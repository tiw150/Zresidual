[{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"installing-zresidual-and-other-packages","dir":"Articles","previous_headings":"","what":"Installing Zresidual and Other packages","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) } library(Zresidual) pkgs <- c(   \"survival\",\"EnvStats\",\"foreach\",\"statip\",\"VGAM\",\"plotrix\",\"actuar\",   \"stringr\",\"Rlab\",\"dplyr\",\"rlang\",\"tidyr\",   \"matrixStats\",\"timeDate\",\"katex\",\"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"installing-z-residua-from-the-source","dir":"Articles","previous_headings":"","what":"Installing Z-residua from the source","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) } library(Zresidual)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"intalling-and-loading-r-packages-used-in-this-demo","dir":"Articles","previous_headings":"","what":"Intalling and Loading R Packages used in this Demo","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"","code":"pkgs <- c(   \"survival\",\"EnvStats\",\"foreach\",\"statip\",\"VGAM\",\"plotrix\",\"actuar\",   \"stringr\",\"Rlab\",\"dplyr\",\"rlang\",\"tidyr\",   \"matrixStats\",\"timeDate\",\"katex\",\"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"vignette explains use Zresidual package calculate Z-residuals based output coxph function survival package R. also serves demonstration use Z-residuals assess overall goodness fit (GOF) identify specific model misspecifications semi-parametric shared frailty models. fully understand detailed definitions example data analysis results, please refer original paper titled “Z-residual diagnostics detecting misspecification functional form covariates shared frailty models.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"definition-of-z-residual","dir":"Articles","previous_headings":"","what":"Definition of Z-residual","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"use Z-residual diagnose shared frailty models Cox proportional hazard setting baseline function unspecified. Suppose g groups individuals, group containing n_i individuals, indexed = 1, 2, , g case clustered failure survival data. Let y_{ij} possibly right-censored observation jth individual ith group, \\delta_{ij} indicator uncensored. normalized randomized survival probabilities (RSPs) y_{ij} shared frailty model defined : \\begin{equation} S_{ij}^{R}(y_{ij}, \\delta_{ij}, U_{ij}) = \\left\\{ \\begin{array}{rl} S_{ij}(y_{ij}), & \\text{$y_{ij}$ uncensored, .e., $\\delta_{ij}=1$,}\\\\ U_{ij}\\,S_{ij}(y_{ij}), & \\text{$y_{ij}$ censored, .e., $\\delta_{ij}=0$,} \\end{array} \\right. \\label{rsp} \\end{equation} U_{ij} uniform random number (0, 1), S_{ij}(\\cdot) postulated survival function t_{ij} given x_{ij}. S_{ij}^{R}(y_{ij}, \\delta_{ij}, U_{ij}) random number 0 S_{ij}(y_{ij}) y_{ij} censored. proved RSPs uniformly distributed (0,1) given x_{} true model . Therefore, RSPs can transformed residuals desired distribution. prefer transform normal quantile: \\begin{equation} r_{ij}^{Z}(y_{ij}, \\delta_{ij}, U_{ij})=-\\Phi^{-1} (S_{ij}^R(y_{ij}, \\delta_{ij}, U_{ij})),\\label{zresid} \\end{equation} normally distributed true model, can conduct model diagnostics Z-residuals censored data way conducting model diagnostics normal regression model. advantages transforming RSPs Z-residuals. First, diagnostics methods checking normal regression rich literature. Second, transforming RSPs normal deviates facilitates identification extremely small large RSPs. frequency small RSPs may small highlighted plots RSPs. However, presence extreme SPs, even , indicative model misspecification. Normal transformation can highlight extreme RSPs.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"examples-for-illustration-and-demonstration","dir":"Articles","previous_headings":"","what":"Examples for Illustration and Demonstration","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"example provides fundamental illustration using Z-residuals diagnosing overall goodness fit (GOF) functional form covariates real application modelling survival times acute myeloid leukemia patients. dataset employed analysis contains 411 patients recorded M. D. Anderson Cancer Center 1980 1996. patients age 60 hailed 24 administrative districts. data collected information survival time acute myeloid leukemia prognostic factors, including age, sex, white blood cell count (wbc) diagnosis, townsend score (tpi) higher values indicate less affluent areas. censoring rate 29.2%. response variable interest survival time days, time entry study death. preliminary study showed wbc highly right-skewed. Logarithm transformation often used reduce impact extremely large values covariate response variable, wbc variable application. However, logarithm transformation may mask impact extremely large values covariate outcome variable. fitted two shared frailty models, one covariates wbc, age, sex tpi, labelled wbc model, log(wbc) replacing wbc, labelled lwbc model. model fitted, can calculate Z-residuals two models. Diagnosing overall goodness--fit (GOF) using Z-residuals follows: QQ plot based Z-residuals can used graphically assess model’s overall GOF, Shapiro-Wilk (SW) Shapiro-Francia (SF) normality tests applied Z-residuals can used numerically test overall GOF model. can see QQ plots Z-residuals two models align well 45 ^\\circ diagonal line. Z-SW tests also give large p-values two models, Z-SW test method normality Z-residuals tested SW test.  Animated QQ plots Z-residuals. Z-residuals can divided k groups cutting linear predictors covariates equally-spaced intervals. can check whether Z-residuals k groups homogeneously distributed. quantitative method assess homogeneity grouped Z-residuals test equality group means variances Z-residuals. employ F-test ANOVA assess equality means Bartlett’s test examine equality variances. scatterplots Z-residuals linear predictor don’t exhibit visible trends; LOWESS lines close horizontal line 0; boxplots Z-residuals grouped cutting linear predictors equal-spaced intervals appear equal means variance across groups. Z-AOV Z-BL linear predictors tests also gives large p-values wbc lwbc models, Z-AOV Z-BL methods applying ANOVA Bartlett test equality means variances Z-residuals groups formed linear predictor. Figure 1: Figure 2: Scatter plots box plots Z-residuals LP wbc (left panels) lwbc (right panels) models fitted survival data acute myeloid leukemia patients Identifing specific model misspecifications using Z-residuals follows: diagnostics results reveal serious misspecification two models. However, inspection Z-residuals covariate wbc/log(wbc) reveals functional form lwbc model likely misspecified. scatterplots comparative boxplots Z-residuals wbc/log(wbc) shown . LOWESS curve wbc model appears align well horizontal line 0 grouped Z-residuals wbc model appear equal means variances across groups. However, diagnosis results lwbc model different. appears non-linear trend LOWESS curve lwbc model grouped Z-residuals appear different means across groups. Z-AOV Z-BL covariate wbc log(wbc) also gives p-values wbc lwbc models shown boxplots. small p-value Z-AOV covariate log(wbc) test lwbc models strongly suggests log transformation wbc likely inappropriate modelling survival time. Figure 2: Figure 3: Scatter plots box plots Z-residuals covariate (wbc) wbc (left panels) lwbc (right panels) models fitted survival data acute myeloid leukemia patients boxplots Z-residuals categorical covariate sex shows grouped Z-residuals appear equal means variances across groups. p-values Z-AOV Z-BL greater 0.05. Shapiro-Wilk (SW) Shapiro-Francia (SF) normality tests applied Z-residuals can used numerically test overall GOF model. Moreover, Shapiro-Franciard (SF) test can employed assess normality censored data. diagnosis GOF survival probabilities can converted diagnosis normality censored Z-residuals. Thus, utilizing gofTestCensored function R package EnvStats, one can examine normality censored Z-residuals. Z-residuals can divided k groups cutting covariates linear predictors equally-spaced intervals. quantitatively evaluate homogeneity grouped Z-residuals, propose testing equality group means group variances. purpose, employ F-test ANOVA assess equality means Bartlett’s test examine equality variances. histograms 1000 replicated Z-residual test p-values wbc lwbc models. red vertical lines histograms show upper bound summaries replicated p-values, p_{min}. histograms show Z-SW, Z-SF, Z-AOV LP tests models give large proportion p-values greater 0.05, large p-values result large p_{min} values. contrast, replicated Z-AOV log(wbc) p-values lwbc model almost smaller 0.001. consistently small Z-AOV log(wbc) p-values confirm log transformation wbc inappropriate modelling survival time. Figure 3: Figure 5: histograms 1000 replicated Z-SW, Z-SF, Z-AOV-LP Z-AOV-log(wbc) p-values wbc model (left panels) lwbc model (right panels) fitted survival times acute myeloid leukemia patients. vertical red lines indicate p_{min} 1000 replicated p-values. Note upper limit x-axis Z-AOV-log(wbc) p-values lwbc model 0.005, 1 others.","code":"data_path <- system.file(\"extdata\", \"LeukSurv.rda\", package = \"Zresidual\") load(data_path)  LeukSurv <- transform(LeukSurv,   district = as.factor(district),   sex      = as.factor(sex),   logwbc   = log(wbc + 0.001) )  LeukSurv <- LeukSurv[LeukSurv$age < 60, ] fit_LeukSurv_wbc <- coxph(Surv(time, cens) ~ age  +sex+ wbc +tpi  +           frailty(district, distribution=\"gamma\"), data= LeukSurv) fit_LeukSurv_logwbc  <- coxph(Surv(time, cens) ~ age +sex + logwbc + tpi +           frailty(district, distribution=\"gamma\"), data= LeukSurv) Zresid.LeukSurv.wbc<-Zresidual(object = fit_LeukSurv_wbc,nrep=1000) Zresid.LeukSurv.logwbc<-Zresidual(object = fit_LeukSurv_logwbc,nrep=1000) for (i in 1:10) {   par(mfrow = c(2, 2), mar = c(4, 4, 1.5, 2))   plot(       Zresid.LeukSurv.wbc,x_axis_var=\"index\",       main.title = \"Z-residual Scatterplot of wbc model\",       irep=i     )   plot(       Zresid.LeukSurv.logwbc,x_axis_var=\"index\",       main.title = \"Z-residual Scatterplot of lwbc model\",       irep=i     )      boxplot(       Zresid.LeukSurv.wbc,x_axis_var = \"lp\",       main.title = \"Z-residual Boxplot of wbc model\",       irep=i     )   boxplot(       Zresid.LeukSurv.logwbc,x_axis_var = \"lp\",       main.title = \"Z-residual Boxplot of lwbc model\",       irep=i     ) } for (i in 1:10) {   par(mfrow = c(2, 2), mar = c(4, 4, 1.5, 2))    plot(     Zresid.LeukSurv.wbc,     x_axis_var = \"wbc\",     main.title = \"Z-residual Scatterplot of wbc model\",     irep=i   )   plot(     Zresid.LeukSurv.logwbc,     x_axis_var = \"logwbc\",     main.title = \"Z-residual Scatterplot of lwbc model\",     irep=i   )    boxplot(     Zresid.LeukSurv.wbc,     x_axis_var = \"wbc\",     main.title = \"Z-residual Boxplot of wbc model\",     irep=i   )   boxplot(     Zresid.LeukSurv.logwbc,     x_axis_var = \"logwbc\",     main.title = \"Z-residual Boxplot of lwbc model\",     irep=i   ) } sw.wbc<-sw.test.zresid(Zresid.LeukSurv.wbc) sw.lwbc<-sw.test.zresid(Zresid.LeukSurv.logwbc) sf.wbc<-sf.test.zresid(Zresid.LeukSurv.wbc) sf.lwbc<-sf.test.zresid(Zresid.LeukSurv.logwbc) gof_tests<-data.frame(sw.wbc,sw.lwbc,sf.wbc,sf.lwbc) aov.wbc.lp<-aov.test.zresid(Zresid.LeukSurv.wbc,X = \"lp\", k.anova=10) aov.lwbc.lp<-aov.test.zresid(Zresid.LeukSurv.logwbc,X = \"lp\", k.anova=10)  bl.wbc.lp<-bartlett.test.zresid(Zresid.LeukSurv.wbc,X = \"lp\", k.bl=10) bl.lwbc.lp<-bartlett.test.zresid(Zresid.LeukSurv.logwbc,X = \"lp\", k.bl=10)  aov.wbc<-aov.test.zresid(Zresid.LeukSurv.wbc,X=\"wbc\", k.anova=10) aov.lwbc<-aov.test.zresid(Zresid.LeukSurv.logwbc,X=\"logwbc\", k.anova=10)  bl.wbc<-bartlett.test.zresid(Zresid.LeukSurv.wbc,X=\"wbc\", k.bl=10) bl.lwbc<-bartlett.test.zresid(Zresid.LeukSurv.logwbc,X=\"logwbc\", k.bl=10)  homogeneity_tests<-data.frame(aov.wbc.lp,aov.lwbc.lp,bl.wbc.lp,bl.lwbc.lp,                               aov.wbc,aov.lwbc,bl.wbc,bl.lwbc)  homogeneity_tests %>%   head(10) %>%    gt() %>%   tab_header(     title = \"Summary of Residual Homogeneity Tests\"   ) %>%   fmt_number(     columns = everything(),     decimals = 4    ) par(mfrow = c(4, 2), mar = c(4, 4, 2, 2))  hist(   sw.wbc,   main  = \"Replicated Z-SW P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-SW P-values for wbc Model\" ) abline(v = pmin.sw.LeukSurv.wbc, col = \"red\")  hist(   sw.lwbc,   main  = \"Replicated Z-SW P-values for lwbc Model\",   breaks = 20,   xlab  = \"Z-SW P-values for lwbc Model\" ) abline(v = pmin.sw.LeukSurv.lwbc, col = \"red\")  hist(   sf.wbc,   main  = \"Replicated Z-SF P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-SF P-values for wbc Model\" ) abline(v = pmin.sf.LeukSurv.wbc, col = \"red\")  hist(   sf.lwbc,   main  = \"Replicated Z-SF P-values for lwbc Model\",   breaks = 20,   xlab  = \"Z-SF P-values for lwbc Model\" ) abline(v = pmin.sf.LeukSurv.lwbc, col = \"red\")  hist(   aov.wbc.lp,   main  = \"Replicated Z-AOV with LP P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-AOV with LP P-values for wbc Model\" ) abline(v = pmin.aov.lp.LeukSurv.wbc, col = \"red\")  hist(   aov.lwbc.lp,   main  = \"Replicated Z-AOV with LP P-values for lwbc Model\",   breaks = 20,   xlab  = \"Z-AOV with LP P-values for lwbc Model\" ) abline(v = pmin.aov.lp.LeukSurv.lwbc, col = \"red\")  hist(   aov.wbc,   main  = \"Replicated Z-AOV with wbc P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-AOV with wbc P-values for wbc Model\" ) abline(v = pmin.aov.wbc.LeukSurv, col = \"red\")  hist(   aov.lwbc,   main  = \"Replicated Z-AOV with wbc P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-AOV with wbc P-values for lwbc Model\" ) abline(v = pmin.aov.lwbc.LeukSurv, col = \"red\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"load-the-real-dataset","dir":"Articles","previous_headings":"","what":"Load the real Dataset","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"example provides fundamental illustration using Z-residuals diagnosing overall goodness fit (GOF) functional form covariates real application modelling survival times acute myeloid leukemia patients. dataset employed analysis contains 411 patients recorded M. D. Anderson Cancer Center 1980 1996. patients age 60 hailed 24 administrative districts. data collected information survival time acute myeloid leukemia prognostic factors, including age, sex, white blood cell count (wbc) diagnosis, townsend score (tpi) higher values indicate less affluent areas. censoring rate 29.2%. response variable interest survival time days, time entry study death. preliminary study showed wbc highly right-skewed. Logarithm transformation often used reduce impact extremely large values covariate response variable, wbc variable application. However, logarithm transformation may mask impact extremely large values covariate outcome variable.","code":"data_path <- system.file(\"extdata\", \"LeukSurv.rda\", package = \"Zresidual\") load(data_path)  LeukSurv <- transform(LeukSurv,   district = as.factor(district),   sex      = as.factor(sex),   logwbc   = log(wbc + 0.001) )  LeukSurv <- LeukSurv[LeukSurv$age < 60, ]"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"fitting-models","dir":"Articles","previous_headings":"","what":"Fitting Models","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"fitted two shared frailty models, one covariates wbc, age, sex tpi, labelled wbc model, log(wbc) replacing wbc, labelled lwbc model.","code":"fit_LeukSurv_wbc <- coxph(Surv(time, cens) ~ age  +sex+ wbc +tpi  +           frailty(district, distribution=\"gamma\"), data= LeukSurv) fit_LeukSurv_logwbc  <- coxph(Surv(time, cens) ~ age +sex + logwbc + tpi +           frailty(district, distribution=\"gamma\"), data= LeukSurv)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"computing-z-residuals","dir":"Articles","previous_headings":"","what":"Computing Z-Residuals","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"model fitted, can calculate Z-residuals two models.","code":"Zresid.LeukSurv.wbc<-Zresidual(object = fit_LeukSurv_wbc,nrep=1000) Zresid.LeukSurv.logwbc<-Zresidual(object = fit_LeukSurv_logwbc,nrep=1000)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"inspecting-the-normality-of-z-residuals-for-checking-overall-gof","dir":"Articles","previous_headings":"","what":"Inspecting the Normality of Z-Residuals for Checking Overall GOF","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"Diagnosing overall goodness--fit (GOF) using Z-residuals follows: QQ plot based Z-residuals can used graphically assess model’s overall GOF, Shapiro-Wilk (SW) Shapiro-Francia (SF) normality tests applied Z-residuals can used numerically test overall GOF model. can see QQ plots Z-residuals two models align well 45 ^\\circ diagonal line. Z-SW tests also give large p-values two models, Z-SW test method normality Z-residuals tested SW test.  Animated QQ plots Z-residuals. Z-residuals can divided k groups cutting linear predictors covariates equally-spaced intervals. can check whether Z-residuals k groups homogeneously distributed. quantitative method assess homogeneity grouped Z-residuals test equality group means variances Z-residuals. employ F-test ANOVA assess equality means Bartlett’s test examine equality variances. scatterplots Z-residuals linear predictor don’t exhibit visible trends; LOWESS lines close horizontal line 0; boxplots Z-residuals grouped cutting linear predictors equal-spaced intervals appear equal means variance across groups. Z-AOV Z-BL linear predictors tests also gives large p-values wbc lwbc models, Z-AOV Z-BL methods applying ANOVA Bartlett test equality means variances Z-residuals groups formed linear predictor. Figure 1: Figure 2: Scatter plots box plots Z-residuals LP wbc (left panels) lwbc (right panels) models fitted survival data acute myeloid leukemia patients Identifing specific model misspecifications using Z-residuals follows: diagnostics results reveal serious misspecification two models. However, inspection Z-residuals covariate wbc/log(wbc) reveals functional form lwbc model likely misspecified. scatterplots comparative boxplots Z-residuals wbc/log(wbc) shown . LOWESS curve wbc model appears align well horizontal line 0 grouped Z-residuals wbc model appear equal means variances across groups. However, diagnosis results lwbc model different. appears non-linear trend LOWESS curve lwbc model grouped Z-residuals appear different means across groups. Z-AOV Z-BL covariate wbc log(wbc) also gives p-values wbc lwbc models shown boxplots. small p-value Z-AOV covariate log(wbc) test lwbc models strongly suggests log transformation wbc likely inappropriate modelling survival time. Figure 2: Figure 3: Scatter plots box plots Z-residuals covariate (wbc) wbc (left panels) lwbc (right panels) models fitted survival data acute myeloid leukemia patients boxplots Z-residuals categorical covariate sex shows grouped Z-residuals appear equal means variances across groups. p-values Z-AOV Z-BL greater 0.05.","code":"for (i in 1:10) {   par(mfrow = c(2, 2), mar = c(4, 4, 1.5, 2))   plot(       Zresid.LeukSurv.wbc,x_axis_var=\"index\",       main.title = \"Z-residual Scatterplot of wbc model\",       irep=i     )   plot(       Zresid.LeukSurv.logwbc,x_axis_var=\"index\",       main.title = \"Z-residual Scatterplot of lwbc model\",       irep=i     )      boxplot(       Zresid.LeukSurv.wbc,x_axis_var = \"lp\",       main.title = \"Z-residual Boxplot of wbc model\",       irep=i     )   boxplot(       Zresid.LeukSurv.logwbc,x_axis_var = \"lp\",       main.title = \"Z-residual Boxplot of lwbc model\",       irep=i     ) } for (i in 1:10) {   par(mfrow = c(2, 2), mar = c(4, 4, 1.5, 2))    plot(     Zresid.LeukSurv.wbc,     x_axis_var = \"wbc\",     main.title = \"Z-residual Scatterplot of wbc model\",     irep=i   )   plot(     Zresid.LeukSurv.logwbc,     x_axis_var = \"logwbc\",     main.title = \"Z-residual Scatterplot of lwbc model\",     irep=i   )    boxplot(     Zresid.LeukSurv.wbc,     x_axis_var = \"wbc\",     main.title = \"Z-residual Boxplot of wbc model\",     irep=i   )   boxplot(     Zresid.LeukSurv.logwbc,     x_axis_var = \"logwbc\",     main.title = \"Z-residual Boxplot of lwbc model\",     irep=i   ) }"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"diagnostic-tests-with-z-residuals","dir":"Articles","previous_headings":"","what":"Diagnostic Tests with Z-residuals","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"Shapiro-Wilk (SW) Shapiro-Francia (SF) normality tests applied Z-residuals can used numerically test overall GOF model. Moreover, Shapiro-Franciard (SF) test can employed assess normality censored data. diagnosis GOF survival probabilities can converted diagnosis normality censored Z-residuals. Thus, utilizing gofTestCensored function R package EnvStats, one can examine normality censored Z-residuals. Z-residuals can divided k groups cutting covariates linear predictors equally-spaced intervals. quantitatively evaluate homogeneity grouped Z-residuals, propose testing equality group means group variances. purpose, employ F-test ANOVA assess equality means Bartlett’s test examine equality variances. histograms 1000 replicated Z-residual test p-values wbc lwbc models. red vertical lines histograms show upper bound summaries replicated p-values, p_{min}. histograms show Z-SW, Z-SF, Z-AOV LP tests models give large proportion p-values greater 0.05, large p-values result large p_{min} values. contrast, replicated Z-AOV log(wbc) p-values lwbc model almost smaller 0.001. consistently small Z-AOV log(wbc) p-values confirm log transformation wbc inappropriate modelling survival time. Figure 3: Figure 5: histograms 1000 replicated Z-SW, Z-SF, Z-AOV-LP Z-AOV-log(wbc) p-values wbc model (left panels) lwbc model (right panels) fitted survival times acute myeloid leukemia patients. vertical red lines indicate p_{min} 1000 replicated p-values. Note upper limit x-axis Z-AOV-log(wbc) p-values lwbc model 0.005, 1 others.","code":"sw.wbc<-sw.test.zresid(Zresid.LeukSurv.wbc) sw.lwbc<-sw.test.zresid(Zresid.LeukSurv.logwbc) sf.wbc<-sf.test.zresid(Zresid.LeukSurv.wbc) sf.lwbc<-sf.test.zresid(Zresid.LeukSurv.logwbc) gof_tests<-data.frame(sw.wbc,sw.lwbc,sf.wbc,sf.lwbc) aov.wbc.lp<-aov.test.zresid(Zresid.LeukSurv.wbc,X = \"lp\", k.anova=10) aov.lwbc.lp<-aov.test.zresid(Zresid.LeukSurv.logwbc,X = \"lp\", k.anova=10)  bl.wbc.lp<-bartlett.test.zresid(Zresid.LeukSurv.wbc,X = \"lp\", k.bl=10) bl.lwbc.lp<-bartlett.test.zresid(Zresid.LeukSurv.logwbc,X = \"lp\", k.bl=10)  aov.wbc<-aov.test.zresid(Zresid.LeukSurv.wbc,X=\"wbc\", k.anova=10) aov.lwbc<-aov.test.zresid(Zresid.LeukSurv.logwbc,X=\"logwbc\", k.anova=10)  bl.wbc<-bartlett.test.zresid(Zresid.LeukSurv.wbc,X=\"wbc\", k.bl=10) bl.lwbc<-bartlett.test.zresid(Zresid.LeukSurv.logwbc,X=\"logwbc\", k.bl=10)  homogeneity_tests<-data.frame(aov.wbc.lp,aov.lwbc.lp,bl.wbc.lp,bl.lwbc.lp,                               aov.wbc,aov.lwbc,bl.wbc,bl.lwbc)  homogeneity_tests %>%   head(10) %>%    gt() %>%   tab_header(     title = \"Summary of Residual Homogeneity Tests\"   ) %>%   fmt_number(     columns = everything(),     decimals = 4    ) par(mfrow = c(4, 2), mar = c(4, 4, 2, 2))  hist(   sw.wbc,   main  = \"Replicated Z-SW P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-SW P-values for wbc Model\" ) abline(v = pmin.sw.LeukSurv.wbc, col = \"red\")  hist(   sw.lwbc,   main  = \"Replicated Z-SW P-values for lwbc Model\",   breaks = 20,   xlab  = \"Z-SW P-values for lwbc Model\" ) abline(v = pmin.sw.LeukSurv.lwbc, col = \"red\")  hist(   sf.wbc,   main  = \"Replicated Z-SF P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-SF P-values for wbc Model\" ) abline(v = pmin.sf.LeukSurv.wbc, col = \"red\")  hist(   sf.lwbc,   main  = \"Replicated Z-SF P-values for lwbc Model\",   breaks = 20,   xlab  = \"Z-SF P-values for lwbc Model\" ) abline(v = pmin.sf.LeukSurv.lwbc, col = \"red\")  hist(   aov.wbc.lp,   main  = \"Replicated Z-AOV with LP P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-AOV with LP P-values for wbc Model\" ) abline(v = pmin.aov.lp.LeukSurv.wbc, col = \"red\")  hist(   aov.lwbc.lp,   main  = \"Replicated Z-AOV with LP P-values for lwbc Model\",   breaks = 20,   xlab  = \"Z-AOV with LP P-values for lwbc Model\" ) abline(v = pmin.aov.lp.LeukSurv.lwbc, col = \"red\")  hist(   aov.wbc,   main  = \"Replicated Z-AOV with wbc P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-AOV with wbc P-values for wbc Model\" ) abline(v = pmin.aov.wbc.LeukSurv, col = \"red\")  hist(   aov.lwbc,   main  = \"Replicated Z-AOV with wbc P-values for wbc Model\",   breaks = 20,   xlab  = \"Z-AOV with wbc P-values for lwbc Model\" ) abline(v = pmin.aov.lwbc.LeukSurv, col = \"red\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"other-residual-calculation","dir":"Articles","previous_headings":"","what":"Other residual calculation","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"normality censored Z-residuals tested extended SF method censored observations, implemented gofTestCensored R package EnvStats. overall GOF tests graphical checking Cox-Snell residuals show wbc lwbc models provide adequate fits dataset. estimated CHFs CS residuals wbc lwbc models align closely along 45^{\\circ} diagonal line.  martingale residuals mostly within interval (-3, 1) two models. scatterplots martingale residuals wbc model, LOWESS curves slight upward slope left, lwbc model, display pronounced downward curve. lines demonstrate noticeable non-horizontal trends.  deviance residuals symmetrically distributed martingale residuals mostly within interval (-3, 3). models, scatterplots deviance residuals exhibit strikingly non-horizontal trends LOWESS curves.","code":"censored.Zresid.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,                                       data=LeukSurv,                                       residual.type=\"censored Z-residual\")  censored.Zresid.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type=\"censored Z-residual\")  gof.censored.zresidual(censored.Zresidual=censored.Zresid.LeukSurv.wbc) [1] 0.5702324 gof.censored.zresidual(censored.Zresidual=censored.Zresid.LeukSurv.logwbc) [1] 0.07535993 ##unmodified CS residuals ucs.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,data= LeukSurv,residual.type = \"Cox-Snell\" ) ucs.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type = \"Cox-Snell\" ) ##unmodified CS residuals par(mfrow = c(1, 2), mar = c(4, 4, 3, 2)) plot.cs.residual(ucs.LeukSurv.wbc,main.title = \"CS Residuals of wbc model\") plot.cs.residual(ucs.LeukSurv.logwbc,main.title = \"CS Residuals of lwbc model\") martg.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,data= LeukSurv,residual.type = \"martingale\") martg.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type = \"martingale\" ) par(mfrow = c(1,2)) plot.martg.resid(martg.LeukSurv.wbc,x_axis_var=\"wbc\",main.title = \"Martingale Residuals of wbc Model\") plot.martg.resid(martg.LeukSurv.logwbc,x_axis_var=\"logwbc\",main.title = \"Martingale Residuals of lwbc Model\") #Deviance residuals dev.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,data= LeukSurv,residual.type = \"deviance\" ) dev.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type = \"deviance\" ) par(mfrow = c(1,2)) plot.dev.resid(dev.LeukSurv.wbc,x_axis_var=\"wbc\",main.title = \"Deviance Residuals of wbc Model\") plot.dev.resid(dev.LeukSurv.logwbc,x_axis_var=\"logwbc\",main.title = \"Deviance Residuals of lwbc Model\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"censored-z-residuals","dir":"Articles","previous_headings":"","what":"censored Z-residuals","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"normality censored Z-residuals tested extended SF method censored observations, implemented gofTestCensored R package EnvStats.","code":"censored.Zresid.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,                                       data=LeukSurv,                                       residual.type=\"censored Z-residual\")  censored.Zresid.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type=\"censored Z-residual\")  gof.censored.zresidual(censored.Zresidual=censored.Zresid.LeukSurv.wbc) [1] 0.5702324 gof.censored.zresidual(censored.Zresidual=censored.Zresid.LeukSurv.logwbc) [1] 0.07535993"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"cox-snell-residual","dir":"Articles","previous_headings":"","what":"Cox-Snell residual","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"overall GOF tests graphical checking Cox-Snell residuals show wbc lwbc models provide adequate fits dataset. estimated CHFs CS residuals wbc lwbc models align closely along 45^{\\circ} diagonal line.","code":"##unmodified CS residuals ucs.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,data= LeukSurv,residual.type = \"Cox-Snell\" ) ucs.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type = \"Cox-Snell\" ) ##unmodified CS residuals par(mfrow = c(1, 2), mar = c(4, 4, 3, 2)) plot.cs.residual(ucs.LeukSurv.wbc,main.title = \"CS Residuals of wbc model\") plot.cs.residual(ucs.LeukSurv.logwbc,main.title = \"CS Residuals of lwbc model\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"martingale-residual","dir":"Articles","previous_headings":"","what":"Martingale residual","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"martingale residuals mostly within interval (-3, 1) two models. scatterplots martingale residuals wbc model, LOWESS curves slight upward slope left, lwbc model, display pronounced downward curve. lines demonstrate noticeable non-horizontal trends.","code":"martg.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,data= LeukSurv,residual.type = \"martingale\") martg.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type = \"martingale\" ) par(mfrow = c(1,2)) plot.martg.resid(martg.LeukSurv.wbc,x_axis_var=\"wbc\",main.title = \"Martingale Residuals of wbc Model\") plot.martg.resid(martg.LeukSurv.logwbc,x_axis_var=\"logwbc\",main.title = \"Martingale Residuals of lwbc Model\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"deviance-residual","dir":"Articles","previous_headings":"","what":"Deviance residual","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"deviance residuals symmetrically distributed martingale residuals mostly within interval (-3, 3). models, scatterplots deviance residuals exhibit strikingly non-horizontal trends LOWESS curves.","code":"#Deviance residuals dev.LeukSurv.wbc<-surv_residuals(fit.object = fit_LeukSurv_wbc,data= LeukSurv,residual.type = \"deviance\" ) dev.LeukSurv.logwbc<-surv_residuals(fit.object = fit_LeukSurv_logwbc,data= LeukSurv,residual.type = \"deviance\" ) par(mfrow = c(1,2)) plot.dev.resid(dev.LeukSurv.wbc,x_axis_var=\"wbc\",main.title = \"Deviance Residuals of wbc Model\") plot.dev.resid(dev.LeukSurv.logwbc,x_axis_var=\"logwbc\",main.title = \"Deviance Residuals of lwbc Model\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_coxph_survival.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Z-residual diagnostic tool for assessing covariate functional form in shared frailty models","text":"Wu, T., Li, L., & Feng, C. (2024). Z-residual diagnostic tool assessing covariate functional form shared frailty models. Journal Applied Statistics, 52(1), 28–58. https://doi.org/10.1080/02664763.2024.2355551","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"installing-zresidual-and-other-packages","dir":"Articles","previous_headings":"","what":"Installing Zresidual and Other packages","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) }  library(Zresidual) pkgs <- c(   \"survival\",\"EnvStats\",\"foreach\",\"statip\",\"VGAM\",\"plotrix\",\"actuar\",   \"stringr\",\"Rlab\",\"dplyr\",\"rlang\",\"tidyr\",   \"matrixStats\",\"timeDate\",\"katex\",\"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"installing-z-residua-from-the-source","dir":"Articles","previous_headings":"","what":"Installing Z-residua from the source","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) }  library(Zresidual)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"intalling-and-loading-r-packages-used-in-this-demo","dir":"Articles","previous_headings":"","what":"Intalling and Loading R Packages used in this Demo","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"","code":"pkgs <- c(   \"survival\",\"EnvStats\",\"foreach\",\"statip\",\"VGAM\",\"plotrix\",\"actuar\",   \"stringr\",\"Rlab\",\"dplyr\",\"rlang\",\"tidyr\",   \"matrixStats\",\"timeDate\",\"katex\",\"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"vignette explains use Zresidual package calculate cross-validatory (CV) Z-residuals based output coxph function survival package R. also serves demonstration use cross-validatory Z-residuals identify outliers semi-parametric shared frailty models. fully understand detailed definitions example data analysis results, please refer original paper titled “Cross-validatory Z-Residual Diagnosing Shared Frailty Models”.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"definition-of-cross-validatory-z-residual","dir":"Articles","previous_headings":"","what":"Definition of Cross-validatory Z-residual","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"use Z-residual diagnose shared frailty models Cox proportional hazard setting baseline function unspecified. Suppose g groups individuals, group containing n_i individuals, indexed = 1, 2, , g case clustered failure survival data. Let y_{ij} possibly right-censored observation jth individual ith group, \\delta_{ij} indicator uncensored. normalized randomized survival probabilities (RSPs) y_{ij} shared frailty model defined : \\begin{equation} S_{ij}^{R}(y_{ij}, \\delta_{ij}, U_{ij}) = \\left\\{ \\begin{array}{rl} S_{ij}(y_{ij}), & \\text{$y_{ij}$ uncensored, .e., $\\delta_{ij}=1$,}\\\\ U_{ij}\\,S_{ij}(y_{ij}), & \\text{$y_{ij}$ censored, .e., $\\delta_{ij}=0$,} \\end{array} \\right. \\label{rsp} \\end{equation} U_{ij} uniform random number (0, 1), S_{ij}(\\cdot) postulated survival function t_{ij} given x_{ij}. S_{ij}^{R}(y_{ij}, \\delta_{ij}, U_{ij}) random number 0 S_{ij}(y_{ij}) y_{ij} censored. proved RSPs uniformly distributed (0,1) given x_{} true model. Therefore, RSPs can transformed residuals desired distribution. prefer transform normal quantile: \\begin{equation} r_{ij}^{Z}(y_{ij}, \\delta_{ij}, U_{ij})=-\\Phi^{-1} (S_{ij}^R(y_{ij}, \\delta_{ij}, U_{ij})),\\label{zresid} \\end{equation} normally distributed true model, can conduct model diagnostics Z-residuals censored data way conducting model diagnostics normal regression model. advantages transforming RSPs Z-residuals. First, diagnostics methods checking normal regression rich literature. Second, transforming RSPs normal deviates facilitates identification extremely small large RSPs. frequency small RSPs may small highlighted plots RSPs. However, presence extreme SPs, even , indicative model misspecification. Normal transformation can highlight extreme RSPs. study, employ leave-one-cross-validation (LOOCV) 10-fold cross-validation (10-fold CV) techniques compute cross-validatory Z-residuals. LOOCV Z-residual, one observation, t_{ij}^{test}, excluded dataset n observations. remaining observations, acting training dataset, used parameter estimation shared frailty model. Fitting model training dataset produces estimated regression coefficients, \\hat{\\beta'}, frailty effects, \\hat{z_i}. Breslow estimator helps estimate cumulative baseline hazard (\\hat{H_0}). survival function \\hat{S}{ij} (y{ij}) test observation y_{ij}^{test} computed using: \\begin{equation} \\hat{S}_{ij}(y_{ij}^{test}) = \\exp \\{- \\hat{z_i} \\exp(\\hat{\\beta'} x_{ij}) \\hat{H}_0(y_{ij}^{test}) \\}. \\end{equation} Subsequently, RSP observed t_{ij} defined : \\begin{equation} \\hat{S}_{ij}^{R}(t_{ij}^{test}, d_{ij}, U_{ij})= \\left\\{ \\begin{array}{rl} \\hat{S}_{ij}(t_{ij}^{test}), & \\text{$t_{ij}^{test}$ uncensored, .e., $d_{ij}=1$,}\\\\ U_{ij}\\,\\hat{S}_{ij}(t_{ij}^{test}), & \\text{$t_{ij}^{test}$ censored, .e., $d_{ij}=0$.} \\end{array} \\right. \\end{equation} Resulting Z-residual t_{ij}^{test}: \\begin{equation} \\hat{z}_{ij}(t_{ij}^{test}, d_{ij}, U_{ij})=-\\Phi^{-1} (\\hat{S}_{ij}^R(t_{ij}^{test}, d_{ij}, U_{ij})). \\end{equation} repeating steps observation (n times), LOOCV predictive Z-residual calculated observation. cluster-based categorical covariate values, specific considerations employed LOOCV k-fold CV methods. Clusters one observation included training dataset, similar requirements imposed categorical covariates. , cross-validatory Z-residuals observations designated NA implementation.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"examples-for-illustration-and-demonstration","dir":"Articles","previous_headings":"","what":"Examples for Illustration and Demonstration","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"example demonstrates practical application cross-validatory Z-residuals identifying outliers within study kidney infections. dataset comprises records 38 kidney patients using portable dialysis machine. documents times first second recurrences kidney infections patients. patient’s survival time defined duration infection catheter insertion. patient records considered clusters due shared frailty, signifying common effect across patients. Instances catheter removed reasons infection treated censored observations, accounting 24% dataset. dataset encompasses 38 patient clusters, patient exactly two observations, resulting total sample size 76. dataset frequently employed exemplify shared frailty models. fit shared gamma frailty model three covariates: covariates: age years, gender (male female), four disease types (0=GN, 1=, 2=PKD, 3=). computed Z-residuals using -CV LOOCV methods kidney infection dataset. Given similarity performance 10-fold CV LOOCV Z-residual methods demonstrated simulation studies manageable computational load, focused LOOCV method. first second columns Figure 1 display scatterplots index QQ plots Z-residuals calculated -CV LOOCV methods. -CV Z-residuals predominantly fall within range -3 3, displaying alignment 45^\\circ straight line QQ plot. QQ plot -CV Z-residuals indicates SW p-value around 0.70, signifying well-fitted model dataset. Thus, diagnostic results using -CV Z-residuals suggest suitability shared frailty model dataset without identifying outliers. However, analysis scatterplot LOOCV Z-residuals reveals Z-residuals cases labeled 20 42 exceed 3. instances considered outliers shared frailty model. QQ plot LOOCV Z-residuals displays noticeable deviation 45^\\circ straight line, attributed considerable Z-residuals two identified outliers. SW p-value LOOCV Z-residuals notably small, measuring less 0.01, evident QQ plot. summary, diagnosis results LOOCV Z-residuals suggest fitted shared frailty model inadequate dataset, two cases exhibit excessive Z-residuals, categorized outliers model.  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset. Shapiro-Wilk (SW) Shapiro-Francia (SF) normality tests applied Z-residuals can used numerically test overall GOF model. exists randomness Z-residuals censored observations, meaning different sets Z-residuals can generated dataset using distinct random numbers. Thus, test robustness previously conducted diagnosis, replicated large number realizations Z-residuals. Figure 2 exhibits histograms 1000 SW test p-values, derived set -CV LOOCV Z-residuals. 95% SW p-values -CV Z-residuals surpass 0.05, whereas 100% SW p-values LOOCV Z-residuals fall 0.05. consistency across numerous replications confirms evaluation misspecification shared frailty model incidental specific set LOOCV Z-residuals recurring conclusion supported extensive Z-residual replications.","code":"data_path <- system.file(\"extdata\", \"kidney.rda\", package = \"Zresidual\") load(data_path) kidney$sex <- ifelse(kidney$sex == 1, \"male\", \"female\") kidney$sex<-as.factor(kidney$sex) kidney$id<-as.factor(kidney$id) fit_kidney <-coxph(Surv(time, status) ~ age + sex + disease+frailty(id, distribution=\"gamma\"), data= kidney) Zresid.kidney<-Zresidual(fit_kidney,nrep=10) CVZresid.kidney<-CV.Zresidual(fit_kidney,nrep=10,nfolds = nrow(kidney)) CVZresid.kidney_new <- CVZresid.kidney [-57, ] for (i in 1:10) { par(mfrow = c(2, 2), mar = c(4, 4, 2, 2)) plot.zresid(Zresid.kidney,x_axis_var=\"index\", main.title = \"Z-residual Scatterplot\",      outlier.return = TRUE,irep=i) plot.zresid(CVZresid.kidney_new,x_axis_var=\"index\", main.title = \"LOOCV Z-residual Scatterplot\",      outlier.return = TRUE,irep=i) qqnorm.zresid(Zresid.kidney, main.title = \"Z-residual QQ plot\",irep=i) qqnorm.zresid(CVZresid.kidney_new, main.title = \"LOOCV Z-residual QQ plot\",irep=i) } library(gt) library(tibble) library(dplyr) sw.kidney<-sw.test.zresid(Zresid.kidney) sw.kidney.cv<-sw.test.zresid(CVZresid.kidney) sf.kidney<-sf.test.zresid(Zresid.kidney) sf.kidney.cv<-sf.test.zresid(CVZresid.kidney) gof_tests<-data.frame(sw.kidney,sw.kidney.cv,sf.kidney,sf.kidney.cv) gof_tests_table <- gof_tests %>%   rownames_to_column(var = \"Metric\") %>%   gt() %>%   tab_spanner(     label = \"Shapiro-Wilk\",     columns = c(sw.kidney, sw.kidney.cv)   ) %>%   tab_spanner(     label = \"Shapiro-Francia\",     columns = c(sf.kidney, sf.kidney.cv)   ) %>%   fmt_number(     columns = -Metric,     decimals = 4   ) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\"   )  gof_tests_table par(mfrow = c(2,2),mar=c(4,4,2,2)) hist(sw.kidney,main=\"Replicated Z-SW P-values, No CV\",breaks=20,      xlab=\"Z-SW P-values\") abline(v=pmin.sw.kidney,col=\"red\") hist(sw.kidney.cv,main=\"Replicated Z-SW P-values, LOOCV\",breaks=20,      xlab=\"Z-SW P-values\") abline(v=pmin.sw.kidney.cv,col=\"red\")  hist(sf.kidney,main=\"Replicated Z-SF P-values, No CV\",breaks=20,      xlab=\"Z-SF P-values\") abline(v=pmin.sf.kidney,col=\"red\") hist(sf.kidney.cv,main=\"Replicated Z-SF P-values, LOOCV\",breaks=20,      xlab=\"Z-SF P-values\") abline(v=pmin.sf.kidney.cv,col=\"red\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"load-the-real-dataset","dir":"Articles","previous_headings":"","what":"Load the real Dataset","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"example demonstrates practical application cross-validatory Z-residuals identifying outliers within study kidney infections. dataset comprises records 38 kidney patients using portable dialysis machine. documents times first second recurrences kidney infections patients. patient’s survival time defined duration infection catheter insertion. patient records considered clusters due shared frailty, signifying common effect across patients. Instances catheter removed reasons infection treated censored observations, accounting 24% dataset. dataset encompasses 38 patient clusters, patient exactly two observations, resulting total sample size 76. dataset frequently employed exemplify shared frailty models.","code":"data_path <- system.file(\"extdata\", \"kidney.rda\", package = \"Zresidual\") load(data_path) kidney$sex <- ifelse(kidney$sex == 1, \"male\", \"female\") kidney$sex<-as.factor(kidney$sex) kidney$id<-as.factor(kidney$id)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"fitting-models","dir":"Articles","previous_headings":"","what":"Fitting Models","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"fit shared gamma frailty model three covariates: covariates: age years, gender (male female), four disease types (0=GN, 1=, 2=PKD, 3=).","code":"fit_kidney <-coxph(Surv(time, status) ~ age + sex + disease+frailty(id, distribution=\"gamma\"), data= kidney)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"z-residual-and-loocv-z-residual-calculation","dir":"Articles","previous_headings":"","what":"Z-residual and LOOCV Z-residual calculation","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"computed Z-residuals using -CV LOOCV methods kidney infection dataset. Given similarity performance 10-fold CV LOOCV Z-residual methods demonstrated simulation studies manageable computational load, focused LOOCV method.","code":"Zresid.kidney<-Zresidual(fit_kidney,nrep=10) CVZresid.kidney<-CV.Zresidual(fit_kidney,nrep=10,nfolds = nrow(kidney)) CVZresid.kidney_new <- CVZresid.kidney [-57, ]"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"inspecting-the-normality-of-z-residuals-for-checking-overall-gof","dir":"Articles","previous_headings":"","what":"Inspecting the Normality of Z-Residuals for Checking Overall GOF","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"first second columns Figure 1 display scatterplots index QQ plots Z-residuals calculated -CV LOOCV methods. -CV Z-residuals predominantly fall within range -3 3, displaying alignment 45^\\circ straight line QQ plot. QQ plot -CV Z-residuals indicates SW p-value around 0.70, signifying well-fitted model dataset. Thus, diagnostic results using -CV Z-residuals suggest suitability shared frailty model dataset without identifying outliers. However, analysis scatterplot LOOCV Z-residuals reveals Z-residuals cases labeled 20 42 exceed 3. instances considered outliers shared frailty model. QQ plot LOOCV Z-residuals displays noticeable deviation 45^\\circ straight line, attributed considerable Z-residuals two identified outliers. SW p-value LOOCV Z-residuals notably small, measuring less 0.01, evident QQ plot. summary, diagnosis results LOOCV Z-residuals suggest fitted shared frailty model inadequate dataset, two cases exhibit excessive Z-residuals, categorized outliers model.  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset.","code":"for (i in 1:10) { par(mfrow = c(2, 2), mar = c(4, 4, 2, 2)) plot.zresid(Zresid.kidney,x_axis_var=\"index\", main.title = \"Z-residual Scatterplot\",      outlier.return = TRUE,irep=i) plot.zresid(CVZresid.kidney_new,x_axis_var=\"index\", main.title = \"LOOCV Z-residual Scatterplot\",      outlier.return = TRUE,irep=i) qqnorm.zresid(Zresid.kidney, main.title = \"Z-residual QQ plot\",irep=i) qqnorm.zresid(CVZresid.kidney_new, main.title = \"LOOCV Z-residual QQ plot\",irep=i) }"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"diagnostic-tests-with-z-residuals","dir":"Articles","previous_headings":"","what":"Diagnostic Tests with Z-residuals","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"Shapiro-Wilk (SW) Shapiro-Francia (SF) normality tests applied Z-residuals can used numerically test overall GOF model. exists randomness Z-residuals censored observations, meaning different sets Z-residuals can generated dataset using distinct random numbers. Thus, test robustness previously conducted diagnosis, replicated large number realizations Z-residuals. Figure 2 exhibits histograms 1000 SW test p-values, derived set -CV LOOCV Z-residuals. 95% SW p-values -CV Z-residuals surpass 0.05, whereas 100% SW p-values LOOCV Z-residuals fall 0.05. consistency across numerous replications confirms evaluation misspecification shared frailty model incidental specific set LOOCV Z-residuals recurring conclusion supported extensive Z-residual replications.","code":"library(gt) library(tibble) library(dplyr) sw.kidney<-sw.test.zresid(Zresid.kidney) sw.kidney.cv<-sw.test.zresid(CVZresid.kidney) sf.kidney<-sf.test.zresid(Zresid.kidney) sf.kidney.cv<-sf.test.zresid(CVZresid.kidney) gof_tests<-data.frame(sw.kidney,sw.kidney.cv,sf.kidney,sf.kidney.cv) gof_tests_table <- gof_tests %>%   rownames_to_column(var = \"Metric\") %>%   gt() %>%   tab_spanner(     label = \"Shapiro-Wilk\",     columns = c(sw.kidney, sw.kidney.cv)   ) %>%   tab_spanner(     label = \"Shapiro-Francia\",     columns = c(sf.kidney, sf.kidney.cv)   ) %>%   fmt_number(     columns = -Metric,     decimals = 4   ) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\"   )  gof_tests_table par(mfrow = c(2,2),mar=c(4,4,2,2)) hist(sw.kidney,main=\"Replicated Z-SW P-values, No CV\",breaks=20,      xlab=\"Z-SW P-values\") abline(v=pmin.sw.kidney,col=\"red\") hist(sw.kidney.cv,main=\"Replicated Z-SW P-values, LOOCV\",breaks=20,      xlab=\"Z-SW P-values\") abline(v=pmin.sw.kidney.cv,col=\"red\")  hist(sf.kidney,main=\"Replicated Z-SF P-values, No CV\",breaks=20,      xlab=\"Z-SF P-values\") abline(v=pmin.sf.kidney,col=\"red\") hist(sf.kidney.cv,main=\"Replicated Z-SF P-values, LOOCV\",breaks=20,      xlab=\"Z-SF P-values\") abline(v=pmin.sf.kidney.cv,col=\"red\")"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_cv_zresidual_survival.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Demo of Cross-validatory Z-Residual for Diagnosing Shared Frailty Models","text":"Wu, T., Feng, C., & Li, L. (2024). Cross-Validatory Z-Residual Diagnosing Shared Frailty Models. American Statistician, 79(2), 198–211. https://doi.org/10.1080/00031305.2024.2421370","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"installing-zresidual-and-other-packages","dir":"Articles","previous_headings":"","what":"Installing Zresidual and Other packages","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) } library(Zresidual) # Vector of required packages pkgs <- c(   \"brms\",\"distributions3\",\"foreach\", \"statip\", \"VGAM\", \"plotrix\", \"actuar\",   \"stringr\", \"Rlab\", \"dplyr\", \"rlang\", \"tidyr\",   \"matrixStats\", \"timeDate\", \"katex\", \"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"installing-z-residua-from-the-source","dir":"Articles","previous_headings":"","what":"Installing Z-residua from the source","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) } library(Zresidual)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"intalling-and-loading-r-packages-used-in-this-demo","dir":"Articles","previous_headings":"","what":"Intalling and Loading R Packages used in this Demo","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"","code":"# Vector of required packages pkgs <- c(   \"brms\",\"distributions3\",\"foreach\", \"statip\", \"VGAM\", \"plotrix\", \"actuar\",   \"stringr\", \"Rlab\", \"dplyr\", \"rlang\", \"tidyr\",   \"matrixStats\", \"timeDate\", \"katex\", \"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"vignette demonstrates use Zresidual package compute component-wise Z-residuals diagnosing Bayesian hurdle models (Mullahy 1986), based output brms package R (Bürkner 2017) can calculated separately zero, count hurdle components reveal potential model misspecifications. examples illustrate practical use residuals RPP (Feng, Li, Sadeghpour 2020) diagnostics.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"definitions-of-component-wise-z-residuals-for-bayesian-hurdle-models","dir":"Articles","previous_headings":"","what":"Definitions of Component-wise Z-residuals for Bayesian Hurdle Models","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"logistic component modeling probability structural zeros. count component modeling positive counts using zero-truncated distribution. Let C_i \\\\{0, 1\\}, C_i = 1 indicates non-zero value, C_i = 0 indicates zero value ^\\th observations. C_i=1, corresponding count model operates y_i^+ \\\\{1, 2, \\dots\\}, .e., positive counts . \\pi^o_i : zero porbability, \\mu_i^{(t)}, \\phi^{(t)} : parameters count component. given observation y_i^\\text{obs}, component-wise posterior predictive PMF survival functions defined . \\begin{equation} p_i^{\\text{post}, \\pi^o_irdle}(y_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} {\\pi^o_i}^{(t)} & \\text{} y_i^\\text{obs} = 0, \\\\ (1 - {\\pi^o_i}^{(t)}) \\cdot\\frac{p_i^\\text{UT}(y_i^\\text{obs} | \\theta^{(t)})}{1 - p_i^\\text{UT}(0 | \\theta^{(t)})} & \\text{} y_i^\\text{obs} =1, 2, \\ldots,\\\\ 0 & \\text{otherwise.} \\end{cases} \\end{equation} \\begin{equation} S_i^{\\text{post}, \\pi^o_irdle}(y_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} 1 & \\text{} y_i^\\text{obs} < 0, \\\\ 1-{\\pi^o_i}^{(t)} & \\text{} 0 \\le y_i^\\text{obs} < 1, \\\\ (1 - {\\pi^o_i}^{(t)}) \\cdot \\frac{S_i^\\text{UT}(y_i^\\text{obs} \\mid \\theta^{(t)})}{1-p_i^\\text{UT}(0 \\mid \\theta^{(t)})} & \\text{} y_i^\\text{obs} \\ge 1. \\end{cases} \\end{equation} \\begin{equation} \\label{componentwise_logistic_pmf} p_i^{\\text{post}, \\text{logit}}(c_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} {\\pi^o_i}^{(t)} & \\text{} c_i^\\text{obs} = 0, \\\\ 1 - {\\pi^o_i}^{(t)} & \\text{} c_i^\\text{obs} = 1,\\\\ 0 & \\text{otherwise.} \\end{cases} \\end{equation} \\begin{equation} \\label{componentwise_logistic_survival} S_i^{\\text{post}, \\text{logit}}(c_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} 1 & \\text{} c_i^\\text{obs} < 0, \\\\ 1-{\\pi^o_i}^{(t)} & \\text{} 0 \\le c_i^\\text{obs} < 1, \\\\ 0, & \\text{} c_i^\\text{obs} \\ge 1. \\end{cases} \\end{equation} \\begin{equation} \\label{componentwise_count_pmf} p_i^{\\text{post},\\text{count}}({y_i^+}^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases}     \\frac{p_i^\\text{UT}({y_i^+}^\\text{obs} \\mid \\theta^{(t)})}{1 - p_i^\\text{UT}(0 \\mid \\theta^{(t)})}, & \\text{ } {y_i^{+}}^\\text{obs} = 1,2,\\ldots,\\\\     0 & \\text{ otherwise.} \\end{cases} \\end{equation} \\begin{equation} \\label{componentwise_count_survival} S_i^{\\text{post}, \\text{count}}({y_i^+}^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases}     1 & \\text{ } {y_i^+}^\\text{obs} < 1 \\\\     \\frac{S_i^\\text{UT}({y_i^+}^\\text{obs} \\mid \\theta^{(t)})}{1-p_i^\\text{UT}(0 \\mid \\theta^{(t)})}, & \\text{ } {y_i^+}^\\text{obs} \\ge 1 \\end{cases} \\end{equation} p_i^\\text{UT}(. \\mid \\theta^{(t)}) S_i^\\text{UT}(. \\mid \\theta^{(t)}) denote PMF survival function untruncated count distribution, given component-specific posterior parameters \\theta^{(t)}. observed value y_i^\\text{obs}, define: \\begin{equation} \\label{eq:post_rpp}\\text{rpp}_i(y_i^\\text{obs} | \\theta^{(t)}) = S_i(y_i^\\text{obs} | \\theta^{(t)}) + U_i \\times p_i(y_i^\\text{obs} | \\theta^{(t)}) \\end{equation} U_i \\sim \\text{Uniform}(0,1). , y_i^\\text{obs} observed value, can refer either binary response C_i positive count {y_i^+}^\\text{obs}, depending component evaluated. , Z-residual discrete response variable , \\begin{equation} \\label{eq:z_residual} z_i = -\\Phi^{-1}(\\text{rpp}_i(y_i^\\text{obs}|\\theta)) \\sim N(0, 1) \\end{equation} (^{-1}(.)) quantile function standard normal distribution.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"hurdle-model","dir":"Articles","previous_headings":"","what":"Hurdle Model:","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"\\begin{equation} p_i^{\\text{post}, \\pi^o_irdle}(y_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} {\\pi^o_i}^{(t)} & \\text{} y_i^\\text{obs} = 0, \\\\ (1 - {\\pi^o_i}^{(t)}) \\cdot\\frac{p_i^\\text{UT}(y_i^\\text{obs} | \\theta^{(t)})}{1 - p_i^\\text{UT}(0 | \\theta^{(t)})} & \\text{} y_i^\\text{obs} =1, 2, \\ldots,\\\\ 0 & \\text{otherwise.} \\end{cases} \\end{equation} \\begin{equation} S_i^{\\text{post}, \\pi^o_irdle}(y_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} 1 & \\text{} y_i^\\text{obs} < 0, \\\\ 1-{\\pi^o_i}^{(t)} & \\text{} 0 \\le y_i^\\text{obs} < 1, \\\\ (1 - {\\pi^o_i}^{(t)}) \\cdot \\frac{S_i^\\text{UT}(y_i^\\text{obs} \\mid \\theta^{(t)})}{1-p_i^\\text{UT}(0 \\mid \\theta^{(t)})} & \\text{} y_i^\\text{obs} \\ge 1. \\end{cases} \\end{equation}","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"logistic-component","dir":"Articles","previous_headings":"","what":"Logistic Component:","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"\\begin{equation} \\label{componentwise_logistic_pmf} p_i^{\\text{post}, \\text{logit}}(c_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} {\\pi^o_i}^{(t)} & \\text{} c_i^\\text{obs} = 0, \\\\ 1 - {\\pi^o_i}^{(t)} & \\text{} c_i^\\text{obs} = 1,\\\\ 0 & \\text{otherwise.} \\end{cases} \\end{equation} \\begin{equation} \\label{componentwise_logistic_survival} S_i^{\\text{post}, \\text{logit}}(c_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} 1 & \\text{} c_i^\\text{obs} < 0, \\\\ 1-{\\pi^o_i}^{(t)} & \\text{} 0 \\le c_i^\\text{obs} < 1, \\\\ 0, & \\text{} c_i^\\text{obs} \\ge 1. \\end{cases} \\end{equation}","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"count-compoenent","dir":"Articles","previous_headings":"","what":"Count Compoenent:","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"\\begin{equation} \\label{componentwise_count_pmf} p_i^{\\text{post},\\text{count}}({y_i^+}^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases}     \\frac{p_i^\\text{UT}({y_i^+}^\\text{obs} \\mid \\theta^{(t)})}{1 - p_i^\\text{UT}(0 \\mid \\theta^{(t)})}, & \\text{ } {y_i^{+}}^\\text{obs} = 1,2,\\ldots,\\\\     0 & \\text{ otherwise.} \\end{cases} \\end{equation} \\begin{equation} \\label{componentwise_count_survival} S_i^{\\text{post}, \\text{count}}({y_i^+}^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases}     1 & \\text{ } {y_i^+}^\\text{obs} < 1 \\\\     \\frac{S_i^\\text{UT}({y_i^+}^\\text{obs} \\mid \\theta^{(t)})}{1-p_i^\\text{UT}(0 \\mid \\theta^{(t)})}, & \\text{ } {y_i^+}^\\text{obs} \\ge 1 \\end{cases} \\end{equation} p_i^\\text{UT}(. \\mid \\theta^{(t)}) S_i^\\text{UT}(. \\mid \\theta^{(t)}) denote PMF survival function untruncated count distribution, given component-specific posterior parameters \\theta^{(t)}. observed value y_i^\\text{obs}, define: \\begin{equation} \\label{eq:post_rpp}\\text{rpp}_i(y_i^\\text{obs} | \\theta^{(t)}) = S_i(y_i^\\text{obs} | \\theta^{(t)}) + U_i \\times p_i(y_i^\\text{obs} | \\theta^{(t)}) \\end{equation} U_i \\sim \\text{Uniform}(0,1). , y_i^\\text{obs} observed value, can refer either binary response C_i positive count {y_i^+}^\\text{obs}, depending component evaluated. , Z-residual discrete response variable , \\begin{equation} \\label{eq:z_residual} z_i = -\\Phi^{-1}(\\text{rpp}_i(y_i^\\text{obs}|\\theta)) \\sim N(0, 1) \\end{equation} (^{-1}(.)) quantile function standard normal distribution.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"a-simulation-example","dir":"Articles","previous_headings":"","what":"A Simulation Example","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"demonstrate Zresidual works hurdle models, first simulate data HNB model. simulated dataset allows us evaluate well model residual diagnostics perform true data-generating process known. dataset includes single continuous predictor x, rando error variable z outcome y generated hurdle negative binomial process. Note error variable included generating y outcome variable. hurdle (zero) part modeled logistic function count part uses zero-truncated negative binomial distribution. Now, use brms package fit hurdle negative binomial model simulated data. hu formula models hurdle (zero) part, main formula models count component. family = hurdle_negbinomial() tells brms use hurdle model negative binomial distribution non-zero counts. use default parameter setting example fit model. example, compute Z-residuals HNB model separately , logistic component (zero part) count component using Zresidual(). Apart component-wise Z-residuals, Zresidual package support overall model Z-residual calculation. package take brms fit input type argument (\"zero\", \"count\" \"hurdle\") specifies component use calculating residuals. default, Z-residuals computed using Importance Sampling Cross-Validation (iscv) method based randomized predictive p-values (RPP). Alternatively, users can choose standard Posterior RPP method setting method = \"post\". function Zresidual.hurdle.negbinomial() (Z-residual computing functions) returns matrix Z-residuals, additional attributes. returned object class zresid, includes metadata useful diagnostic plotting purposes. Return Value numeric matrix dimension n × nrep, n number observations data nrep number randomized replicates Z-residuals (default 1). column represents set Z-residuals computed RPP, using either posterior (post) importance sampling cross-validation (iscv) log predictive distributions. Matrix Attributes type: component hurdle model residuals correspond . One “zero”, “count”, “hurdle”. zero_id: Indices observations response value 0. Useful separating diagnostics zero non-zero parts. log_pmf: matrix log predictive probabilities (log-PMF) per observation posterior draw. log_cdf: matrix log predictive CDF values used computing RPPs. covariates: data frame containing covariates used model (excluding response variable). can used plotting conditional diagnostics. fitted.value: posterior mean predicted value observation depending type. Whether residuals approximately standard normal (via QQ plots), Whether patterns residuals across fitted values (may suggest model misspecification), Whether residuals differ across covariates (optional extensions).  Figure 1: QQ plots  Figure 2: Scatter plots  Figure 3: boxplots diagnostic evaluations true model—comprising scatter plots, Q-Q plots, boxplots Z-residuals—demonstrate model adequately captures data structure. Across logistic, count, hurdle components, Z-residuals evenly scattered around zero mostly fall within range -3 3, indicating visible model misfit. Complementary statistical tests, including SW test normality, ANOVA mean equality, BL test variance homogeneity, return p-values 0.05 threshold. suggests residuals follow normal distribution exhibit equal means variances across fitted value intervals. Q-Q plots support normality close alignment 45-degree reference line, boxplots confirm consistent residual means across partitions. Collectively, diagnostics validate true model satisfies key distributional assumptions proposed Z-residual methods effective detecting model adequacy. plotting functions Zresidual package designed flexible lightweight, allowing users quickly visualize residual patterns across different components hurdle models. functions support customizable arguments base R functions axes, labels etc. making adaptable wide range diagnostic workflows. plot.zresid() function offers flexible diagnostic plotting Z-residuals, supporting various x-axes index, fitted values, covariates. plot.zresid() qqnorm.zresid() automatically highlights outlier residuals fall outside typical (user specified)range making easier identify problematic observations. addition visual diagnostics, package offers formal statistical tests quantify deviations normality homogeneity variance Z-residuals taking zresid class object input. tests return standard htest aov objects, making easy report, summarize, integrate automated workflows. One advantage visualization functions provided Zresidual package allow users diagnose model visually using statistical tests simultaneously. might also interested comparing HNB model HP model taking HP model misspecified model . prior(\"normal(1000, 1)\", class = \"shape\") strong prior, tightly centered around 1000. practical effect force shape parameter large, turn makes model behave almost like Poisson distribution positive counts (truncated part hurdle model).  Figure 4: qqplots  Figure 5: plots  Figure 6: qqplots logistic component shows randomly scattered residuals normal Q-Q alignment, supported non-significant p-values, count hurdle components display clear signs misspecification. include banded residual patterns, heavy tails, Q-Q deviations, significant p-values SW, ANOVA, BL tests. overall hurdle model diagnostics reflect similar issues isolate source misfit. highlights key advantage component-wise residual analysis: reveals logistic sub-model correctly specified, count component . separation enables precise identification correction modeling issues. ##Real Data Example Illustration Demonstration","code":"# Simulation parameters n <- 100 beta0 <- -1   # Intercept for hurdle (zero) part beta1 <- -1  # Coefficient for hurdle part alpha0 <- 2  # Intercept for count part alpha1 <- 6  # Coefficient for count part size <- 6      # Dispersion parameter for negative binomial  x <- rnorm(n) # Predictor  # Hurdle (zero) part logit_p <- beta0 + beta1 * x p_zero <- exp(logit_p) / (1 + exp(logit_p)) zeros <- rbinom(n, 1, p_zero)  # Count (non-zero) part log_mu <- alpha0 + alpha1 * x mu <- exp(log_mu)  # Generate from zero-truncated negative binomial prob <- size / (size + mu) y <- (1-zeros)*distributions3::rztnbinom(n, size, prob)  # A random error variable z <- rnorm(n, mean = 0, sd = 1)  # Final dataset sim_data <- data.frame(y = y, x = x, z = z) library(brms) library(distributions3) load(here::here(\"inst/extdata/fit_hnb.Rdata\"))  #fit_hnb <- brm(bf(y ~ x + z, hu ~ x + z), #               data = sim_data,  #               family = hurdle_negbinomial()) library(matrixStats) library(distributions3) library(Zresidual) zres_hnb_post_zero <- Zresidual(fit_hnb, type = \"zero\", method = \"rpost\",nrep=10) zres_hnb_post_count <- Zresidual(fit_hnb, type = \"count\", method = \"rpost\",nrep=10) zres_hnb_post_hurdle <- Zresidual(fit_hnb, type = \"hurdle\", method = \"rpost\",nrep=10) for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_hnb_post_zero,irep=i) qqnorm.zresid(zres_hnb_post_count,irep=i) qqnorm.zresid(zres_hnb_post_hurdle,irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) plot.zresid(zres_hnb_post_zero, x_axis_var=\"lp\", outlier.return = TRUE,irep=i) plot.zresid(zres_hnb_post_count, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) plot.zresid(zres_hnb_post_hurdle, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) boxplot(zres_hnb_post_zero, x_axis_var=\"lp\",irep=i) boxplot(zres_hnb_post_count, x_axis_var=\"lp\",irep=i) boxplot(zres_hnb_post_hurdle, x_axis_var=\"lp\",irep=i) } library(gt) library(tibble) library(dplyr)  zero_sw <- as.numeric(sw.test.zresid(zres_hnb_post_zero)) count_sw <- as.numeric(sw.test.zresid(zres_hnb_post_count)) hurdle_sw <- as.numeric(sw.test.zresid(zres_hnb_post_hurdle))  zero_aov <- as.numeric(aov.test.zresid(zres_hnb_post_zero)) count_aov <- as.numeric(aov.test.zresid(zres_hnb_post_count)) hurdle_aov <- as.numeric(aov.test.zresid(zres_hnb_post_hurdle))  zero_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_zero)) count_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_count)) hurdle_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_hurdle))  gof_wide <- data.frame(   Residual = paste0(\"CV.Z-residual \", 1:10),   SW_Zero = zero_sw, SW_Count = count_sw, SW_Hurdle = hurdle_sw,   AOV_Zero = zero_aov, AOV_Count = count_aov, AOV_Hurdle = hurdle_aov,   BL_Zero = zero_bl, BL_Count = count_bl, BL_Hurdle = hurdle_bl )  gof_table <- gof_wide %>%   gt() %>%   tab_spanner(label = \"Shapiro-Wilk\", columns = starts_with(\"SW_\")) %>%   tab_spanner(label = \"ANOVA\", columns = starts_with(\"AOV_\")) %>%   tab_spanner(label = \"Bartlett\", columns = starts_with(\"BL_\")) %>%   cols_label(     SW_Zero = \"Zero\", SW_Count = \"Count\", SW_Hurdle = \"Hurdle\",     AOV_Zero = \"Zero\", AOV_Count = \"Count\", AOV_Hurdle = \"Hurdle\",     BL_Zero = \"Zero\", BL_Count = \"Count\", BL_Hurdle = \"Hurdle\"   ) %>%   fmt_number(columns = -Residual, decimals = 4) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\",     table.width = pct(100),     table.font.size = px(12)   ) %>%   tab_style(     style = cell_fill(color = \"#f9f9f9\"),     locations = cells_body(columns = starts_with(\"AOV_\"))   )  gof_table load(here::here(\"inst/extdata/fit_hp.Rdata\")) #fit_hp <- brm(bf(y ~ x + z, hu ~ x + z), #               data = sim_data,  #               family = hurdle_negbinomial(), #               prior = prior(\"normal(1000, 1)\", class = \"shape\")) zres_hp_post_zero <- Zresidual(fit_hp, type = \"zero\", method = \"rpost\",nrep=10) zres_hp_post_count <- Zresidual(fit_hp, type = \"count\", method = \"rpost\",nrep=10) zres_hp_post_hurdle <- Zresidual(fit_hp, type = \"hurdle\", method = \"rpost\",nrep=10) for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_hp_post_zero,irep=i) qqnorm.zresid(zres_hp_post_count,irep=i) qqnorm.zresid(zres_hp_post_hurdle,irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) plot.zresid(zres_hp_post_zero, x_axis_var=\"lp\", outlier.return = TRUE,irep=i) plot.zresid(zres_hp_post_count, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) plot.zresid(zres_hp_post_hurdle, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) boxplot(zres_hp_post_zero, x_axis_var=\"lp\",irep=i) boxplot(zres_hp_post_count, x_axis_var=\"lp\",irep=i) boxplot(zres_hp_post_hurdle, x_axis_var=\"lp\",irep=i) }"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"model-fitting-with-brms","dir":"Articles","previous_headings":"","what":"Model fitting with brms","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"demonstrate Zresidual works hurdle models, first simulate data HNB model. simulated dataset allows us evaluate well model residual diagnostics perform true data-generating process known. dataset includes single continuous predictor x, rando error variable z outcome y generated hurdle negative binomial process. Note error variable included generating y outcome variable. hurdle (zero) part modeled logistic function count part uses zero-truncated negative binomial distribution. Now, use brms package fit hurdle negative binomial model simulated data. hu formula models hurdle (zero) part, main formula models count component. family = hurdle_negbinomial() tells brms use hurdle model negative binomial distribution non-zero counts. use default parameter setting example fit model.","code":"# Simulation parameters n <- 100 beta0 <- -1   # Intercept for hurdle (zero) part beta1 <- -1  # Coefficient for hurdle part alpha0 <- 2  # Intercept for count part alpha1 <- 6  # Coefficient for count part size <- 6      # Dispersion parameter for negative binomial  x <- rnorm(n) # Predictor  # Hurdle (zero) part logit_p <- beta0 + beta1 * x p_zero <- exp(logit_p) / (1 + exp(logit_p)) zeros <- rbinom(n, 1, p_zero)  # Count (non-zero) part log_mu <- alpha0 + alpha1 * x mu <- exp(log_mu)  # Generate from zero-truncated negative binomial prob <- size / (size + mu) y <- (1-zeros)*distributions3::rztnbinom(n, size, prob)  # A random error variable z <- rnorm(n, mean = 0, sd = 1)  # Final dataset sim_data <- data.frame(y = y, x = x, z = z) library(brms) library(distributions3) load(here::here(\"inst/extdata/fit_hnb.Rdata\"))  #fit_hnb <- brm(bf(y ~ x + z, hu ~ x + z), #               data = sim_data,  #               family = hurdle_negbinomial())"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"computing-z-residuals","dir":"Articles","previous_headings":"","what":"Computing Z-residuals","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"example, compute Z-residuals HNB model separately , logistic component (zero part) count component using Zresidual(). Apart component-wise Z-residuals, Zresidual package support overall model Z-residual calculation. package take brms fit input type argument (\"zero\", \"count\" \"hurdle\") specifies component use calculating residuals. default, Z-residuals computed using Importance Sampling Cross-Validation (iscv) method based randomized predictive p-values (RPP). Alternatively, users can choose standard Posterior RPP method setting method = \"post\". function Zresidual.hurdle.negbinomial() (Z-residual computing functions) returns matrix Z-residuals, additional attributes. returned object class zresid, includes metadata useful diagnostic plotting purposes. Return Value numeric matrix dimension n × nrep, n number observations data nrep number randomized replicates Z-residuals (default 1). column represents set Z-residuals computed RPP, using either posterior (post) importance sampling cross-validation (iscv) log predictive distributions. Matrix Attributes type: component hurdle model residuals correspond . One “zero”, “count”, “hurdle”. zero_id: Indices observations response value 0. Useful separating diagnostics zero non-zero parts. log_pmf: matrix log predictive probabilities (log-PMF) per observation posterior draw. log_cdf: matrix log predictive CDF values used computing RPPs. covariates: data frame containing covariates used model (excluding response variable). can used plotting conditional diagnostics. fitted.value: posterior mean predicted value observation depending type.","code":"library(matrixStats) library(distributions3) library(Zresidual) zres_hnb_post_zero <- Zresidual(fit_hnb, type = \"zero\", method = \"rpost\",nrep=10) zres_hnb_post_count <- Zresidual(fit_hnb, type = \"count\", method = \"rpost\",nrep=10) zres_hnb_post_hurdle <- Zresidual(fit_hnb, type = \"hurdle\", method = \"rpost\",nrep=10)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"what-the-function-returns","dir":"Articles","previous_headings":"","what":"What the function returns","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"function Zresidual.hurdle.negbinomial() (Z-residual computing functions) returns matrix Z-residuals, additional attributes. returned object class zresid, includes metadata useful diagnostic plotting purposes. Return Value numeric matrix dimension n × nrep, n number observations data nrep number randomized replicates Z-residuals (default 1). column represents set Z-residuals computed RPP, using either posterior (post) importance sampling cross-validation (iscv) log predictive distributions. Matrix Attributes type: component hurdle model residuals correspond . One “zero”, “count”, “hurdle”. zero_id: Indices observations response value 0. Useful separating diagnostics zero non-zero parts. log_pmf: matrix log predictive probabilities (log-PMF) per observation posterior draw. log_cdf: matrix log predictive CDF values used computing RPPs. covariates: data frame containing covariates used model (excluding response variable). can used plotting conditional diagnostics. fitted.value: posterior mean predicted value observation depending type.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"diagnostic-tools-for-z-residuals","dir":"Articles","previous_headings":"","what":"Diagnostic Tools for Z-Residuals","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"Whether residuals approximately standard normal (via QQ plots), Whether patterns residuals across fitted values (may suggest model misspecification), Whether residuals differ across covariates (optional extensions).  Figure 1: QQ plots  Figure 2: Scatter plots  Figure 3: boxplots diagnostic evaluations true model—comprising scatter plots, Q-Q plots, boxplots Z-residuals—demonstrate model adequately captures data structure. Across logistic, count, hurdle components, Z-residuals evenly scattered around zero mostly fall within range -3 3, indicating visible model misfit. Complementary statistical tests, including SW test normality, ANOVA mean equality, BL test variance homogeneity, return p-values 0.05 threshold. suggests residuals follow normal distribution exhibit equal means variances across fitted value intervals. Q-Q plots support normality close alignment 45-degree reference line, boxplots confirm consistent residual means across partitions. Collectively, diagnostics validate true model satisfies key distributional assumptions proposed Z-residual methods effective detecting model adequacy. plotting functions Zresidual package designed flexible lightweight, allowing users quickly visualize residual patterns across different components hurdle models. functions support customizable arguments base R functions axes, labels etc. making adaptable wide range diagnostic workflows. plot.zresid() function offers flexible diagnostic plotting Z-residuals, supporting various x-axes index, fitted values, covariates. plot.zresid() qqnorm.zresid() automatically highlights outlier residuals fall outside typical (user specified)range making easier identify problematic observations. addition visual diagnostics, package offers formal statistical tests quantify deviations normality homogeneity variance Z-residuals taking zresid class object input. tests return standard htest aov objects, making easy report, summarize, integrate automated workflows. One advantage visualization functions provided Zresidual package allow users diagnose model visually using statistical tests simultaneously. might also interested comparing HNB model HP model taking HP model misspecified model . prior(\"normal(1000, 1)\", class = \"shape\") strong prior, tightly centered around 1000. practical effect force shape parameter large, turn makes model behave almost like Poisson distribution positive counts (truncated part hurdle model).  Figure 4: qqplots  Figure 5: plots  Figure 6: qqplots logistic component shows randomly scattered residuals normal Q-Q alignment, supported non-significant p-values, count hurdle components display clear signs misspecification. include banded residual patterns, heavy tails, Q-Q deviations, significant p-values SW, ANOVA, BL tests. overall hurdle model diagnostics reflect similar issues isolate source misfit. highlights key advantage component-wise residual analysis: reveals logistic sub-model correctly specified, count component . separation enables precise identification correction modeling issues. ##Real Data Example Illustration Demonstration","code":"for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_hnb_post_zero,irep=i) qqnorm.zresid(zres_hnb_post_count,irep=i) qqnorm.zresid(zres_hnb_post_hurdle,irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) plot.zresid(zres_hnb_post_zero, x_axis_var=\"lp\", outlier.return = TRUE,irep=i) plot.zresid(zres_hnb_post_count, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) plot.zresid(zres_hnb_post_hurdle, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) boxplot(zres_hnb_post_zero, x_axis_var=\"lp\",irep=i) boxplot(zres_hnb_post_count, x_axis_var=\"lp\",irep=i) boxplot(zres_hnb_post_hurdle, x_axis_var=\"lp\",irep=i) } library(gt) library(tibble) library(dplyr)  zero_sw <- as.numeric(sw.test.zresid(zres_hnb_post_zero)) count_sw <- as.numeric(sw.test.zresid(zres_hnb_post_count)) hurdle_sw <- as.numeric(sw.test.zresid(zres_hnb_post_hurdle))  zero_aov <- as.numeric(aov.test.zresid(zres_hnb_post_zero)) count_aov <- as.numeric(aov.test.zresid(zres_hnb_post_count)) hurdle_aov <- as.numeric(aov.test.zresid(zres_hnb_post_hurdle))  zero_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_zero)) count_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_count)) hurdle_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_hurdle))  gof_wide <- data.frame(   Residual = paste0(\"CV.Z-residual \", 1:10),   SW_Zero = zero_sw, SW_Count = count_sw, SW_Hurdle = hurdle_sw,   AOV_Zero = zero_aov, AOV_Count = count_aov, AOV_Hurdle = hurdle_aov,   BL_Zero = zero_bl, BL_Count = count_bl, BL_Hurdle = hurdle_bl )  gof_table <- gof_wide %>%   gt() %>%   tab_spanner(label = \"Shapiro-Wilk\", columns = starts_with(\"SW_\")) %>%   tab_spanner(label = \"ANOVA\", columns = starts_with(\"AOV_\")) %>%   tab_spanner(label = \"Bartlett\", columns = starts_with(\"BL_\")) %>%   cols_label(     SW_Zero = \"Zero\", SW_Count = \"Count\", SW_Hurdle = \"Hurdle\",     AOV_Zero = \"Zero\", AOV_Count = \"Count\", AOV_Hurdle = \"Hurdle\",     BL_Zero = \"Zero\", BL_Count = \"Count\", BL_Hurdle = \"Hurdle\"   ) %>%   fmt_number(columns = -Residual, decimals = 4) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\",     table.width = pct(100),     table.font.size = px(12)   ) %>%   tab_style(     style = cell_fill(color = \"#f9f9f9\"),     locations = cells_body(columns = starts_with(\"AOV_\"))   )  gof_table load(here::here(\"inst/extdata/fit_hp.Rdata\")) #fit_hp <- brm(bf(y ~ x + z, hu ~ x + z), #               data = sim_data,  #               family = hurdle_negbinomial(), #               prior = prior(\"normal(1000, 1)\", class = \"shape\")) zres_hp_post_zero <- Zresidual(fit_hp, type = \"zero\", method = \"rpost\",nrep=10) zres_hp_post_count <- Zresidual(fit_hp, type = \"count\", method = \"rpost\",nrep=10) zres_hp_post_hurdle <- Zresidual(fit_hp, type = \"hurdle\", method = \"rpost\",nrep=10) for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_hp_post_zero,irep=i) qqnorm.zresid(zres_hp_post_count,irep=i) qqnorm.zresid(zres_hp_post_hurdle,irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) plot.zresid(zres_hp_post_zero, x_axis_var=\"lp\", outlier.return = TRUE,irep=i) plot.zresid(zres_hp_post_count, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) plot.zresid(zres_hp_post_hurdle, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) boxplot(zres_hp_post_zero, x_axis_var=\"lp\",irep=i) boxplot(zres_hp_post_count, x_axis_var=\"lp\",irep=i) boxplot(zres_hp_post_hurdle, x_axis_var=\"lp\",irep=i) }"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"visualizing-z-residuals","dir":"Articles","previous_headings":"","what":"Visualizing Z-residuals","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"Whether residuals approximately standard normal (via QQ plots), Whether patterns residuals across fitted values (may suggest model misspecification), Whether residuals differ across covariates (optional extensions).  Figure 1: QQ plots  Figure 2: Scatter plots  Figure 3: boxplots diagnostic evaluations true model—comprising scatter plots, Q-Q plots, boxplots Z-residuals—demonstrate model adequately captures data structure. Across logistic, count, hurdle components, Z-residuals evenly scattered around zero mostly fall within range -3 3, indicating visible model misfit. Complementary statistical tests, including SW test normality, ANOVA mean equality, BL test variance homogeneity, return p-values 0.05 threshold. suggests residuals follow normal distribution exhibit equal means variances across fitted value intervals. Q-Q plots support normality close alignment 45-degree reference line, boxplots confirm consistent residual means across partitions. Collectively, diagnostics validate true model satisfies key distributional assumptions proposed Z-residual methods effective detecting model adequacy. plotting functions Zresidual package designed flexible lightweight, allowing users quickly visualize residual patterns across different components hurdle models. functions support customizable arguments base R functions axes, labels etc. making adaptable wide range diagnostic workflows. plot.zresid() function offers flexible diagnostic plotting Z-residuals, supporting various x-axes index, fitted values, covariates. plot.zresid() qqnorm.zresid() automatically highlights outlier residuals fall outside typical (user specified)range making easier identify problematic observations.","code":"for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_hnb_post_zero,irep=i) qqnorm.zresid(zres_hnb_post_count,irep=i) qqnorm.zresid(zres_hnb_post_hurdle,irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) plot.zresid(zres_hnb_post_zero, x_axis_var=\"lp\", outlier.return = TRUE,irep=i) plot.zresid(zres_hnb_post_count, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) plot.zresid(zres_hnb_post_hurdle, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) boxplot(zres_hnb_post_zero, x_axis_var=\"lp\",irep=i) boxplot(zres_hnb_post_count, x_axis_var=\"lp\",irep=i) boxplot(zres_hnb_post_hurdle, x_axis_var=\"lp\",irep=i) }"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"statistical-tests","dir":"Articles","previous_headings":"","what":"Statistical Tests","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"addition visual diagnostics, package offers formal statistical tests quantify deviations normality homogeneity variance Z-residuals taking zresid class object input. tests return standard htest aov objects, making easy report, summarize, integrate automated workflows. One advantage visualization functions provided Zresidual package allow users diagnose model visually using statistical tests simultaneously. might also interested comparing HNB model HP model taking HP model misspecified model . prior(\"normal(1000, 1)\", class = \"shape\") strong prior, tightly centered around 1000. practical effect force shape parameter large, turn makes model behave almost like Poisson distribution positive counts (truncated part hurdle model).  Figure 4: qqplots  Figure 5: plots  Figure 6: qqplots logistic component shows randomly scattered residuals normal Q-Q alignment, supported non-significant p-values, count hurdle components display clear signs misspecification. include banded residual patterns, heavy tails, Q-Q deviations, significant p-values SW, ANOVA, BL tests. overall hurdle model diagnostics reflect similar issues isolate source misfit. highlights key advantage component-wise residual analysis: reveals logistic sub-model correctly specified, count component . separation enables precise identification correction modeling issues. ##Real Data Example Illustration Demonstration","code":"library(gt) library(tibble) library(dplyr)  zero_sw <- as.numeric(sw.test.zresid(zres_hnb_post_zero)) count_sw <- as.numeric(sw.test.zresid(zres_hnb_post_count)) hurdle_sw <- as.numeric(sw.test.zresid(zres_hnb_post_hurdle))  zero_aov <- as.numeric(aov.test.zresid(zres_hnb_post_zero)) count_aov <- as.numeric(aov.test.zresid(zres_hnb_post_count)) hurdle_aov <- as.numeric(aov.test.zresid(zres_hnb_post_hurdle))  zero_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_zero)) count_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_count)) hurdle_bl <- as.numeric(bartlett.test.zresid(zres_hnb_post_hurdle))  gof_wide <- data.frame(   Residual = paste0(\"CV.Z-residual \", 1:10),   SW_Zero = zero_sw, SW_Count = count_sw, SW_Hurdle = hurdle_sw,   AOV_Zero = zero_aov, AOV_Count = count_aov, AOV_Hurdle = hurdle_aov,   BL_Zero = zero_bl, BL_Count = count_bl, BL_Hurdle = hurdle_bl )  gof_table <- gof_wide %>%   gt() %>%   tab_spanner(label = \"Shapiro-Wilk\", columns = starts_with(\"SW_\")) %>%   tab_spanner(label = \"ANOVA\", columns = starts_with(\"AOV_\")) %>%   tab_spanner(label = \"Bartlett\", columns = starts_with(\"BL_\")) %>%   cols_label(     SW_Zero = \"Zero\", SW_Count = \"Count\", SW_Hurdle = \"Hurdle\",     AOV_Zero = \"Zero\", AOV_Count = \"Count\", AOV_Hurdle = \"Hurdle\",     BL_Zero = \"Zero\", BL_Count = \"Count\", BL_Hurdle = \"Hurdle\"   ) %>%   fmt_number(columns = -Residual, decimals = 4) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\",     table.width = pct(100),     table.font.size = px(12)   ) %>%   tab_style(     style = cell_fill(color = \"#f9f9f9\"),     locations = cells_body(columns = starts_with(\"AOV_\"))   )  gof_table load(here::here(\"inst/extdata/fit_hp.Rdata\")) #fit_hp <- brm(bf(y ~ x + z, hu ~ x + z), #               data = sim_data,  #               family = hurdle_negbinomial(), #               prior = prior(\"normal(1000, 1)\", class = \"shape\")) zres_hp_post_zero <- Zresidual(fit_hp, type = \"zero\", method = \"rpost\",nrep=10) zres_hp_post_count <- Zresidual(fit_hp, type = \"count\", method = \"rpost\",nrep=10) zres_hp_post_hurdle <- Zresidual(fit_hp, type = \"hurdle\", method = \"rpost\",nrep=10) for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_hp_post_zero,irep=i) qqnorm.zresid(zres_hp_post_count,irep=i) qqnorm.zresid(zres_hp_post_hurdle,irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) plot.zresid(zres_hp_post_zero, x_axis_var=\"lp\", outlier.return = TRUE,irep=i) plot.zresid(zres_hp_post_count, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) plot.zresid(zres_hp_post_hurdle, x_axis_var=\"lp\", outlier.return = TRUE, log = \"x\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) boxplot(zres_hp_post_zero, x_axis_var=\"lp\",irep=i) boxplot(zres_hp_post_count, x_axis_var=\"lp\",irep=i) boxplot(zres_hp_post_hurdle, x_axis_var=\"lp\",irep=i) }"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_hurdle_brms.html","id":"other-functions","dir":"Articles","previous_headings":"","what":"Other Functions","title":"Demo of Component-wise Z-residual Diagnosis for Bayesian Hurdle Models","text":"addition Z-residual computation visualization, Zresidual package provides several utility functions support deeper model diagnostics probabilistic analysis including functions calculating logarithmic predictive p-values (post_logrpp(), iscv_logrpp()). package also includes dedicated functions compute logarithmic PDFs CDFs supported distributions. can used manually inspect likelihood components derive custom model evaluation metrics. log-scale calculations offer improved numerical stability, especially dealing small probabilities. tools integrate seamlessly outputs Bayesian models fitted using brms, maintaining compatibility flexibility. Together, extend package’s functionality beyond residual analysis, supporting comprehensive rigorous approach Bayesian model checking.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"installing-zresidual-and-other-packages","dir":"Articles","previous_headings":"","what":"Installing Zresidual and Other packages","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) } library(Zresidual) # Vector of required packages pkgs <- c(   \"brms\",\"EnvStats\",\"foreach\", \"statip\", \"VGAM\", \"plotrix\", \"actuar\",   \"stringr\", \"Rlab\", \"dplyr\", \"rlang\", \"tidyr\",   \"matrixStats\", \"timeDate\", \"katex\", \"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"installing-z-residua-from-the-source","dir":"Articles","previous_headings":"","what":"Installing Z-residua from the source","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"","code":"if (!requireNamespace(\"Zresidual\", quietly = TRUE)) {   if (!requireNamespace(\"remotes\", quietly = TRUE)) {     install.packages(\"remotes\")   }   remotes::install_github(\"tiw150/Zresidual\",                           upgrade = \"never\",                           dependencies = TRUE) } library(Zresidual)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"intalling-and-loading-r-packages-used-in-this-demo","dir":"Articles","previous_headings":"","what":"Intalling and Loading R Packages used in this Demo","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"","code":"# Vector of required packages pkgs <- c(   \"brms\",\"EnvStats\",\"foreach\", \"statip\", \"VGAM\", \"plotrix\", \"actuar\",   \"stringr\", \"Rlab\", \"dplyr\", \"rlang\", \"tidyr\",   \"matrixStats\", \"timeDate\", \"katex\", \"gt\",\"loo\" )  missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)] if (length(missing_pkgs)) {   message(\"Installing missing packages: \", paste(missing_pkgs, collapse = \", \"))   install.packages(missing_pkgs, dependencies = TRUE) }  invisible(lapply(pkgs, function(p) {   suppressPackageStartupMessages(library(p, character.only = TRUE)) }))  nc <- parallel::detectCores(logical = FALSE) if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"vignette demonstrates use Zresidual package compute Z-residuals diagnosing Logistic regression, based output brms package R (Bürkner 2017) reveal potential model misspecifications. examples illustrate practical use residuals RPP (Feng, Li, Sadeghpour 2020) diagnostics.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"definitions-of-z-residuals-for-logistic-regression","dir":"Articles","previous_headings":"","what":"Definitions of Z-residuals for Logistic Regression","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"section demonstrates definitions posterior predictive quantities including posterior predictive PMF, survival function, RPP Logistic Regression. Let y_i \\\\{0, 1\\}, y_i = 1 indicates success, y_i = 0 indicates failure ^th observations. Using Bayesian estimation (e.g., via brms package), draw T samples posterior distribution. Let \\theta^{(t)} denote t^{th} posterior draw. given observation y_i^\\text{obs}, posterior predictive PMF survival functions defined . \\begin{equation} p_i^{\\text{post}, \\text{logit}}(y_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} {\\pi^o_i}^{(t)} & \\text{} y_i^\\text{obs} = 1, \\\\ 1 - {\\pi^o_i}^{(t)} & \\text{} y_i^\\text{obs} = 0,\\\\ 0 & \\text{otherwise.} \\end{cases} \\end{equation} \\begin{equation} S_i^{\\text{post}, \\text{logit}}(y_i^\\text{obs}) = \\frac{1}{T} \\sum_{t=1}^T \\begin{cases} 1 & \\text{} y_i^\\text{obs} < 0, \\\\ 1-{\\pi^o_i}^{(t)} & \\text{} 0 \\le y_i^\\text{obs} < 1, \\\\ 0, & \\text{} y_i^\\text{obs} \\ge 1. \\end{cases} \\end{equation} observed value y_i^\\text{obs}, define: \\begin{equation} \\label{eq:post_rpp}\\text{rpp}_i(y_i^\\text{obs} | \\theta^{(t)}) = S_i(y_i^\\text{obs} | \\theta^{(t)}) + U_i \\times p_i(y_i^\\text{obs} | \\theta^{(t)}) \\end{equation} U_i \\sim \\text{Uniform}(0,1). , y_i^\\text{obs} observed value, can refer either success failure. , Z-residual response variable , \\begin{equation} \\label{eq:z_residual} z_i = -\\Phi^{-1}(\\text{rpp}_i(y_i^\\text{obs}|\\theta)) \\sim N(0, 1) \\end{equation} (^{-1}(.)) quantile function standard normal distribution.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"a-simulation-example","dir":"Articles","previous_headings":"","what":"A Simulation Example","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"demonstrate Zresidual works hurdle models, first simulate data HNB model. simulated dataset allows us evaluate well model residual diagnostics perform true data-generating process known. dataset includes continuous predictor x1, binary variable x2, five random error variables z1, z2, z3, z4, z5 outcome y generated Bernoulli process. Note error variables included generating y outcome variable. Now, use brms package fit logistic regression model simulated data. family = bernoulli() tells brms use logistic regression binary response. use default parameter setting example fit model. example, compute Z-residuals logistic regression using Zresidual.bernoulli(). package take brms fit input Zresidual.bernoulli() function. model Hurdle model, type argument (\"zero\", \"count\" \"hurdle\") specifies component use calculating residuals. default, Z-residuals computed using Importance Sampling Cross-Validation (iscv) method based randomized predictive p-values (RPP). Alternatively, users can choose standard Posterior RPP method setting method = \"post\". function Zresidual.bernoulli() (Z-residual computing functions) returns matrix Z-residuals, additional attributes. returned object class zresid, includes metadata useful diagnostic plotting purposes. Return Value numeric matrix dimension n × nrep, n number observations data nrep number randomized replicates Z-residuals (default 1). column represents set Z-residuals computed RPP, using either posterior (post) importance sampling cross-validation (iscv) log predictive distributions. Matrix Attributes type: component hurdle model residuals correspond . One “zero”, “count”, “hurdle”. logistic, type returned “zero”. zero_id: Indices observations response value 0. Useful separating diagnostics zero non-zero parts. log_pmf: matrix log predictive probabilities (log-PMF) per observation posterior draw. log_cdf: matrix log predictive CDF values used computing RPPs. covariates: data frame containing covariates used model (excluding response variable). can used plotting conditional diagnostics. fitted.value: posterior mean predicted value observation depending type. Whether residuals approximately standard normal (via QQ plots), Whether patterns residuals across fitted values (may suggest model misspecification), Whether residuals differ across covariates (optional extensions).  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset.  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset. diagnostic evaluations model—comprising scatter plots, Q-Q plots, boxplots Z-residuals—demonstrate model adequately captures data structure. Z-residuals evenly scattered around zero mostly fall within range -3 3, indicating visible model misfit. “count” represent success “zero” represent failure. Complementary statistical tests, including SW test normality, ANOVA mean equality, BL test variance homogeneity, return p-values 0.05 threshold. suggests residuals follow normal distribution exhibit equal means variances across fitted value intervals. Q-Q plots support normality close alignment 45-degree reference line, boxplots confirm consistent residual means across partitions. Collectively, diagnostics validate model satisfies key distributional assumptions proposed Z-residual methods effective detecting model adequacy. plotting functions Zresidual package designed flexible lightweight, allowing users quickly visualize residual patterns. functions support customizable arguments base R functions axes, labels etc. making adaptable wide range diagnostic workflows. plot.zresid() function offers flexible diagnostic plotting Z-residuals, supporting various x-axes index, fitted values, covariates. plot.zresid() qqnorm.zresid() automatically highlights outlier residuals fall outside typical (user specified) range making easier identify problematic observations. addition visual diagnostics, package offers formal statistical tests quantify deviations normality homogeneity variance Z-residuals taking zresid class object input. tests return standard htest aov objects, making easy report, summarize, integrate automated workflows. One advantage visualization functions provided Zresidual package allow users diagnose model visually using statistical tests simultaneously.","code":"# Simulation parameters n <- 100 beta0 <- -1 beta1 <- 6 beta2 <- 1  # Predictors x1 <- runif(n, 0, 1) x2 <- rbinom(n, size = 1, p = 0.5)  # Generating response variable logit_p <- beta0 + beta1*x1 + beta2*x2 p <- exp(logit_p) / (1 + exp(logit_p)) y <- rbinom(n, 1, p)     # Random error variables j <- 5 # number of random effect sample_experiment <- replicate(j, rnorm(n, mean = 0, sd = 1), simplify = FALSE) z <- data.frame(matrix(unlist(sample_experiment), ncol=j, byrow=FALSE)) z_names <- paste0(\"z\", seq(1,j)) colnames(z) <- z_names    data_logit <- data.frame(x1, x2, z, y)  k <- j+2 predictors <- colnames(data_logit)[2:k] logit_formula <- formula(paste(\"y ~ \", paste(predictors, collapse=\" + \"))) library(matrixStats) library(Zresidual) library(brms) #fit_logit <- brm(bf(logit_formula), #               data = data_logit,  #               family = bernoulli()) load(here::here(\"inst/extdata/fit_logit.Rdata\")) zres_logit_iscv <- Zresidual(fit_logit,nrep=10) zres_logit_post <- Zresidual(fit_logit, method = \"rpost\",nrep=10) for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_logit_iscv,irep=i) plot.zresid(zres_logit_iscv, x_axis_var=\"x2\", outlier.return = TRUE,categor=TRUE,irep=i) boxplot(zres_logit_iscv, x_axis_var=\"lp\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_logit_post,irep=i) plot.zresid(zres_logit_post, x_axis_var=\"x2\", outlier.return = TRUE,categor=TRUE,irep=i) boxplot(zres_logit_post, x_axis_var=\"lp\",irep=i) } library(gt) library(tibble) library(dplyr)  res_sw_iscv <- as.numeric(sw.test.zresid(zres_logit_iscv)) res_sw_post <- as.numeric(sw.test.zresid(zres_logit_post))  res_aov_iscv <- as.numeric(aov.test.zresid(zres_logit_iscv, X=\"lp\")) res_aov_post <- as.numeric(aov.test.zresid(zres_logit_post, X=\"lp\"))  res_bl_iscv <- as.numeric(bartlett.test.zresid(zres_logit_iscv, X=\"lp\")) res_bl_post <- as.numeric(bartlett.test.zresid(zres_logit_post, X=\"lp\"))  gof_wide <- data.frame(   Residual = paste0(\"CV.Z-residual \", 1:10),   SW_ISCV = res_sw_iscv, SW_Post = res_sw_post,   AOV_ISCV = res_aov_iscv, AOV_Post = res_aov_post,   BL_ISCV = res_bl_iscv, BL_Post = res_bl_post )  gof_table <- gof_wide %>%   gt() %>%   tab_spanner(label = \"Shapiro-Wilk\", columns = starts_with(\"SW_\")) %>%   tab_spanner(label = \"ANOVA\", columns = starts_with(\"AOV_\")) %>%   tab_spanner(label = \"Bartlett\", columns = starts_with(\"BL_\")) %>%   cols_label(     SW_ISCV = \"ISCV\", SW_Post = \"Post\",     AOV_ISCV = \"ISCV\", AOV_Post = \"Post\",     BL_ISCV = \"ISCV\", BL_Post = \"Post\"   ) %>%   fmt_number(columns = -Residual, decimals = 4) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\",     table.width = pct(100),     table.font.size = px(12)   ) %>%   tab_style(     style = cell_fill(color = \"#f9f9f9\"),     locations = cells_body(columns = starts_with(\"AOV_\"))   )  gof_table"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"model-fitting-with-brms","dir":"Articles","previous_headings":"","what":"Model fitting with brms","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"demonstrate Zresidual works hurdle models, first simulate data HNB model. simulated dataset allows us evaluate well model residual diagnostics perform true data-generating process known. dataset includes continuous predictor x1, binary variable x2, five random error variables z1, z2, z3, z4, z5 outcome y generated Bernoulli process. Note error variables included generating y outcome variable. Now, use brms package fit logistic regression model simulated data. family = bernoulli() tells brms use logistic regression binary response. use default parameter setting example fit model.","code":"# Simulation parameters n <- 100 beta0 <- -1 beta1 <- 6 beta2 <- 1  # Predictors x1 <- runif(n, 0, 1) x2 <- rbinom(n, size = 1, p = 0.5)  # Generating response variable logit_p <- beta0 + beta1*x1 + beta2*x2 p <- exp(logit_p) / (1 + exp(logit_p)) y <- rbinom(n, 1, p)     # Random error variables j <- 5 # number of random effect sample_experiment <- replicate(j, rnorm(n, mean = 0, sd = 1), simplify = FALSE) z <- data.frame(matrix(unlist(sample_experiment), ncol=j, byrow=FALSE)) z_names <- paste0(\"z\", seq(1,j)) colnames(z) <- z_names    data_logit <- data.frame(x1, x2, z, y)  k <- j+2 predictors <- colnames(data_logit)[2:k] logit_formula <- formula(paste(\"y ~ \", paste(predictors, collapse=\" + \"))) library(matrixStats) library(Zresidual) library(brms) #fit_logit <- brm(bf(logit_formula), #               data = data_logit,  #               family = bernoulli()) load(here::here(\"inst/extdata/fit_logit.Rdata\"))"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"computing-z-residuals","dir":"Articles","previous_headings":"","what":"Computing Z-residuals","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"example, compute Z-residuals logistic regression using Zresidual.bernoulli(). package take brms fit input Zresidual.bernoulli() function. model Hurdle model, type argument (\"zero\", \"count\" \"hurdle\") specifies component use calculating residuals. default, Z-residuals computed using Importance Sampling Cross-Validation (iscv) method based randomized predictive p-values (RPP). Alternatively, users can choose standard Posterior RPP method setting method = \"post\". function Zresidual.bernoulli() (Z-residual computing functions) returns matrix Z-residuals, additional attributes. returned object class zresid, includes metadata useful diagnostic plotting purposes. Return Value numeric matrix dimension n × nrep, n number observations data nrep number randomized replicates Z-residuals (default 1). column represents set Z-residuals computed RPP, using either posterior (post) importance sampling cross-validation (iscv) log predictive distributions. Matrix Attributes type: component hurdle model residuals correspond . One “zero”, “count”, “hurdle”. logistic, type returned “zero”. zero_id: Indices observations response value 0. Useful separating diagnostics zero non-zero parts. log_pmf: matrix log predictive probabilities (log-PMF) per observation posterior draw. log_cdf: matrix log predictive CDF values used computing RPPs. covariates: data frame containing covariates used model (excluding response variable). can used plotting conditional diagnostics. fitted.value: posterior mean predicted value observation depending type.","code":"zres_logit_iscv <- Zresidual(fit_logit,nrep=10) zres_logit_post <- Zresidual(fit_logit, method = \"rpost\",nrep=10)"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"what-the-function-returns","dir":"Articles","previous_headings":"","what":"What the function returns","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"function Zresidual.bernoulli() (Z-residual computing functions) returns matrix Z-residuals, additional attributes. returned object class zresid, includes metadata useful diagnostic plotting purposes. Return Value numeric matrix dimension n × nrep, n number observations data nrep number randomized replicates Z-residuals (default 1). column represents set Z-residuals computed RPP, using either posterior (post) importance sampling cross-validation (iscv) log predictive distributions. Matrix Attributes type: component hurdle model residuals correspond . One “zero”, “count”, “hurdle”. logistic, type returned “zero”. zero_id: Indices observations response value 0. Useful separating diagnostics zero non-zero parts. log_pmf: matrix log predictive probabilities (log-PMF) per observation posterior draw. log_cdf: matrix log predictive CDF values used computing RPPs. covariates: data frame containing covariates used model (excluding response variable). can used plotting conditional diagnostics. fitted.value: posterior mean predicted value observation depending type.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"diagnostic-tools-for-z-residuals","dir":"Articles","previous_headings":"","what":"Diagnostic Tools for Z-Residuals","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"Whether residuals approximately standard normal (via QQ plots), Whether patterns residuals across fitted values (may suggest model misspecification), Whether residuals differ across covariates (optional extensions).  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset.  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset. diagnostic evaluations model—comprising scatter plots, Q-Q plots, boxplots Z-residuals—demonstrate model adequately captures data structure. Z-residuals evenly scattered around zero mostly fall within range -3 3, indicating visible model misfit. “count” represent success “zero” represent failure. Complementary statistical tests, including SW test normality, ANOVA mean equality, BL test variance homogeneity, return p-values 0.05 threshold. suggests residuals follow normal distribution exhibit equal means variances across fitted value intervals. Q-Q plots support normality close alignment 45-degree reference line, boxplots confirm consistent residual means across partitions. Collectively, diagnostics validate model satisfies key distributional assumptions proposed Z-residual methods effective detecting model adequacy. plotting functions Zresidual package designed flexible lightweight, allowing users quickly visualize residual patterns. functions support customizable arguments base R functions axes, labels etc. making adaptable wide range diagnostic workflows. plot.zresid() function offers flexible diagnostic plotting Z-residuals, supporting various x-axes index, fitted values, covariates. plot.zresid() qqnorm.zresid() automatically highlights outlier residuals fall outside typical (user specified) range making easier identify problematic observations. addition visual diagnostics, package offers formal statistical tests quantify deviations normality homogeneity variance Z-residuals taking zresid class object input. tests return standard htest aov objects, making easy report, summarize, integrate automated workflows. One advantage visualization functions provided Zresidual package allow users diagnose model visually using statistical tests simultaneously.","code":"for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_logit_iscv,irep=i) plot.zresid(zres_logit_iscv, x_axis_var=\"x2\", outlier.return = TRUE,categor=TRUE,irep=i) boxplot(zres_logit_iscv, x_axis_var=\"lp\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_logit_post,irep=i) plot.zresid(zres_logit_post, x_axis_var=\"x2\", outlier.return = TRUE,categor=TRUE,irep=i) boxplot(zres_logit_post, x_axis_var=\"lp\",irep=i) } library(gt) library(tibble) library(dplyr)  res_sw_iscv <- as.numeric(sw.test.zresid(zres_logit_iscv)) res_sw_post <- as.numeric(sw.test.zresid(zres_logit_post))  res_aov_iscv <- as.numeric(aov.test.zresid(zres_logit_iscv, X=\"lp\")) res_aov_post <- as.numeric(aov.test.zresid(zres_logit_post, X=\"lp\"))  res_bl_iscv <- as.numeric(bartlett.test.zresid(zres_logit_iscv, X=\"lp\")) res_bl_post <- as.numeric(bartlett.test.zresid(zres_logit_post, X=\"lp\"))  gof_wide <- data.frame(   Residual = paste0(\"CV.Z-residual \", 1:10),   SW_ISCV = res_sw_iscv, SW_Post = res_sw_post,   AOV_ISCV = res_aov_iscv, AOV_Post = res_aov_post,   BL_ISCV = res_bl_iscv, BL_Post = res_bl_post )  gof_table <- gof_wide %>%   gt() %>%   tab_spanner(label = \"Shapiro-Wilk\", columns = starts_with(\"SW_\")) %>%   tab_spanner(label = \"ANOVA\", columns = starts_with(\"AOV_\")) %>%   tab_spanner(label = \"Bartlett\", columns = starts_with(\"BL_\")) %>%   cols_label(     SW_ISCV = \"ISCV\", SW_Post = \"Post\",     AOV_ISCV = \"ISCV\", AOV_Post = \"Post\",     BL_ISCV = \"ISCV\", BL_Post = \"Post\"   ) %>%   fmt_number(columns = -Residual, decimals = 4) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\",     table.width = pct(100),     table.font.size = px(12)   ) %>%   tab_style(     style = cell_fill(color = \"#f9f9f9\"),     locations = cells_body(columns = starts_with(\"AOV_\"))   )  gof_table"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"visualizing-z-residuals","dir":"Articles","previous_headings":"","what":"Visualizing Z-residuals","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"Whether residuals approximately standard normal (via QQ plots), Whether patterns residuals across fitted values (may suggest model misspecification), Whether residuals differ across covariates (optional extensions).  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset.  Figure 1: Scatterplots QQ plots -CV LOOCV Z-residuals fitted shared frailty models based original kidney infection dataset. diagnostic evaluations model—comprising scatter plots, Q-Q plots, boxplots Z-residuals—demonstrate model adequately captures data structure. Z-residuals evenly scattered around zero mostly fall within range -3 3, indicating visible model misfit. “count” represent success “zero” represent failure. Complementary statistical tests, including SW test normality, ANOVA mean equality, BL test variance homogeneity, return p-values 0.05 threshold. suggests residuals follow normal distribution exhibit equal means variances across fitted value intervals. Q-Q plots support normality close alignment 45-degree reference line, boxplots confirm consistent residual means across partitions. Collectively, diagnostics validate model satisfies key distributional assumptions proposed Z-residual methods effective detecting model adequacy. plotting functions Zresidual package designed flexible lightweight, allowing users quickly visualize residual patterns. functions support customizable arguments base R functions axes, labels etc. making adaptable wide range diagnostic workflows. plot.zresid() function offers flexible diagnostic plotting Z-residuals, supporting various x-axes index, fitted values, covariates. plot.zresid() qqnorm.zresid() automatically highlights outlier residuals fall outside typical (user specified) range making easier identify problematic observations.","code":"for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_logit_iscv,irep=i) plot.zresid(zres_logit_iscv, x_axis_var=\"x2\", outlier.return = TRUE,categor=TRUE,irep=i) boxplot(zres_logit_iscv, x_axis_var=\"lp\",irep=i) } for (i in 1:10) { par(mfrow = c(1,3)) qqnorm.zresid(zres_logit_post,irep=i) plot.zresid(zres_logit_post, x_axis_var=\"x2\", outlier.return = TRUE,categor=TRUE,irep=i) boxplot(zres_logit_post, x_axis_var=\"lp\",irep=i) }"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"statistical-tests","dir":"Articles","previous_headings":"","what":"Statistical Tests","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"addition visual diagnostics, package offers formal statistical tests quantify deviations normality homogeneity variance Z-residuals taking zresid class object input. tests return standard htest aov objects, making easy report, summarize, integrate automated workflows. One advantage visualization functions provided Zresidual package allow users diagnose model visually using statistical tests simultaneously.","code":"library(gt) library(tibble) library(dplyr)  res_sw_iscv <- as.numeric(sw.test.zresid(zres_logit_iscv)) res_sw_post <- as.numeric(sw.test.zresid(zres_logit_post))  res_aov_iscv <- as.numeric(aov.test.zresid(zres_logit_iscv, X=\"lp\")) res_aov_post <- as.numeric(aov.test.zresid(zres_logit_post, X=\"lp\"))  res_bl_iscv <- as.numeric(bartlett.test.zresid(zres_logit_iscv, X=\"lp\")) res_bl_post <- as.numeric(bartlett.test.zresid(zres_logit_post, X=\"lp\"))  gof_wide <- data.frame(   Residual = paste0(\"CV.Z-residual \", 1:10),   SW_ISCV = res_sw_iscv, SW_Post = res_sw_post,   AOV_ISCV = res_aov_iscv, AOV_Post = res_aov_post,   BL_ISCV = res_bl_iscv, BL_Post = res_bl_post )  gof_table <- gof_wide %>%   gt() %>%   tab_spanner(label = \"Shapiro-Wilk\", columns = starts_with(\"SW_\")) %>%   tab_spanner(label = \"ANOVA\", columns = starts_with(\"AOV_\")) %>%   tab_spanner(label = \"Bartlett\", columns = starts_with(\"BL_\")) %>%   cols_label(     SW_ISCV = \"ISCV\", SW_Post = \"Post\",     AOV_ISCV = \"ISCV\", AOV_Post = \"Post\",     BL_ISCV = \"ISCV\", BL_Post = \"Post\"   ) %>%   fmt_number(columns = -Residual, decimals = 4) %>%   cols_align(align = \"center\", columns = everything()) %>%   tab_options(     column_labels.font.weight = \"bold\",     table.width = pct(100),     table.font.size = px(12)   ) %>%   tab_style(     style = cell_fill(color = \"#f9f9f9\"),     locations = cells_body(columns = starts_with(\"AOV_\"))   )  gof_table"},{"path":"https://tiw150.github.io/Zresidual/articles/demo_logistic_brms.html","id":"other-functions","dir":"Articles","previous_headings":"","what":"Other Functions","title":"Demo of Z-residual Diagnosis for Bayesian Logistic Regression","text":"addition Z-residual computation visualization, Zresidual package provides several utility functions support deeper model diagnostics probabilistic analysis including functions calculating logarithmic predictive p-values (post_logrpp(), iscv_logrpp()). package also includes dedicated functions compute logarithmic PDFs CDFs supported distributions. can used manually inspect likelihood components derive custom model evaluation metrics. log-scale calculations offer improved numerical stability, especially dealing small probabilities. tools integrate seamlessly outputs Bayesian models fitted using brms, maintaining compatibility flexibility. Together, extend package’s functionality beyond residual analysis, supporting comprehensive rigorous approach Bayesian model checking.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/articles/illus_zresid.html","id":"z-residuals","dir":"Articles","previous_headings":"","what":"Z-residuals","title":"An Animation for Understanding Z-residuals","text":"Zresidual package implements diagnostic residuals based predictive distribution observation. utilizing full probabilistic information model, package generates residuals approximately normally distributed. allows standard diagnostic techniques similar using Pearson residuals OLS regression. given observation y_i, Randomized Survival Probability (RSP)—also known randomized probability integral transform—represents value predictive survival function (upper-tail probability) y_i, adjusted randomization term ensure continuity discrete outcomes. defined : RSP_i(y_i \\mid \\theta) = S_i(y_i \\mid \\theta) + U_i \\, p_i(y_i \\mid \\theta) \\tag{1} S_i p_i represent survival function probability mass function, respectively, derived predictive distribution y_i given covariates \\mathbf{x}_i parameters \\theta. U_i \\sim \\text{Unif}(0,1) random uniform variable used smooth discrete outcomes. correctly specified model—observed data y_i arises assumed predictive distribution—RSP follows \\text{Unif}(0,1) distribution. Z-residual (aka randomized quantile residual) derived transforming RSP via inverse survival function N(0,1): z_i(y_i \\mid \\theta) = -\\Phi^{-1}\\left(RSP_i(y_i \\mid \\theta)\\right)= \\Psi^{-1}\\left(RSP_i(y_i \\mid \\theta)\\right) \\tag{2} \\Psi^{-1}(p) = -\\Phi^{-1}(p) = \\Phi^{-1}(1-p) represents inverse survival function (upper-tailed quantile) standard normal distribution N(0,1). words, Z-residual simply N(0,1) value shares upper-tail area (RSP) observed y_i. transformation effectively maps predictive distribution standard normal scale preserving tail probabilities. model correct, resulting Z-residuals follow standard normal distribution. Intuition: Think Z-residual distance median, rescaled account skewness smoothed handle discreteness. ensures residual +2 always implies degree ‘extremeness’, regardless original distribution’s shape.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/illus_zresid.html","id":"rsp","dir":"Articles","previous_headings":"","what":"RSP","title":"An Animation for Understanding Z-residuals","text":"given observation y_i, Randomized Survival Probability (RSP)—also known randomized probability integral transform—represents value predictive survival function (upper-tail probability) y_i, adjusted randomization term ensure continuity discrete outcomes. defined : RSP_i(y_i \\mid \\theta) = S_i(y_i \\mid \\theta) + U_i \\, p_i(y_i \\mid \\theta) \\tag{1} S_i p_i represent survival function probability mass function, respectively, derived predictive distribution y_i given covariates \\mathbf{x}_i parameters \\theta. U_i \\sim \\text{Unif}(0,1) random uniform variable used smooth discrete outcomes. correctly specified model—observed data y_i arises assumed predictive distribution—RSP follows \\text{Unif}(0,1) distribution.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/illus_zresid.html","id":"z-residual","dir":"Articles","previous_headings":"","what":"Z-residual","title":"An Animation for Understanding Z-residuals","text":"Z-residual (aka randomized quantile residual) derived transforming RSP via inverse survival function N(0,1): z_i(y_i \\mid \\theta) = -\\Phi^{-1}\\left(RSP_i(y_i \\mid \\theta)\\right)= \\Psi^{-1}\\left(RSP_i(y_i \\mid \\theta)\\right) \\tag{2} \\Psi^{-1}(p) = -\\Phi^{-1}(p) = \\Phi^{-1}(1-p) represents inverse survival function (upper-tailed quantile) standard normal distribution N(0,1). words, Z-residual simply N(0,1) value shares upper-tail area (RSP) observed y_i. transformation effectively maps predictive distribution standard normal scale preserving tail probabilities. model correct, resulting Z-residuals follow standard normal distribution. Intuition: Think Z-residual distance median, rescaled account skewness smoothed handle discreteness. ensures residual +2 always implies degree ‘extremeness’, regardless original distribution’s shape.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/illus_zresid.html","id":"z-residuals-of-a-true-model","dir":"Articles","previous_headings":"","what":"Z-residuals of a True Model","title":"An Animation for Understanding Z-residuals","text":"animation Figure 1 demonstrates transformation y_i using true predictive distribution. points simulated, distribution z_i values (shown accumulating points) aligns theoretical N(0,1) density curve. Figure 1: Animation Z-residuals correct model. meters compare True Generation (\\mu=5) Postulated Model (\\mu=5). blue bar represents RSP (upper-tail area), calculated survival probability S(y) plus random fraction probability mass p(y). models match, resulting Z-residuals (red dots) map perfectly standard normal distribution, confirming model fit.","code":""},{"path":"https://tiw150.github.io/Zresidual/articles/illus_zresid.html","id":"z-residuals-of-a-wrong-model","dir":"Articles","previous_headings":"","what":"Z-residuals of a Wrong Model","title":"An Animation for Understanding Z-residuals","text":"animation Figure 2 demonstrates behavior Z-residuals model misspecified. , data y_i simulated True Model (Negative Binomial \\mu=2), residuals calculated based Postulated Model (Negative Binomial \\mu=5). can see observed data (solid bars) fall systematically left expected distribution (dashed bars). observed values smaller expected, calculated RSP values consistently high (upper tail area large), resulting z_i values drift toward negative side standard normal distribution. Figure 2: Animation Z-residual wrong model. Data generated True Model \\mu=2, residuals calculated using Postulated Model \\mu=5. observed values y_i likely smaller expected, resulting RSP values (blue bars) large assumed distribution. Consequently, Z-residuals drift systematically left (negative bias), signaling model overestimates mean.","code":""},{"path":"https://tiw150.github.io/Zresidual/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tingxuan Wu. Author, maintainer. Longhai Li. Author. Hettiarachchige Alias Egodage Dananji. Contributor. Cindy Feng. Contributor.","code":""},{"path":"https://tiw150.github.io/Zresidual/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wu T, Li L (2025). Zresidual: Z-residual: Computing Diagnosing Gaussian-like Residuals. R package version 0.1.0, https://tiw150.github.io/Zresidual.","code":"@Manual{,   title = {Zresidual: Z-residual: Computing and Diagnosing Gaussian-like Residuals},   author = {Tingxuan Wu and Longhai Li},   year = {2025},   note = {R package version 0.1.0},   url = {https://tiw150.github.io/Zresidual}, }"},{"path":"https://tiw150.github.io/Zresidual/changelog.html","id":null,"dir":"","previous_headings":"","what":"December 19, 2025","title":null,"text":"Improve vignettes like: $$Z_i =-\\Phi^{-1} (RSP_i) $${#eq-rsp}, improve table, figure format captions verbal descriptions experiments results. vignettes, can generate large number like 1000 replicated Z-residuals histograms look better, upper-bound p-values sample size. using saved rds save pre-computed objects inst/extdata save re-production time. See : https://gemini.google.com/share/5362ba39f503 Use upper-bound p-values median summarize replicated Z-residuals , even past works survival Z-residuals. theoretically grounded method p-min. Don’t use min p-value, confuses people. Use name recent paper . Sanitize function names names follow patterns, example using log_pred.bern.brms, phurdle, ptruncnb, etc. functions like pdf cdf needs renamed consistent conventional names dnorm.pnorm. function applied class name, register S3 method. can use either two methods: Rename (refactor) messy function names. need change packages. RStudio, can use edit-> find files find function names whole directory. may easiest way change function names. recommend permanent change future developers. Using S3method export create alias users. may easier without modifying internal code may cause confusion future developers. Extend Zresidual method custom models Rewrite methods log_pred.model compute log_pred given fitting class, eg, log_pred.brms, log_pred.coxph,log_pred.survreg, Rewrite method Zresidual take input class log_pred: (log_cdf, log_pmf), vectors. obj Zresidual specific model (e.g, brms), find log_pred.brms, compute Z-residuals Add @concept tags function, reference list organized. Example: add lines _pkgdown.yaml: pkgdown organize functions concept. function can multiple concepts.","code":"#' @concept Zresidual #' @concept visualization #' @concept log_pred #' @concept test reference:     - title: \"Visualization\"     desc: \"Functions for visualizing entropy contributions and model noise.\"     contents:       - has_concept(\"visualization\")    - title: \"Tabulation\"     desc: \"Functions for formatting, printing, and exporting results tables.\"     contents:       - has_concept(\"tabulation\")"},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/index.html","id":"z-residual","dir":"","previous_headings":"","what":"Z-residual","title":"Z-residual: Computing and Diagnosing Gaussian-like Residuals","text":"Zresidual package implements diagnostic residuals based predictive distribution observation. utilizing full probabilistic information model, package generates residuals approximately normally distributed, enabling standard diagnostics Pearson’s residuals OLS. foundation approach Randomized Survival Probability (RSP). given observation y_i, RSP represents value predictive cumulative distribution function (CDF) y_i, randomization term ensure continuity discrete outcomes. defined : RSP_i(y_i \\mid \\theta) = S_i(y_i \\mid \\theta) + U_i \\, p_i(y_i \\mid \\theta) S_i p_i represent survival function probability mass function, respectively, derived predictive distribution y_i given covariates \\mathbf{x}_i parameters \\theta. U_i \\sim \\text{Unif}(0,1) random uniform variable used handle discrete outcomes. correctly specified model observed data y_i arises assumed predictive distribution, RSP follows \\text{Unif}(0,1) distribution. Z-residual derived transforming RSP via inverse standard normal cumulative distribution function: z_i^{RSP}(y_i \\mid \\theta) = -\\Phi^{-1}[RSP_i(y_i \\mid \\theta)] correct model specification, residuals follow standard normal N(0,1) distribution. mapping allows researchers assess quality predictive distribution—including mean, variance, shape—using standard diagnostics Gaussian OLS. practical applications, parameter vector \\theta must estimated. package supports two primary paradigms constructing residuals:","code":""},{"path":"https://tiw150.github.io/Zresidual/index.html","id":"frequentist-models","dir":"","previous_headings":"Z-residual","what":"Frequentist Models","title":"Z-residual: Computing and Diagnosing Gaussian-like Residuals","text":"frequentist models (e.g., survival::coxph, glmmTMB), package computes residuals plugging estimated parameters \\hat{\\theta}. Furthermore, coxph models, package provides cross-validatory Z-residuals allow rigorous validation survival models within frequentist framework.","code":""},{"path":"https://tiw150.github.io/Zresidual/index.html","id":"bayesian-models","dir":"","previous_headings":"Z-residual","what":"Bayesian Models","title":"Z-residual: Computing and Diagnosing Gaussian-like Residuals","text":"Bayesian models (e.g., brms), package accounts parameter uncertainty integrating posterior distribution: Posterior Z-residuals: obtained averaging RSPs full-data posterior f(\\theta \\mid y). Although approach involves “double use data” since observations estimation residual calculation, z-residuals asymptotically distributed N(0,1) test p-values asymptotically Uniform (0,1) approach “summarize first test” used. Importance-Sampling Cross-Validatory (ISCV) Z-residuals: provide robust diagnostic, package implements ISCV Z-residuals. method approximates leave-one-(LOO) RSPs using importance sampling based full-data posterior. deleted residuals OLS, ISCV Z-residuals variance slightly greater 1. resulting posterior ISCV Z-residuals approximately standard normal, enabling full range graphical numerical diagnostics Bayesian models.","code":""},{"path":"https://tiw150.github.io/Zresidual/index.html","id":"supported-models","dir":"","previous_headings":"","what":"Supported Models","title":"Z-residual: Computing and Diagnosing Gaussian-like Residuals","text":"Zresidual package provides built-support objects generated several prominent R modeling packages. current implementation includes: survival: Support Cox Proportional Hazards models (coxph) parametric survival models (survreg). glmmTMB: Support Generalized Linear Mixed Models, including zero-inflation complex covariance structures. brms: Support wide array Bayesian regression models via brmsfit interface. stats: Support standard Generalized Linear Models (glm). (still incomplete) Custom Models: Support user-defined framework providing log_cdf log_pmf arguments generic Zresidual method.","code":""},{"path":"https://tiw150.github.io/Zresidual/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Z-residual: Computing and Diagnosing Gaussian-like Residuals","text":"can install development version package GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"tiw150/Zresidual\")"},{"path":"https://tiw150.github.io/Zresidual/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Z-residual: Computing and Diagnosing Gaussian-like Residuals","text":"Feng, C., Li, L., Sadeghpour, ., 2020. comparison residual diagnosis tools diagnosing regression models count data. BMC Medical Research Methodology 20, 175. https://doi.org/10.1186/s12874-020-01055-2 (OA). Li L, Wu T, Feng C. Model diagnostics censored regression via randomized survival probabilities. Statistics Medicine. 2021; 40: 1482–1497. https://doi.org/10.1002/sim.8852; Reprint version Wu, T., Li, L., & Feng, C. (2024). Z-residual diagnostic tool assessing covariate functional form shared frailty models. Journal Applied Statistics, 52(1), 28–58. https://doi.org/10.1080/02664763.2024.2355551; Reprint version Wu, T., Feng, C., & Li, L. (2024). Cross-Validatory Z-Residual Diagnosing Shared Frailty Models. American Statistician, 79(2), 198–211. https://doi.org/10.1080/00031305.2024.2421370; Reprint version","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.coxph.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated Z-residuals for Cox proportional hazards models — CV.Zresidual.coxph","title":"Cross-validated Z-residuals for Cox proportional hazards models — CV.Zresidual.coxph","text":"S3 method generic function CV.Zresidual() applied Cox proportional hazards models fitted survival::coxph(). method computes cross-validated Z-residuals, automatically detecting whether frailty term present model formula. dispatches appropriate internal implementation standard Cox models shared frailty Cox models.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.coxph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated Z-residuals for Cox proportional hazards models — CV.Zresidual.coxph","text":"","code":"# S3 method for class 'coxph' CV.Zresidual(object, nfolds, foldlist = NULL, data = NULL, nrep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.coxph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated Z-residuals for Cox proportional hazards models — CV.Zresidual.coxph","text":"object fitted survival::coxph model object. nfolds Integer. number folds cross-validation (K K-fold CV). foldlist Optional list specifying custom fold assignments. NULL, folds generated internally, often ensuring balanced distribution events. data Optional data frame used refit model cross-validation. required original model call contain data explicitly, foldlist supplied. nrep Integer. Number repeated cross-validations perform. Default 1. Repeating CV provides stable estimate residuals. ... arguments passed internal worker functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.coxph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated Z-residuals for Cox proportional hazards models — CV.Zresidual.coxph","text":"matrix class \"cvzresid\" (others inherited internal worker) dimension \\(N \\times nrep\\) (\\(N\\) number observations). matrix columns contain cross-validated Z-residuals. object also includes following diagnostic attributes: Survival.Prob: Cross-validated predicted survival probabilities \\(\\hat S_i(t_i)\\). linear.pred: Cross-validated linear predictors \\(\\eta_i = \\mathbf{x}_i^\\top \\hat{\\boldsymbol{\\beta}}\\). censored.status: event indicator survival object. covariates: covariates used model. object.model.frame: model frame original data.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.coxph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validated Z-residuals for Cox proportional hazards models — CV.Zresidual.coxph","text":"method determines correct worker function examining attr(object$terms, \"specials\")$frailty: Standard Cox Models: frailty term found, calls CV_Zresidual_coxph_survival. Shared Frailty Cox Models: frailty term (e.g., frailty(group)) present, calls CV_Zresidual_coxph_frailty_survival. returned object matrix Z-residuals crucial diagnostic information stored attributes.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.coxph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validated Z-residuals for Cox proportional hazards models — CV.Zresidual.coxph","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)   # Example 1: Standard Cox Model   fit_std <- coxph(Surv(time, status) ~ age + sex, data = lung)   cv_out_std <- CV.Zresidual(fit_std, nfolds = 5, data = lung)    # Example 2: Shared Frailty Cox Model (assuming the lung data has a group column 'inst')   # lung$inst_factor <- as.factor(lung$inst)   # fit_frty <- coxph(Surv(time, status) ~ age + sex + frailty(inst_factor), data = lung)   # cv_out_frty <- CV.Zresidual(fit_frty, nfolds = 5, data = lung) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated Z-residual diagnostics (generic) — CV.Zresidual","title":"Cross-validated Z-residual diagnostics (generic) — CV.Zresidual","text":"Generic function cross-validated Z-residual diagnostics. Method dispatch based class object. Methods currently provided survival models coxph survreg.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated Z-residual diagnostics (generic) — CV.Zresidual","text":"","code":"CV.Zresidual(object, nfolds, foldlist = NULL, data = NULL, nrep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated Z-residual diagnostics (generic) — CV.Zresidual","text":"object fitted model object. nfolds Integer. Number folds cross-validation. foldlist Optional list specifying custom fold assignments. NULL, folds generated internally method. data Optional data frame used refit model cross-validation, required method. nrep Integer. Number repeated cross-validations perform. Default 1. ... arguments passed specific methods.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated Z-residual diagnostics (generic) — CV.Zresidual","text":"object whose structure depends underlying method, typically tagged class \"cvzresid\" addition method-specific classes.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validated Z-residual diagnostics (generic) — CV.Zresidual","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)   fit <- coxph(Surv(time, status) ~ age + sex, data = lung)   out <- CV.Zresidual(fit, nfolds = 5, data = lung) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.survreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated Z-residuals for parametric survival regression models — CV.Zresidual.survreg","title":"Cross-validated Z-residuals for parametric survival regression models — CV.Zresidual.survreg","text":"S3 method CV.Zresidual() applied parametric survival regression models fitted survreg. method performs K-fold cross-validation obtain external Z-residuals model diagnostics.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.survreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated Z-residuals for parametric survival regression models — CV.Zresidual.survreg","text":"","code":"# S3 method for class 'survreg' CV.Zresidual(object, nfolds, foldlist = NULL, data = NULL, nrep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.survreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated Z-residuals for parametric survival regression models — CV.Zresidual.survreg","text":"object fitted survreg model object. nfolds Integer. Number folds cross-validation. foldlist Optional list specifying custom fold assignments. NULL, folds generated internally, typically stratified survival response censoring indicator. data Optional data frame used refit model cross-validation. highly recommended supply original data ensure correct model refitting fold, especially original call complex. nrep Integer. Number repeated Z-residual samples per observation generate. Defaults 1. replicate involves re-randomizing imputed survival probability censored observations. ... arguments passed internal worker function CV_Zresidual_survreg_survival.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.survreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated Z-residuals for parametric survival regression models — CV.Zresidual.survreg","text":"object class \"cvzresid\" containing cross-validated Z-residual diagnostics parametric survival model. numeric matrix \\(N\\) rows nrep columns, accompanied diagnostic attributes (see CV_Zresidual_survreg_survival details).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.survreg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validated Z-residuals for parametric survival regression models — CV.Zresidual.survreg","text":"method delegates actual cross-validation work CV_Zresidual_survreg_survival, handles iterative refitting survreg model \\(K-1\\) folds computes randomized Z-residuals held-fold. randomized Z-residual, \\(Z_{ij}\\), \\(j\\)-th observation \\(\\)-th fold defined : $$Z_{ij} = ...$$ computed based predicted --sample survival probability \\(\\hat{S}_{\\text{train}_i}(t_j)\\). returned object tagged class \"cvzresid\" addition classes returned internal worker.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/CV.Zresidual.survreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validated Z-residuals for parametric survival regression models — CV.Zresidual.survreg","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)   # Fit a Weibull model   fit_weibull <- survreg(Surv(time, status) ~ age + sex,                          data = lung, dist = \"weibull\")   # Compute 5-fold cross-validated Z-residuals   cv_out <- CV.Zresidual(fit_weibull, nfolds = 5, data = lung, nrep = 10)    # Check the first few cross-validated residuals   head(cv_out) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_frailty_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated Z-residuals for Shared Frailty Cox Models — CV_Zresidual_coxph_frailty_survival","title":"Cross-validated Z-residuals for Shared Frailty Cox Models — CV_Zresidual_coxph_frailty_survival","text":"Internal function compute cross-validated Z-residuals shared frailty Cox proportional hazards models.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_frailty_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated Z-residuals for Shared Frailty Cox Models — CV_Zresidual_coxph_frailty_survival","text":"","code":"CV_Zresidual_coxph_frailty_survival(   fit.coxph,   data,   nfolds,   foldlist,   n.rep,   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_frailty_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated Z-residuals for Shared Frailty Cox Models — CV_Zresidual_coxph_frailty_survival","text":"fit.coxph fitted survival::coxph model object containing frailty term. data Optional data frame containing data. Required original model fit without specifying data argument foldlist supplied. nfolds Integer. Number folds cross-validation (K K-fold CV). foldlist Optional list specifying custom fold assignments. n.rep Integer. Number repeated cross-validations. ... Additional arguments.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_frailty_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated Z-residuals for Shared Frailty Cox Models — CV_Zresidual_coxph_frailty_survival","text":"matrix containing cross-validated Z-residuals (\\(N \\times nrep\\)) diagnostic attributes: Survival.Prob, linear.pred, censored.status, covariates, object.model.frame.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_frailty_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validated Z-residuals for Shared Frailty Cox Models — CV_Zresidual_coxph_frailty_survival","text":"function implements K-fold cross-validation procedure specifically shared frailty Cox models (.e., containing frailty() term). fold, model refitted training data, Z-residuals calculated held-test data.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated Z-residuals for Standard Cox Models — CV_Zresidual_coxph_survival","title":"Cross-validated Z-residuals for Standard Cox Models — CV_Zresidual_coxph_survival","text":"Internal function compute cross-validated Z-residuals standard Cox proportional hazards models (without frailty).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated Z-residuals for Standard Cox Models — CV_Zresidual_coxph_survival","text":"","code":"CV_Zresidual_coxph_survival(fit.coxph, data, nfolds, foldlist, n.rep, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated Z-residuals for Standard Cox Models — CV_Zresidual_coxph_survival","text":"fit.coxph fitted survival::coxph model object. data Optional data frame containing data. Required original model fit without specifying data argument foldlist supplied. nfolds Integer. Number folds cross-validation (K K-fold CV). foldlist Optional list specifying custom fold assignments. n.rep Integer. Number repeated cross-validations. ... Additional arguments.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated Z-residuals for Standard Cox Models — CV_Zresidual_coxph_survival","text":"matrix containing cross-validated Z-residuals (\\(N \\times nrep\\)) diagnostic attributes: Survival.Prob, linear.pred, censored.status, covariates, object.model.frame.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_coxph_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validated Z-residuals for Standard Cox Models — CV_Zresidual_coxph_survival","text":"function implements K-fold cross-validation procedure. fold, Cox model refitted training data, Z-residuals calculated held-test data. approach models without shared frailty terms.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_survreg_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validated Z-residuals for Survreg Models — CV_Zresidual_survreg_survival","title":"Cross-validated Z-residuals for Survreg Models — CV_Zresidual_survreg_survival","text":"Internal function compute cross-validated Z-residuals parametric survival regression models fitted survreg.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_survreg_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validated Z-residuals for Survreg Models — CV_Zresidual_survreg_survival","text":"","code":"CV_Zresidual_survreg_survival(fit.survreg, data, nfolds, foldlist, n.rep, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_survreg_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validated Z-residuals for Survreg Models — CV_Zresidual_survreg_survival","text":"fit.survreg fitted survreg model object. data Optional data.frame used cross-validation. Highly recommended original model fit without specifying data argument foldlist supplied. nfolds Integer. Number folds cross-validation (\\(K\\) K-fold CV). foldlist Optional list specifying custom fold assignments. NULL, folds generated internally, typically stratified survival response. n.rep Integer. Number repeated Z-residual samples generate per observation (Monte Carlo replications censored observations). ... Additional arguments passed residual calculation function Zresidual_survreg_survival().","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_survreg_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validated Z-residuals for Survreg Models — CV_Zresidual_survreg_survival","text":"numeric matrix containing cross-validated Z-residuals (\\(N \\times nrep\\)), \\(N\\) total number observations. matrix carries following diagnostic attributes: Survival.Prob: --sample predicted survival probabilities. linear.pred: --sample linear predictors (survreg scale). censored.status: Event indicator (1 = event, 0 = censored). covariates: Data frame covariates used. object.model.frame: full model frame used CV residual calculation. type: Character string, typically \"survival\".","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/CV_Zresidual_survreg_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-validated Z-residuals for Survreg Models — CV_Zresidual_survreg_survival","text":"function implements K-fold cross-validation procedure. fold, parametric survival model (preserving original distribution, e.g., Weibull) refitted training data. --sample randomized Z-residuals calculated held-test data. Data Handling Note: data NULL, internal model frame must manually reconstructed standard data frame (un-packing Surv object) survreg model can successfully refitted training subset fold. Failed model fits cross-validation result NA residuals corresponding test fold.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Zresidual: Diagnostics with Z-residuals — Zresidual-package","title":"Zresidual: Diagnostics with Z-residuals — Zresidual-package","text":"Provides unified framework computing analyzing Z-residuals across diverse range statistical models. package facilitates model diagnostics transforming outputs popular modeling frameworks—including 'coxph', 'survreg', 'glmmTMB', 'brms'—standardized Z-residuals. tools enable researchers assess model fit, identify outliers, detect misspecification. addition standard residuals, package implements cross-validatory variants support robust predictive assessments model validation workflows.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Zresidual: Diagnostics with Z-residuals — Zresidual-package","text":"Maintainer: Tingxuan Wu tiw150@mail.usask.ca Authors: Longhai Li longhai@math.usask.ca contributors: Hettiarachchige Alias Egodage Dananji ocf542@mail.usask.ca [contributor] Cindy Feng longhai@math.usask.ca [contributor]","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.bernoulli.brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for Bernoulli models fitted with brms — Zresidual.bernoulli.brms","title":"Z-residuals for Bernoulli models fitted with brms — Zresidual.bernoulli.brms","text":"Zresidual.bernoulli.brms() S3 method Zresidual() applied Bernoulli (binary) regression models fitted brms::brm() family = bernoulli(). Objects dispatched fitted object \"brmsfit\" family \"bernoulli\" internally tagged class \"bernoulli.brms\" Zresidual(). cases users call Zresidual() directly brmsfit object, e.g. Zresidual(fit), rather calling Zresidual.bernoulli.brms() explicitly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.bernoulli.brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for Bernoulli models fitted with brms — Zresidual.bernoulli.brms","text":"","code":"# S3 method for class 'bernoulli.brms' Zresidual(object, nrep = 1, data = NULL, type = NULL, method = \"iscv\", ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.bernoulli.brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for Bernoulli models fitted with brms — Zresidual.bernoulli.brms","text":"object brmsfit object brms::family(object)$family == \"bernoulli\". nrep Integer; number replicated Z-residual sets generate. Defaults 1. data Optional data frame used prediction. NULL, data stored inside brmsfit object used. type Optional character string controlling residual type, interpreted underlying implementation (used). method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" randomized posterior predictive p-values, \"mpost\" middle-value posterior predictive p-values. Default \"iscv\". ... arguments passed underlying implementation","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.bernoulli.brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for Bernoulli models fitted with brms — Zresidual.bernoulli.brms","text":"numeric matrix Z-residuals one column per replication, returned Zresidual_bernoulli_brms(), class \"zresid\" added class vector.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.bernoulli.brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-residuals for Bernoulli models fitted with brms — Zresidual.bernoulli.brms","text":"","code":"if (FALSE) { # \\dontrun{   library(brms)   fit_bern <- brm(y ~ x1 + x2, data = df, family = bernoulli())    ## ISCV-based Z-residuals   z1 <- Zresidual(fit_bern, method = \"iscv\", nrep = 2)    ## Posterior predictive Z-residuals   z2 <- Zresidual(fit_bern, method = \"rpost\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.coxph.survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for Cox proportional hazards models (survival package) — Zresidual.coxph.survival","title":"Z-residuals for Cox proportional hazards models (survival package) — Zresidual.coxph.survival","text":"Zresidual.coxph.survival() computes randomized Z-residuals Cox proportional hazards models fitted coxph, supporting standard shared frailty models. S3 method designed called via generic function Zresidual. function automatically detects presence frailty term (e.g., frailty(group)) dispatches calculation one two internal implementations. residuals intended -sample diagnostics model assessment.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.coxph.survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for Cox proportional hazards models (survival package) — Zresidual.coxph.survival","text":"","code":"# S3 method for class 'coxph.survival' Zresidual(object, nrep = 1, data = NULL, type = NULL, method = NULL, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.coxph.survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for Cox proportional hazards models (survival package) — Zresidual.coxph.survival","text":"object fitted coxph model. Supports standard Cox models shared frailty models. nrep Integer; number independent randomized Z-residual replicates generate. Defaults 1. data Optional data.frame containing survival response covariates. NULL (default), residuals computed data used fit object. parameter often aliased newdata internal worker functions. type Optional character string controlling residual type. Set internally \"survival\" Cox models. method Character string specifying residual calculation method. Currently unused. ... arguments passed underlying implementation functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.coxph.survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for Cox proportional hazards models (survival package) — Zresidual.coxph.survival","text":"numeric matrix class \"zresid\" dimension \\(N \\times nrep\\). column independent set Z-residuals. following diagnostic attributes attached: Survival.Prob: Vector predicted survival probabilities \\(S_i(t_i)\\). linear.pred: Vector linear predictors \\(\\eta_i = \\mathbf{x}_i \\mathbf{\\hat{\\beta}}\\). covariates: Data frame covariates used model. censored.status: Event indicator (1 = event, 0 = censored). object.model.frame: model.frame used computation. type: Character string, always \"survival\".","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.coxph.survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Z-residuals for Cox proportional hazards models (survival package) — Zresidual.coxph.survival","text":"method dispatches work based model formula: Standard Cox models (Frailty): function calls Zresidual_coxph_survival compute Z-residuals using fixed effects (\\(\\mathbf{x}\\hat{\\mathbf{\\beta}}\\)) estimated baseline cumulative hazard function \\(\\hat{H}_0(t)\\). Shared Frailty Cox models: function calls Zresidual_coxph_frailty_survival. implementation computes residuals accounting cluster-level frailty effect (\\(\\hat{z}_{\\text{group}}\\)). requires data used fitting (traindata) reconstruct baseline hazard estimate frailty term. Randomization Censored Observations: Since true survival probability censored observation $$ known greater \\(S_i(t_i)\\), Z-residual uses randomized survival probability: \\(S_{, \\text{rand}}(t_i) = S_i(t_i) \\cdot U\\), \\(U \\sim \\text{Unif}(0, 1)\\). randomization repeated nrep times.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.coxph.survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-residuals for Cox proportional hazards models (survival package) — Zresidual.coxph.survival","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)    ## Standard Cox model (no frailty term)   fit_cox <- coxph(Surv(time, status) ~ age + sex, data = lung)   # Note: The internal class 'coxph.survival' is usually added by a wrapper,   # but Zresidual() handles dispatch automatically.   z_cox <- Zresidual(fit_cox, nrep = 10, data = lung)    ## Shared frailty Cox model (in-sample residuals)   # Note: 'inst' must be a grouping factor.   lung$inst_f <- factor(lung$inst)   fit_frail <- coxph(Surv(time, status) ~ age + sex + frailty(inst_f),                      data = lung)   z_in <- Zresidual(fit_frail, nrep = 5) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Z-residuals via an S3 generic — Zresidual","title":"Compute Z-residuals via an S3 generic — Zresidual","text":"Zresidual() S3 generic computing Z-residuals range survival regression models. currently supports Cox proportional hazards models (coxph) without frailty terms, parametric survival regression models (survreg), Bayesian regression models fitted brms (brmsfit) several common count hurdle families. function inspects fitted object, assigns internal model– package–specific class (e.g. \"coxph.survival\", \"survreg.survival\", \"poisson.brms\", \"hurdle_poisson.brms\"), dispatches corresponding Zresidual.*() method.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Z-residuals via an S3 generic — Zresidual","text":"","code":"Zresidual(object, nrep = 1, data = NULL, type = NULL, method = \"iscv\", ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Z-residuals via an S3 generic — Zresidual","text":"object fitted model object. Currently supported objects include: \"coxph\" – Cox proportional hazards model (survival) \"survreg\" – Parametric survival regression (survival) \"brmsfit\" – Bayesian regression model (brms) one supported families listed Details. nrep Integer. Number replicated Z-residual samples compute. Default 1. data Optional data frame used generating model predictions residuals. models (e.g. coxph frailty terms) match data used fit model. type Optional character string. Residual type hurdle count models (mainly used brms Bayesian/count-model interfaces). interpretation argument model-specific. method Character string indicating predictive p-value scheme use computing Z-residuals Bayesian simulation-based models. Common options include \"iscv\" (importance-sampling cross-validated), \"loocv\", \"posterior\". default \"iscv\". ... arguments passed model-specific methods Zresidual.coxph.survival(), Zresidual.survreg.survival(), Zresidual.poisson.brms(), etc.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Z-residuals via an S3 generic — Zresidual","text":"object class \"zresid\" additional class information inherited model-specific method. object contains computed Z-residuals model-specific diagnostic quantities returned underlying Zresidual.*() implementation.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Z-residuals via an S3 generic — Zresidual","text":"Internally, Zresidual() modifies class object encode model type fitting package, uses S3 method dispatch: survival models coxph objects receive class \"coxph.survival\" handled Zresidual.coxph.survival(), distinguishes models without frailty terms. survreg objects receive class \"survreg.survival\" handled Zresidual.survreg.survival(). brms models family obtained via family(object)$family. Currently supported families include \"hurdle_negbinomial\", \"hurdle_poisson\", \"negbinomial\", \"poisson\", \"bernoulli\". supported family mapped class form \"<family>.brms\", dispatched method Zresidual.hurdle_poisson.brms(), Zresidual.negbinomial.brms(), Zresidual.poisson.brms(), Zresidual.bernoulli.brms(). Additional model classes (e.g. glmmTMB fits) can supported defining new S3 methods Zresidual.poisson.glmmTMB() ensuring Zresidual() assigns corresponding internal class (example \"poisson.glmmTMB\"). object match supported model class, brmsfit object uses unsupported family, Zresidual() raises error.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Z-residuals via an S3 generic — Zresidual","text":"","code":"if (FALSE) { # \\dontrun{ ## Cox proportional hazards model library(survival) fit_cox <- coxph(Surv(time, status) ~ age + sex, data = lung) z_cox <- Zresidual(fit_cox, nrep = 10, data = lung)  ## Parametric survival regression fit_surv <- survreg(Surv(time, status) ~ age + sex,                     data = lung, dist = \"weibull\") z_surv <- Zresidual(fit_surv, nrep = 5, data = lung)  ## Bayesian Poisson regression with brms library(brms) fit_brms <- brm(count ~ x, data = df, family = poisson) z_brms <- Zresidual(fit_brms, method = \"posterior\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_negbinomial.brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for hurdle negative binomial models fitted with brms — Zresidual.hurdle_negbinomial.brms","title":"Z-residuals for hurdle negative binomial models fitted with brms — Zresidual.hurdle_negbinomial.brms","text":"Zresidual.hurdle_negbinomial.brms() S3 method Zresidual() applied hurdle negative binomial models fitted brms::brm() family = hurdle_negbinomial(). Objects dispatched fitted object \"brmsfit\" brms::family(object)$family == \"hurdle_negbinomial\" internally tagged class \"hurdle_negbinomial.brms\" Zresidual(). normal use, users call Zresidual() directly brmsfit object (example Zresidual(fit)), rather calling Zresidual.hurdle_negbinomial.brms() explicitly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_negbinomial.brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for hurdle negative binomial models fitted with brms — Zresidual.hurdle_negbinomial.brms","text":"","code":"# S3 method for class 'hurdle_negbinomial.brms' Zresidual(   object,   nrep = 1,   data,   type = c(\"hurdle\", \"count\", \"zero\"),   method = \"iscv\",   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_negbinomial.brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for hurdle negative binomial models fitted with brms — Zresidual.hurdle_negbinomial.brms","text":"object brmsfit object hurdle negative binomial family (brms::family(object)$family == \"hurdle_negbinomial\"). nrep Integer; number replicated Z-residual sets generate. Default 1. data Optional data frame used prediction residual computation. NULL, data stored inside brmsfit object used. type Character string specifying part model compute Z-residuals : \"zero\"   — hurdle/zero part; \"count\"  — truncated negative binomial count part; \"hurdle\" — full hurdle negative binomial model. default \"hurdle\". method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" randomized posterior predictive p-values, \"mpost\" middle-value posterior predictive p-values. Default \"iscv\". ... arguments passed underlying implementation function Zresidual_hurdle_negbinomial_brms().","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_negbinomial.brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for hurdle negative binomial models fitted with brms — Zresidual.hurdle_negbinomial.brms","text":"numeric matrix Z-residuals (one column per replication) returned Zresidual_hurdle_negbinomial_brms(), class \"zresid\" added class vector.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_negbinomial.brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-residuals for hurdle negative binomial models fitted with brms — Zresidual.hurdle_negbinomial.brms","text":"","code":"if (FALSE) { # \\dontrun{   library(brms)   fit_hnb <- brm(y ~ x1 + x2, data = df,                  family = hurdle_negbinomial())    ## Counts part only   z_count <- Zresidual(fit_hnb, type = \"count\", method = \"iscv\")    ## Full hurdle model with 2 replicates   z_hurdle <- Zresidual(fit_hnb, type = \"hurdle\", nrep = 2) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_poisson.brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for hurdle Poisson models fitted with brms — Zresidual.hurdle_poisson.brms","title":"Z-residuals for hurdle Poisson models fitted with brms — Zresidual.hurdle_poisson.brms","text":"Zresidual.hurdle_poisson.brms() S3 method Zresidual() applied hurdle Poisson models fitted brms::brm() family = hurdle_poisson(). Objects dispatched fitted object \"brmsfit\" brms::family(object)$family == \"hurdle_poisson\" internally tagged class \"hurdle_poisson.brms\" Zresidual(). normal use, users call Zresidual() directly brmsfit object (example Zresidual(fit)), rather calling Zresidual.hurdle_poisson.brms() explicitly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_poisson.brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for hurdle Poisson models fitted with brms — Zresidual.hurdle_poisson.brms","text":"","code":"# S3 method for class 'hurdle_poisson.brms' Zresidual(   object,   nrep = 1,   data,   type = c(\"hurdle\", \"count\", \"zero\"),   method = \"iscv\",   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_poisson.brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for hurdle Poisson models fitted with brms — Zresidual.hurdle_poisson.brms","text":"object brmsfit object hurdle Poisson family (brms::family(object)$family == \"hurdle_poisson\"). nrep Integer; number replicated Z-residual sets generate. Default 1. data Optional data frame used prediction residual computation. NULL (default), data stored inside brmsfit object used. type Character string specifying part model compute Z-residuals : \"zero\"   — hurdle/zero part; \"count\"  — truncated Poisson count part; \"hurdle\" — full hurdle-Poisson model. default \"hurdle\". method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" randomized posterior predictive p-values, \"mpost\" middle-value posterior predictive p-values. Default \"iscv\". ... arguments passed underlying implementation function Zresidual_hurdle_poisson_brms().","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_poisson.brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for hurdle Poisson models fitted with brms — Zresidual.hurdle_poisson.brms","text":"numeric matrix Z-residuals (one column per replication) returned Zresidual_hurdle_poisson_brms(), class \"zresid\" added class vector.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.hurdle_poisson.brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-residuals for hurdle Poisson models fitted with brms — Zresidual.hurdle_poisson.brms","text":"","code":"if (FALSE) { # \\dontrun{   library(brms)   fit_hp <- brm(y ~ x1 + x2, data = df,                 family = hurdle_poisson())    ## Counts part only   z_count <- Zresidual(fit_hp, type = \"count\", method = \"iscv\")    ## Full hurdle model with 2 replicates   z_hurdle <- Zresidual(fit_hp, type = \"hurdle\", nrep = 2) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.negbinomial.brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for negative binomial models fitted with brms — Zresidual.negbinomial.brms","title":"Z-residuals for negative binomial models fitted with brms — Zresidual.negbinomial.brms","text":"Zresidual.negbinomial.brms() S3 method Zresidual() applied negative binomial models fitted brms::brm() family = negbinomial(). Objects dispatched fitted object \"brmsfit\" brms::family(object)$family == \"negbinomial\" internally tagged class \"negbinomial.brms\" Zresidual(). normal use, users call Zresidual() directly brmsfit object (example Zresidual(fit)), rather calling Zresidual.negbinomial.brms() explicitly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.negbinomial.brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for negative binomial models fitted with brms — Zresidual.negbinomial.brms","text":"","code":"# S3 method for class 'negbinomial.brms' Zresidual(object, nrep = 1, data, type, method = \"iscv\", ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.negbinomial.brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for negative binomial models fitted with brms — Zresidual.negbinomial.brms","text":"object brmsfit object negative binomial family (brms::family(object)$family == \"negbinomial\"). nrep Integer; number replicated Z-residual sets generate. Default 1. data Optional data frame used prediction residual computation. NULL (default), data stored inside brmsfit object used. type Optional character string controlling residual type, interpreted underlying implementation (used). method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" posterior predictive p-values, \"mpost\" marginal posterior predictive p-values. Default \"iscv\". ... arguments passed underlying implementation function Zresidual_negbinomial_brms().","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.negbinomial.brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for negative binomial models fitted with brms — Zresidual.negbinomial.brms","text":"numeric matrix Z-residuals (one column per replication) returned Zresidual_negbinomial_brms(), class \"zresid\" added class vector.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.negbinomial.brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-residuals for negative binomial models fitted with brms — Zresidual.negbinomial.brms","text":"","code":"if (FALSE) { # \\dontrun{   library(brms)   fit_nb <- brm(y ~ x1 + x2, data = df,                 family = negbinomial())    ## ISCV-based Z-residuals   z_nb <- Zresidual(fit_nb, method = \"iscv\")    ## Posterior predictive Z-residuals with 2 replicates   z_nb_post <- Zresidual(fit_nb, method = \"rpost\", nrep = 2) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.poisson.brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for Poisson models fitted with brms — Zresidual.poisson.brms","title":"Z-residuals for Poisson models fitted with brms — Zresidual.poisson.brms","text":"Zresidual.poisson.brms() S3 method Zresidual() applied Poisson models fitted brms::brm() family = poisson(). Objects dispatched fitted object \"brmsfit\" brms::family(object)$family == \"poisson\" internally tagged class \"poisson.brms\" Zresidual(). normal use, users call Zresidual() directly brmsfit object (example Zresidual(fit)), rather calling Zresidual.poisson.brms() explicitly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.poisson.brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for Poisson models fitted with brms — Zresidual.poisson.brms","text":"","code":"# S3 method for class 'poisson.brms' Zresidual(object, nrep = 1, data, type, method = \"iscv\", ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.poisson.brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for Poisson models fitted with brms — Zresidual.poisson.brms","text":"object brmsfit object Poisson family (brms::family(object)$family == \"poisson\"). nrep Integer; number replicated Z-residual sets generate. Default 1. data Optional data frame used prediction residual computation. NULL (default), data stored inside brmsfit object used. type Optional character string controlling residual type, interpreted underlying implementation (used). method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" posterior predictive p-values, \"mpost\" marginal posterior predictive p-values. Default \"iscv\". ... arguments passed Zresidual(). ignored method accepted consistency generic.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.poisson.brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for Poisson models fitted with brms — Zresidual.poisson.brms","text":"numeric matrix Z-residuals (one column per replication) returned Zresidual_poisson_brms(), class \"zresid\" added class vector.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.poisson.brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-residuals for Poisson models fitted with brms — Zresidual.poisson.brms","text":"","code":"if (FALSE) { # \\dontrun{   library(brms)   fit_pois <- brm(y ~ x1 + x2, data = df,                   family = poisson())    ## ISCV-based Z-residuals   z_pois <- Zresidual(fit_pois, method = \"iscv\")    ## Posterior predictive Z-residuals with 2 replicates   z_pois_post <- Zresidual(fit_pois, method = \"rpost\", nrep = 2) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.survreg.survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for parametric survival regression models (survival) — Zresidual.survreg.survival","title":"Z-residuals for parametric survival regression models (survival) — Zresidual.survreg.survival","text":"S3 method Zresidual() fitted model survival::survreg() object (internally tagged \"survreg.survival\"). thin wrapper around existing Zresidual.survreg() core implementation: simply passes fitted object optional data core function adds \"zresid\" class. Users expected call Zresidual() directly rather calling Zresidual.survreg.survival().","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.survreg.survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for parametric survival regression models (survival) — Zresidual.survreg.survival","text":"","code":"# S3 method for class 'survreg.survival' Zresidual(object, nrep = 1, data = NULL, type = NULL, method = NULL, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.survreg.survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for parametric survival regression models (survival) — Zresidual.survreg.survival","text":"object fitted survival::survreg() model. nrep Integer; number randomized Z-residual replicates generate. Defaults 1. data Optional data frame containing survival response covariates; NULL, original model frame used. type Optional character string controlling residual type, interpreted underlying implementation (used). survreg models, typically set internally \"survival\". method Character string specifying residual calculation method (applicable underlying worker function). Currently unused default implementation. ... arguments passed underlying implementation functions. Currently unused.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.survreg.survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for parametric survival regression models (survival) — Zresidual.survreg.survival","text":"numeric matrix dimension \\(n \\times\\) nrep, additional attributes produced Zresidual_survreg_survival(). returned object given class \"zresid\" addition existing classes.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual.survreg.survival.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-residuals for parametric survival regression models (survival) — Zresidual.survreg.survival","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)   fit_surv <- survreg(Surv(time, status) ~ age + sex,                       data = lung, dist = \"weibull\")   z_surv <- Zresidual(fit_surv, nrep = 5, data = lung) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_bernoulli_brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Z-residuals for a Bernoulli/Logistic brms model — Zresidual_bernoulli_brms","title":"Compute Z-residuals for a Bernoulli/Logistic brms model — Zresidual_bernoulli_brms","text":"Computes Z-residuals fitted Bayesian Bernoulli/Logistic (binary) model fitted brms::brm() family = bernoulli(). Z-residuals calculated using posterior predictive methods can used model diagnostics. internal workhorse Zresidual.bernoulli.brms() intended called directly end users.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_bernoulli_brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Z-residuals for a Bernoulli/Logistic brms model — Zresidual_bernoulli_brms","text":"","code":"Zresidual_bernoulli_brms(   fit,   method = \"iscv\",   n.rep = 1,   data = NULL,   type = NULL,   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_bernoulli_brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Z-residuals for a Bernoulli/Logistic brms model — Zresidual_bernoulli_brms","text":"fit fitted brmsfit model object Bernoulli family. method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" randomized posterior predictive p-values, \"mpost\" middle-value posterior predictive p-values. Default \"iscv\". n.rep Integer; number replicated Z-residual sets generate. Default 1. data Optional data frame used override data stored inside fit prediction diagnostic calculation. NULL, data embedded fit used. type Optional character string controlling residual type; meaning determined underlying implementation (used). ... arguments passed lower-level helpers.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_bernoulli_brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Z-residuals for a Bernoulli/Logistic brms model — Zresidual_bernoulli_brms","text":"numeric matrix Z-residuals attributes: type: Type outcome (Bernoulli). zero_id: Indices zero outcomes. log_pmf: Log-probability mass function values. log_cdf: Log-cumulative distribution function values. covariates: Model covariates. linear.pred: Linear predictor values fitted model.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_bernoulli_brms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Z-residuals for a Bernoulli/Logistic brms model — Zresidual_bernoulli_brms","text":"function typically performs following steps: Extracts observed response vector model data. Computes log-PMF log-CDF Bernoulli model using log_pred_dist_bern. Generates posterior predictive p-values according specified method. Converts p-values Z-residuals via negative quantile standard normal distribution. output matrix Z-residuals one column per replication.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_coxph_frailty_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for Standard Cox Models with Frailty terms (Internal Worker) — Zresidual_coxph_frailty_survival","title":"Z-residuals for Standard Cox Models with Frailty terms (Internal Worker) — Zresidual_coxph_frailty_survival","text":"Z-residuals Standard Cox Models Frailty terms (Internal Worker)","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_coxph_frailty_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for Standard Cox Models with Frailty terms (Internal Worker) — Zresidual_coxph_frailty_survival","text":"","code":"Zresidual_coxph_frailty_survival(fit_coxph, traindata, newdata, n.rep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_coxph_survival.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-residuals for Standard Cox Models (Internal Worker) — Zresidual_coxph_survival","title":"Z-residuals for Standard Cox Models (Internal Worker) — Zresidual_coxph_survival","text":"Internal function compute randomized Z-residuals standard Cox proportional hazards model (without frailty).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_coxph_survival.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-residuals for Standard Cox Models (Internal Worker) — Zresidual_coxph_survival","text":"","code":"Zresidual_coxph_survival(fit_coxph, newdata, n.rep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_coxph_survival.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-residuals for Standard Cox Models (Internal Worker) — Zresidual_coxph_survival","text":"fit_coxph fitted survival::coxph model object. newdata Optional data frame compute residuals. NULL, original model frame used. n.rep Integer. Number randomized residual replicates generate. Default 1. ... Additional arguments (currently unused).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_coxph_survival.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-residuals for Standard Cox Models (Internal Worker) — Zresidual_coxph_survival","text":"matrix containing Z-residuals (\\(N \\times nrep\\)) diagnostic attributes: Survival.Prob, linear.pred, covariates, censored.status, object.model.frame, type = \"survival\".","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_coxph_survival.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Z-residuals for Standard Cox Models (Internal Worker) — Zresidual_coxph_survival","text":"Z-residual observation $$ calculated $$Z_i = -\\Phi^{-1}(\\hat{S}_i(t_i, \\text{rand}))$$ \\(\\Phi^{-1}\\) inverse standard normal CDF, \\(\\hat{S}_i(t_i, \\text{rand})\\) predicted survival probability time \\(t_i\\). uncensored observations (\\(t_i\\) event time), \\(\\hat{S}_i(t_i, \\text{rand}) = \\hat{S}_i(t_i)\\). censored observations, \\(\\hat{S}_i(t_i, \\text{rand}) = \\hat{S}_i(t_i) \\cdot U\\), \\(U \\sim \\text{Unif}(0, 1)\\). predicted survival calculated $$\\hat{S}_i(t_i) = \\exp(-\\exp(\\mathbf{x}_i \\mathbf{\\hat{\\beta}}) \\hat{H}_0(t_i))$$.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_negbinomial_brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Z-residuals for hurdle negative binomial brms models — Zresidual_hurdle_negbinomial_brms","title":"Compute Z-residuals for hurdle negative binomial brms models — Zresidual_hurdle_negbinomial_brms","text":"Computes Z-residuals fitted Bayesian hurdle negative binomial models using brms model family = hurdle_negbinomial(). Z-residuals can calculated zeros, counts, overall hurdle distribution, can used model diagnostics. internal workhorse Zresidual.hurdle_negbinomial.brms() intended called directly end users.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_negbinomial_brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Z-residuals for hurdle negative binomial brms models — Zresidual_hurdle_negbinomial_brms","text":"","code":"Zresidual_hurdle_negbinomial_brms(fit, type, method = \"iscv\", n.rep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_negbinomial_brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Z-residuals for hurdle negative binomial brms models — Zresidual_hurdle_negbinomial_brms","text":"fit fitted brms model object hurdle negative binomial outcome. type Character string specifying part model calculate Z-residuals : \"zero\" hurdle/zero portion, \"count\" truncated negative binomial counts, \"hurdle\" full hurdle-negative binomial model. method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" randomized posterior predictive p-values, \"mpost\" middle-value posterior predictive p-values. Default \"iscv\". n.rep Integer; number replicated Z-residual sets generate. Default 1. ... arguments passed lower-level helper functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_negbinomial_brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Z-residuals for hurdle negative binomial brms models — Zresidual_hurdle_negbinomial_brms","text":"numeric matrix Z-residuals attributes : type: requested model component. zero_id: Indices zero outcomes. log_pmf: Log-probability mass function values. log_cdf: Log-cumulative distribution function values. covariates: Model covariates. linear.pred: Linear predictor values fitted model. S3 wrapper Zresidual.hurdle_negbinomial.brms() additionally attach class \"zresid\" returned object.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_negbinomial_brms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Z-residuals for hurdle negative binomial brms models — Zresidual_hurdle_negbinomial_brms","text":"typical implementation: Extracts observed response vector model data. Computes log-PMF log-CDF specified part model using corresponding log_pred_dist_* function, log_pred_dist_HNB log_pred_dist_TNB. Generates posterior predictive p-values according specified method. Converts p-values Z-residuals via negative quantile standard normal distribution. output matrix Z-residuals one column per replication.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_negbinomial_brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Z-residuals for hurdle negative binomial brms models — Zresidual_hurdle_negbinomial_brms","text":"","code":"if (FALSE) { # \\dontrun{   zres_counts <- Zresidual_hurdle_negbinomial_brms(     fit    = fit_hnb,     type   = \"count\",     method = \"iscv\"   ) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_poisson_brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Z-residuals for hurdle or count Poisson brms models — Zresidual_hurdle_poisson_brms","title":"Compute Z-residuals for hurdle or count Poisson brms models — Zresidual_hurdle_poisson_brms","text":"Computes Z-residuals fitted Bayesian hurdle count models Poisson distribution using brms model family = hurdle_poisson(). Z-residuals can calculated zeros, counts, overall hurdle distribution, can used model diagnostics. internal workhorse Zresidual.hurdle_poisson.brms() intended called directly end users.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_poisson_brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Z-residuals for hurdle or count Poisson brms models — Zresidual_hurdle_poisson_brms","text":"","code":"Zresidual_hurdle_poisson_brms(fit, type, method = \"iscv\", n.rep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_poisson_brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Z-residuals for hurdle or count Poisson brms models — Zresidual_hurdle_poisson_brms","text":"fit fitted brms model object hurdle count Poisson outcome. type Character string specifying part model calculate Z-residuals : \"zero\" hurdle/zero portion, \"count\" truncated Poisson counts, \"hurdle\" full hurdle-Poisson model. method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" randomized posterior predictive p-values, \"mpost\" middle-value posterior predictive p-values. Default \"iscv\". n.rep Integer; number replicated Z-residual sets generate. Default 1.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_poisson_brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Z-residuals for hurdle or count Poisson brms models — Zresidual_hurdle_poisson_brms","text":"numeric matrix Z-residuals attributes : type: requested model component. zero_id: Indices zero outcomes. log_pmf: Log-probability mass function values. log_cdf: Log-cumulative distribution function values. covariates: Model covariates. linear.pred: Linear predictor values fitted model. S3 wrapper Zresidual.hurdle_poisson.brms() additionally attach class \"zresid\" returned object.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_poisson_brms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Z-residuals for hurdle or count Poisson brms models — Zresidual_hurdle_poisson_brms","text":"typical implementation: Extracts observed response vector model data. Computes log-PMF log-CDF specified part model using corresponding log_pred_dist_* function, log_pred_dist_HP log_pred_dist_TP. Generates posterior predictive p-values according specified method. Converts p-values Z-residuals via negative quantile standard normal distribution. output matrix Z-residuals one column per replication.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_hurdle_poisson_brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Z-residuals for hurdle or count Poisson brms models — Zresidual_hurdle_poisson_brms","text":"","code":"if (FALSE) { # \\dontrun{   # Compute Z-residuals for counts   zres_counts <- Zresidual_hurdle_poisson_brms(     fit    = fit_hp,     type   = \"count\",     method = \"iscv\"   ) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_negbinomial_brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Z-residuals for negative binomial brms models — Zresidual_negbinomial_brms","title":"Compute Z-residuals for negative binomial brms models — Zresidual_negbinomial_brms","text":"Computes Z-residuals fitted Bayesian negative binomial models. Z-residuals useful model diagnostics, including checking fit overdispersion, can calculated using posterior cross-validated predictive p-values. internal workhorse Zresidual.negbinomial.brms() intended called directly end users.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_negbinomial_brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Z-residuals for negative binomial brms models — Zresidual_negbinomial_brms","text":"","code":"Zresidual_negbinomial_brms(fit, method = \"iscv\", n.rep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_negbinomial_brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Z-residuals for negative binomial brms models — Zresidual_negbinomial_brms","text":"fit fitted brms model object negative binomial outcome. method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" posterior predictive p-values, \"mpost\" marginal posterior predictive p-values. Default \"iscv\". n.rep Integer; number replicated Z-residual sets generate. Default 1. ... arguments passed lower-level helper functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_negbinomial_brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Z-residuals for negative binomial brms models — Zresidual_negbinomial_brms","text":"numeric matrix Z-residuals attributes : zero_id: Indices zero outcomes. log_pmf: Log-probability mass function values. log_cdf: Log-cumulative distribution function values. covariates: Model covariates. linear.pred: Linear predictor values fitted model. S3 wrapper Zresidual.negbinomial.brms() additionally attach class \"zresid\" returned object.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_negbinomial_brms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Z-residuals for negative binomial brms models — Zresidual_negbinomial_brms","text":"function typically performs following steps: Extracts observed response vector model data. Computes log-PMF log-CDF negative binomial model using log_pred_dist_NB. Generates randomized posterior predictive p-values according specified method. Converts p-values Z-residuals via negative quantile standard normal distribution. output matrix Z-residuals one column per replication.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_negbinomial_brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Z-residuals for negative binomial brms models — Zresidual_negbinomial_brms","text":"","code":"if (FALSE) { # \\dontrun{   # Compute Z-residuals for a negative binomial model   zres_nb <- Zresidual_negbinomial_brms(     fit    = fit_nb,     method = \"iscv\"   )    # Compute Z-residuals with 2 replicates using posterior predictive p-values   zres_nb_post <- Zresidual_negbinomial_brms(     fit    = fit_nb,     method = \"rpost\",     n.rep  = 2   ) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_poisson_brms.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Z-residuals for Poisson brms models — Zresidual_poisson_brms","title":"Compute Z-residuals for Poisson brms models — Zresidual_poisson_brms","text":"Computes Z-residuals fitted Bayesian Poisson models. Z-residuals useful model diagnostics, including checking fit overdispersion, can calculated using posterior cross-validated predictive p-values. internal workhorse Zresidual.poisson.brms() intended called directly end users.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_poisson_brms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Z-residuals for Poisson brms models — Zresidual_poisson_brms","text":"","code":"Zresidual_poisson_brms(fit, method = \"iscv\", n.rep = 1, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_poisson_brms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Z-residuals for Poisson brms models — Zresidual_poisson_brms","text":"fit fitted brms model object Poisson outcome. method Character string specifying residual calculation method: \"iscv\" importance-sampled cross-validated randomized predictive p-values, \"rpost\" posterior predictive p-values, \"mpost\" marginal posterior predictive p-values. Default \"iscv\". n.rep Integer; number replicated Z-residual sets generate. Default 1. ... arguments passed lower-level helper functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_poisson_brms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Z-residuals for Poisson brms models — Zresidual_poisson_brms","text":"numeric matrix Z-residuals attributes : zero_id: Indices zero outcomes. log_pmf: Log-probability mass function values. log_cdf: Log-cumulative distribution function values. covariates: Model covariates. linear.pred: Linear predictor values fitted model. S3 wrapper Zresidual.poisson.brms() additionally attach class \"zresid\" returned object.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_poisson_brms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Z-residuals for Poisson brms models — Zresidual_poisson_brms","text":"function typically performs following steps: Extracts observed response vector model data. Computes log-PMF log-CDF Poisson model using log_pred_dist_pois. Generates randomized posterior predictive p-values according specified method. Converts p-values Z-residuals via negative quantile standard normal distribution. output matrix Z-residuals one column per replication.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/Zresidual_poisson_brms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Z-residuals for Poisson brms models — Zresidual_poisson_brms","text":"","code":"if (FALSE) { # \\dontrun{   # Compute Z-residuals for a Poisson model   zres_pois <- Zresidual_poisson_brms(     fit    = fit_pois,     method = \"iscv\"   )    # Compute Z-residuals with 2 replicates using posterior predictive p-values   zres_pois_post <- Zresidual_poisson_brms(     fit    = fit_pois,     method = \"rpost\",     n.rep  = 2   ) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/aov.test.zresid.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to calculate ANOVA of Zresidual — aov.test.zresid","title":"A function to calculate ANOVA of Zresidual — aov.test.zresid","text":"function calculate ANOVA Zresidual","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/aov.test.zresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to calculate ANOVA of Zresidual — aov.test.zresid","text":"","code":"aov.test.zresid(Zresidual, X = c(\"lp\", \"covariate\"), k.anova = 10)"},{"path":"https://tiw150.github.io/Zresidual/reference/aov.test.zresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to calculate ANOVA of Zresidual — aov.test.zresid","text":"Zresidual Z-residual. X Linear predictor covariate k.anova Number bins applicable","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/bartlett.test.zresid.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to calculate Bartlett of Zresidual — bartlett.test.zresid","title":"A function to calculate Bartlett of Zresidual — bartlett.test.zresid","text":"function calculate Bartlett Zresidual","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/bartlett.test.zresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to calculate Bartlett of Zresidual — bartlett.test.zresid","text":"","code":"# S3 method for class 'zresid' bartlett.test(x, X = c(\"lp\", \"covariate\"), k.bl = 10, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/bartlett.test.zresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to calculate Bartlett of Zresidual — bartlett.test.zresid","text":"x Z-residual object (class 'zresid'). X Linear predictor covariate. Must (1) length-n vector, (2) 'lp'/'covariate', (3) covariate name attr(x, 'covariates'). k.bl Number bins applicable continuous covariates. Default 10. ... arguments passed methods.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/boxplot.zresid.html","id":null,"dir":"Reference","previous_headings":"","what":"Boxplot of Z-Residuals — boxplot.zresid","title":"Boxplot of Z-Residuals — boxplot.zresid","text":"Produces boxplot Z-residuals grouped binned fitted values selected covariate. diagnostic plot supports count-data models (e.g. Bayesian hurdle, zero-truncated) visualizing residual distribution, detecting outliers, evaluating normality assumptions using Shapiro-Wilk, ANOVA, Bartlett-type tests Z-residuals.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/boxplot.zresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boxplot of Z-Residuals — boxplot.zresid","text":"","code":"# S3 method for class 'zresid' boxplot(   x,   irep = 1,   x_axis_var = c(\"lp\", \"covariate\"),   num.bin = 10,   normality.test = c(\"SW\", \"AOV\", \"BL\"),   k.test = 10,   main.title = paste(\"Z-residual Boxplot -\", attr(x, \"type\")),   outlier.return = FALSE,   outlier.value = 3.5,   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/boxplot.zresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boxplot of Z-Residuals — boxplot.zresid","text":"x matrix Z-residuals one column per MCMC iteration. Must contain attributes: \"type\" Model type used generate residuals (e.g., hurdle, truncated). \"fitted.value\" Vector fitted values model. \"covariates\" Optional data frame covariates. \"zero_id\" Indices zero observations (applicable). irep Integer vector indicating columns Zresidual plot. Default 1. x_axis_var Character string specifying x-axis variable: \"fitted.value\" (default): Bin fitted values. \"covariate\": Display list covariate names. specific covariate name present attr(Zresidual, \"covariates\"). num.bin Integer. Number bins grouping fitted values selected covariate. Defaults 10. normality.test Character vector specifying normality tests report: \"SW\" - Shapiro-Wilk test Z-residuals. \"AOV\" - ANOVA-based test variance/mean structure. \"BL\" - Bartlett-type test variance homogeneity. Defaults c(\"SW\",\"AOV\",\"BL\"). k.test Integer. Number groups use ANOVA/Bartlett-type tests. Default 10. main.title Character. Main title plot. Default includes model type automatically. outlier.return Logical. TRUE, returns index Z-residual values exceeding threshold defined outlier.value. Default FALSE. outlier.value Numeric. Threshold defining outliers based absolute Z-residual magnitude. Default 3.5. ... Additional graphical parameters passed plot legend.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/boxplot.zresid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Boxplot of Z-Residuals — boxplot.zresid","text":"outlier.return = TRUE, returns list containing: outliers - vector indices |Zresidual| > outlier.value. Otherwise, function returns NULL (invisible) produces diagnostic plot.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/boxplot.zresid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Boxplot of Z-Residuals — boxplot.zresid","text":"function generates boxplots Z-residuals across binned fitted values (selected covariate), helps detect lack fit, heteroscedasticity, model misspecification. Infinite non-finite residuals automatically replaced maximal finite value (preserved sign), warning message displayed. x_axis_var=\"covariate\", users may supply covariate name available \"covariates\" attribute. covariate contains unique bins, fitted values transformed using log() stabilize binning, message provided. Normality diagnostics displayed plot legend. Internally, function calls: sw.test.zresid(), aov.test.zresid(), bartlett.test.zresid().","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/boxplot.zresid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Boxplot of Z-Residuals — boxplot.zresid","text":"","code":"if (FALSE) { # \\dontrun{ # Assuming 'zres' is a Z-residual matrix produced by a model-fitting function: boxplot.zresid(zres)  # Plot against a specific covariate boxplot.zresid(zres, x_axis_var = \"age\")  # Return outliers box.out <- boxplot.zresid(zres, outlier.return = TRUE) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/cdf.tp.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function (CDF) of Zero-Truncated Poisson Distribution — cdf.tp","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Poisson Distribution — cdf.tp","text":"Computes cumulative distribution function (CDF) zero-truncated Poisson (TP) distribution. function modifies standard Poisson CDF account truncation zero (.e., supports \\(y > 0\\)).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/cdf.tp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Poisson Distribution — cdf.tp","text":"","code":"cdf.tp(y, lambda, lower.tail = FALSE, log.p = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/cdf.tp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Poisson Distribution — cdf.tp","text":"y Numeric vector quantiles (count values) compute CDF. lambda Numeric vector scalar giving mean parameter (\\(\\lambda\\)) Poisson distribution. lower.tail Logical; TRUE (default), probabilities \\(P(Y \\le y)\\). FALSE, probabilities \\(P(Y > y)\\). log.p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/cdf.tp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Poisson Distribution — cdf.tp","text":"numeric vector length input, containing: CDF values (\\(P(Y \\le y \\mid Y > 0)\\)) lower.tail = TRUE. Upper-tail probabilities (\\(P(Y > y \\mid Y > 0)\\)) lower.tail = FALSE. Log-probabilities log.p = TRUE.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/cdf.tp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Poisson Distribution — cdf.tp","text":"function computes probabilities zero-truncated version Poisson distribution: $$P(Y \\le y \\mid Y > 0) = \\frac{P(Y \\le y) - P(Y = 0)}{1 - P(Y = 0)}.$$ Internally, uses ppois() function base R computing Poisson probabilities, performs calculations log scale improved numerical stability. lower.tail = FALSE, returns upper-tail probabilities \\(P(Y > y \\mid Y > 0)\\) instead.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/cdf.tp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Poisson Distribution — cdf.tp","text":"","code":"# Example: Compute the zero-truncated Poisson CDF for y = 1:5 lambda <- 2 cdf.tp(1:5, lambda) #> [1] 0.68696471 0.37392943 0.16523924 0.06089414 0.01915611  # Compute upper-tail probabilities cdf.tp(1:5, lambda, lower.tail = FALSE) #> [1] 0.68696471 0.37392943 0.16523924 0.06089414 0.01915611  # Compute log-CDF values cdf.tp(1:5, lambda, log.p = TRUE) #> [1] -0.3754723 -0.9836882 -1.8003609 -2.7986183 -3.9551338"},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability Mass Function of the Hurdle Negative Binomial Distribution — dhurdle.nb","title":"Probability Mass Function of the Hurdle Negative Binomial Distribution — dhurdle.nb","text":"Computes probability (log-probability) observing count \\(y\\) hurdle model Bernoulli process zeros truncated Negative Binomial distribution positive counts (\\(y > 0\\)).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability Mass Function of the Hurdle Negative Binomial Distribution — dhurdle.nb","text":"","code":"dhurdle.nb(y, mu, size, pi, log = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability Mass Function of the Hurdle Negative Binomial Distribution — dhurdle.nb","text":"y Numeric vector observed count values. mu Mean parameter (\\(\\mu\\)) Negative Binomial component. size Dispersion (shape) parameter (\\(r\\)) Negative Binomial component. pi Probability observing structural zero (hurdle component). log Logical; TRUE, probabilities \\(p\\) returned log scale.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability Mass Function of the Hurdle Negative Binomial Distribution — dhurdle.nb","text":"numeric vector : Probabilities \\(P(Y = y)\\) log = FALSE. Log-probabilities \\(\\log P(Y = y)\\) log = TRUE.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.nb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability Mass Function of the Hurdle Negative Binomial Distribution — dhurdle.nb","text":"hurdle Negative Binomial (HNB) distribution models counts \\(Y\\) : $$ P(Y = 0) = \\pi, $$ $$ P(Y = y) = (1 - \\pi) \\frac{f_{NB}(y)}{1 - f_{NB}(0)}, \\quad \\text{} y > 0, $$ \\(f_{NB}(y)\\) Negative Binomial probability mass function parameters \\(\\mu\\) \\(r\\) (dispersion). Internally, computations performed log scale numerical stability. function handles vectorized inputs returns numeric vector length y.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability Mass Function of the Hurdle Negative Binomial Distribution — dhurdle.nb","text":"","code":"# Example parameters mu <- 2 size <- 1 pi <- 0.3  # Compute hurdle NB probabilities for counts 0–5 dhurdle.nb(0:5, mu, size, pi) #> [1] 0.30000000 0.23333333 0.15555556 0.10370370 0.06913580 0.04609053  # Log-scale probabilities dhurdle.nb(0:5, mu, size, pi, log = TRUE) #> [1] -1.203973 -1.455287 -1.860752 -2.266217 -2.671683 -3.077148  # Compare structural zero vs positive counts dhurdle.nb(0, mu, size, pi)      # P(Y = 0) #> [1] 0.3 dhurdle.nb(1, mu, size, pi)      # P(Y = 1) #> [1] 0.2333333"},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.pois.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability Mass Function of the Hurdle Poisson Distribution — dhurdle.pois","title":"Probability Mass Function of the Hurdle Poisson Distribution — dhurdle.pois","text":"Computes probability density (log-density) Poisson hurdle distribution. distribution combines point mass zero truncated--zero Poisson distribution positive counts.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.pois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability Mass Function of the Hurdle Poisson Distribution — dhurdle.pois","text":"","code":"dhurdle.pois(y, lambda, pi, log = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.pois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability Mass Function of the Hurdle Poisson Distribution — dhurdle.pois","text":"y Numeric vector observed counts. lambda Numeric vector Poisson mean parameters (must positive). pi Numeric vector hurdle probabilities (probability structural zeros), value must 0 1. log Logical; TRUE, probabilities returned log scale.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.pois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability Mass Function of the Hurdle Poisson Distribution — dhurdle.pois","text":"numeric vector length y, giving density (log-density) Poisson hurdle distribution.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.pois.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability Mass Function of the Hurdle Poisson Distribution — dhurdle.pois","text":"hurdle Poisson distribution assumes: $$ P(Y = 0) = \\pi $$ \\(y > 0\\): $$ P(Y = y) = (1 - \\pi) \\frac{P_{\\text{Pois}}(Y = y)}{1 - P_{\\text{Pois}}(Y = 0)} $$ \\(P_{\\text{Pois}}(Y = y)\\) standard Poisson probability mass function. function vectorized parameters.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/dhurdle.pois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability Mass Function of the Hurdle Poisson Distribution — dhurdle.pois","text":"","code":"# Example usage: y <- 0:5 lambda <- 2 pi <- 0.3 dhurdle.pois(y, lambda, pi) #> [1] 0.30000000 0.21912470 0.21912470 0.14608313 0.07304157 0.02921663 dhurdle.pois(y, lambda, pi, log = TRUE) #> [1] -1.203973 -1.518114 -1.518114 -1.923579 -2.616727 -3.533017"},{"path":"https://tiw150.github.io/Zresidual/reference/gof.censored.zresidual.html","id":null,"dir":"Reference","previous_headings":"","what":"Goodness-of-fit test for censored Z-residuals — gof.censored.zresidual","title":"Goodness-of-fit test for censored Z-residuals — gof.censored.zresidual","text":"Perform normality goodness--fit test censored Z-residuals using gofTestCensored. typically used assess whether censored Z-residuals approximately standard normal fitted survival model.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/gof.censored.zresidual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Goodness-of-fit test for censored Z-residuals — gof.censored.zresidual","text":"","code":"gof.censored.zresidual(censored.Zresidual)"},{"path":"https://tiw150.github.io/Zresidual/reference/gof.censored.zresidual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Goodness-of-fit test for censored Z-residuals — gof.censored.zresidual","text":"censored.Zresidual Numeric vector (one-column matrix) censored Z-residuals. must carry attribute \"censored.status\" giving censoring indicator (1 = event, 0 = censored) observation.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/gof.censored.zresidual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Goodness-of-fit test for censored Z-residuals — gof.censored.zresidual","text":"single numeric value: p-value EnvStats::gofTestCensored using Shapiro–Francia test (test = \"sf\") right-censored normal distribution (distribution = \"norm\"). Larger p-values indicate strong evidence normality censored Z-residuals.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/gof.censored.zresidual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Goodness-of-fit test for censored Z-residuals — gof.censored.zresidual","text":"Infinite residual values (positive negative) truncated large finite values (+/- 1e10) test applied. censoring indicator taken \"censored.status\" attribute censored.Zresidual.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/iscv_logrpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Randomized Predictive p-values using ISCV Method — iscv_logrpp","title":"Compute Log Randomized Predictive p-values using ISCV Method — iscv_logrpp","text":"Calculates log randomized predictive p-values (log-RPPs) based Importance Sampling Cross-Validation (ISCV) method, using precomputed log cumulative distribution function (log-CDF) log probability mass function (log-PMF) values.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/iscv_logrpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Randomized Predictive p-values using ISCV Method — iscv_logrpp","text":"","code":"iscv_logrpp(log_cdf, log_pmf)"},{"path":"https://tiw150.github.io/Zresidual/reference/iscv_logrpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Randomized Predictive p-values using ISCV Method — iscv_logrpp","text":"log_cdf numeric matrix log-CDF values dimensions \\(M \\times N\\), \\(M\\) number posterior draws \\(N\\) number observations. log_pmf numeric matrix log-PMF values dimensions log_cdf.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/iscv_logrpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Randomized Predictive p-values using ISCV Method — iscv_logrpp","text":"numeric vector length \\(N\\), giving log randomized predictive p-values observation.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/iscv_logrpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Randomized Predictive p-values using ISCV Method — iscv_logrpp","text":"function implements Importance Sampling Cross-Validation (ISCV) version log randomized predictive p-value (log-RPP) computation. uses numerically stable log-sum-exp operations avoid overflow underflow summing log space. Randomized predictive p-values (\\(rpp\\)) computed using uniform random draws \\(u_i \\sim \\text{Uniform}(0,1)\\), combined model-predicted \\(\\text{CDF}\\) \\(\\text{PMF}\\) values observation posterior sample. result returned log scale numerical stability. Internally, function: Generates uniform random values \\(u_i\\) observation. Computes \\(\\log(u_i)\\) adds \\(\\log(\\text{PMF})\\). Applies numerically stable log-sum-exp operations column-wise. Values numerically equal 0 1 replaced \\(\\log(1e-5)\\) \\(\\log(9e-5)\\) respectively keep calculations stable.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/iscv_logrpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Randomized Predictive p-values using ISCV Method — iscv_logrpp","text":"","code":"NULL #> NULL"},{"path":"https://tiw150.github.io/Zresidual/reference/log_diff_exp.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to compute the logarithm of the difference between the exponentials of two log values. — log_diff_exp","title":"A function to compute the logarithm of the difference between the exponentials of two log values. — log_diff_exp","text":"function compute logarithm difference exponentials two log values.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_diff_exp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to compute the logarithm of the difference between the exponentials of two log values. — log_diff_exp","text":"","code":"log_diff_exp(la, lb)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_diff_exp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to compute the logarithm of the difference between the exponentials of two log values. — log_diff_exp","text":"la log value. lb log value.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HNB.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Predictive Distributions for a Hurdle Negative Binomial Model of a 'brms' Fit — log_pred_dist_HNB","title":"Compute Log Predictive Distributions for a Hurdle Negative Binomial Model of a 'brms' Fit — log_pred_dist_HNB","text":"function calculates log probability mass function (log-PMF) log cumulative distribution function (log-CDF) observation fitted hurdle negative binomial model (fitted using brms). function extracts posterior samples model parameters evaluates predictive distributions across posterior draws.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HNB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Predictive Distributions for a Hurdle Negative Binomial Model of a 'brms' Fit — log_pred_dist_HNB","text":"","code":"log_pred_dist_HNB(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HNB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Predictive Distributions for a Hurdle Negative Binomial Model of a 'brms' Fit — log_pred_dist_HNB","text":"fit fitted brms hurdle negative binomial model object. model must include distributional parameters mu, shape, hurdle probability zero.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HNB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Predictive Distributions for a Hurdle Negative Binomial Model of a 'brms' Fit — log_pred_dist_HNB","text":"list following components: lpmf_hat matrix log-PMF values (posterior samples × observations). lcdf_hat matrix log-CCDF values (posterior samples × observations). zero_id Indices observations zero counts. count_id Indices observations positive counts.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HNB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Predictive Distributions for a Hurdle Negative Binomial Model of a 'brms' Fit — log_pred_dist_HNB","text":"posterior draw observation, function computes: lpmf_hat: Log predictive mass function values using dhurdle.nb(). lcdf_hat: Log cumulative distribution function values using phurdle.nb() lower.tail = FALSE.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HNB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Predictive Distributions for a Hurdle Negative Binomial Model of a 'brms' Fit — log_pred_dist_HNB","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: fit <- brm(bf(y ~ x1 + x2, hu ~ x1), family = hurdle_negbinomial(), data = mydata) pred_dist <- log_pred_dist_HNB(fit) str(pred_dist) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HP.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Predictive Distributions for a Hurdle Poisson Model of a 'brms' Fit — log_pred_dist_HP","title":"Compute Log Predictive Distributions for a Hurdle Poisson Model of a 'brms' Fit — log_pred_dist_HP","text":"function calculates log predictive mass function (log-PMF) log cumulative distribution function (log-CDF) observation fitted hurdle Poisson model (fitted using brms). function extracts posterior samples model parameters evaluates predictive distributions across posterior draws.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Predictive Distributions for a Hurdle Poisson Model of a 'brms' Fit — log_pred_dist_HP","text":"","code":"log_pred_dist_HP(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Predictive Distributions for a Hurdle Poisson Model of a 'brms' Fit — log_pred_dist_HP","text":"fit fitted brms hurdle Poisson model object. model must include distributional parameters mu (mean parameter) hurdle probability zero.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Predictive Distributions for a Hurdle Poisson Model of a 'brms' Fit — log_pred_dist_HP","text":"list following components: lpmf_hat matrix log-PMF values (posterior samples × observations). lcdf_hat matrix log-CDF values (posterior samples × observations). zero_id Indices observations zero counts. count_id Indices observations positive counts.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Predictive Distributions for a Hurdle Poisson Model of a 'brms' Fit — log_pred_dist_HP","text":"posterior draw observation, function computes: lpmf_hat: Log predictive mass function values using dhurdle.pois(). lcdf_hat: Log cumulative distribution function values using phurdle.pois() lower.tail = FALSE. function also identifies indices zero positive count responses.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_HP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Predictive Distributions for a Hurdle Poisson Model of a 'brms' Fit — log_pred_dist_HP","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: fit <- brm(bf(y ~ x1 + x2, hu ~ x1), family = hurdle_poisson(), data = mydata) pred_dist <- log_pred_dist_HP(fit) str(pred_dist) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_NB.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Predictive Distributions for a Negative Binomial Model of a 'brms' Fit — log_pred_dist_NB","title":"Compute Log Predictive Distributions for a Negative Binomial Model of a 'brms' Fit — log_pred_dist_NB","text":"function calculates log predictive mass function (log-PMF) log cumulative distribution function (log-CDF) observation fitted negative binomial model (fitted using brms). function extracts posterior samples distributional parameters evaluates predictive distributions across posterior draws.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_NB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Predictive Distributions for a Negative Binomial Model of a 'brms' Fit — log_pred_dist_NB","text":"","code":"log_pred_dist_NB(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_NB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Predictive Distributions for a Negative Binomial Model of a 'brms' Fit — log_pred_dist_NB","text":"fit fitted brms negative binomial model object. model must include distributional parameters mu (mean parameter) shape (dispersion parameter).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_NB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Predictive Distributions for a Negative Binomial Model of a 'brms' Fit — log_pred_dist_NB","text":"list following components: lpmf_hat matrix log-PMF values (posterior samples × observations). lcdf_hat matrix log-CDF values (posterior samples × observations). zero_id Indices observations zero counts.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_NB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Predictive Distributions for a Negative Binomial Model of a 'brms' Fit — log_pred_dist_NB","text":"posterior draw observation, function computes: lpmf_hat: Log predictive mass function values using dnbinom(). lcdf_hat: Log cumulative distribution function values using pnbinom() lower.tail = FALSE. function also identifies indices zero-valued observations, can useful model diagnostic procedures Z-residuals posterior predictive checks.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_NB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Predictive Distributions for a Negative Binomial Model of a 'brms' Fit — log_pred_dist_NB","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: fit <- brm(bf(y ~ x1 + x2), family = negbinomial(), data = mydata) pred_dist <- log_pred_dist_NB(fit) str(pred_dist) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TNB.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Predictive Distributions for a Truncated Negative Binomial Model of a 'brms' Fit — log_pred_dist_TNB","title":"Compute Log Predictive Distributions for a Truncated Negative Binomial Model of a 'brms' Fit — log_pred_dist_TNB","text":"function calculates log predictive mass function (log-PMF) log cumulative distribution function (log-CDF) observation fitted truncated negative binomial model (fitted using brms). function extracts posterior samples model’s distributional parameters evaluates predictive distributions across posterior draws.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TNB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Predictive Distributions for a Truncated Negative Binomial Model of a 'brms' Fit — log_pred_dist_TNB","text":"","code":"log_pred_dist_TNB(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TNB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Predictive Distributions for a Truncated Negative Binomial Model of a 'brms' Fit — log_pred_dist_TNB","text":"fit fitted brms truncated negative binomial model object. model must include distributional parameters mu (mean parameter) shape (dispersion parameter).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TNB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Predictive Distributions for a Truncated Negative Binomial Model of a 'brms' Fit — log_pred_dist_TNB","text":"list following components: lpmf_hat matrix log-PMF values (posterior samples × observations). lcdf_hat matrix log-CDF values (posterior samples × observations).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TNB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Predictive Distributions for a Truncated Negative Binomial Model of a 'brms' Fit — log_pred_dist_TNB","text":"posterior draw observation, function computes: lpmf_hat: Log predictive mass function values using pdf.tnb(). lcdf_hat: Log cumulative distribution function values using p_tnb() lower.tail = FALSE.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TNB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Predictive Distributions for a Truncated Negative Binomial Model of a 'brms' Fit — log_pred_dist_TNB","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: fit <- brm(bf(y | trunc(lb = 1) ~ x1 + x2), family = negbinomial(), data = mydata) pred_dist <- log_pred_dist_TNB(fit) str(pred_dist) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TP.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Predictive Distributions for a Truncated Poisson Model of a 'brms' Fit — log_pred_dist_TP","title":"Compute Log Predictive Distributions for a Truncated Poisson Model of a 'brms' Fit — log_pred_dist_TP","text":"function calculates log predictive mass function (log-PMF) log cumulative distribution function (log-CDF) observation fitted truncated Poisson model (fitted using brms). function extracts posterior samples model’s mean parameter evaluates predictive distributions across posterior draws.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Predictive Distributions for a Truncated Poisson Model of a 'brms' Fit — log_pred_dist_TP","text":"","code":"log_pred_dist_TP(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Predictive Distributions for a Truncated Poisson Model of a 'brms' Fit — log_pred_dist_TP","text":"fit fitted brms truncated Poisson model object. model must include distributional parameter mu (mean parameter).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Predictive Distributions for a Truncated Poisson Model of a 'brms' Fit — log_pred_dist_TP","text":"list following components: lpmf_hat matrix log-PMF values (posterior samples × observations). lcdf_hat matrix log-CDF values (posterior samples × observations).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Predictive Distributions for a Truncated Poisson Model of a 'brms' Fit — log_pred_dist_TP","text":"posterior draw observation, function computes: lpmf_hat: Log predictive mass function values using pdf.tp(). lcdf_hat: Log cumulative distribution function values using cdf.tp.li() lower.tail = FALSE.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_TP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Predictive Distributions for a Truncated Poisson Model of a 'brms' Fit — log_pred_dist_TP","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: fit <- brm(bf(y | trunc(lb = 1) ~ x1 + x2), family = poisson(), data = mydata) pred_dist <- log_pred_dist_TP(fit) str(pred_dist) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_bern.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Predictive Distributions for Logistic Regression of a 'brms' Fit — log_pred_dist_bern","title":"Compute Log Predictive Distributions for Logistic Regression of a 'brms' Fit — log_pred_dist_bern","text":"Calculates log probability mass function (log-PMF) log cumulative distribution function (log-CDF) logistic model based fitted 'brms' model.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_bern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Predictive Distributions for Logistic Regression of a 'brms' Fit — log_pred_dist_bern","text":"","code":"log_pred_dist_bern(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_bern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Predictive Distributions for Logistic Regression of a 'brms' Fit — log_pred_dist_bern","text":"fit fitted model object brms.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_bern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Predictive Distributions for Logistic Regression of a 'brms' Fit — log_pred_dist_bern","text":"list containing: lpmf_hat: numeric matrix log-PMF values (posterior draws × observations). lcdf_hat: numeric matrix log-CDF values (posterior draws × observations).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_bern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Predictive Distributions for Logistic Regression of a 'brms' Fit — log_pred_dist_bern","text":"function extracts posterior predictions Bernoulli component (structural zeros) using posterior.pred() mean parameter (\"mu\"). observation: Computes log-PMF observed binary outcome. Computes log-CDF (upper-tail probability) observed outcome. produces matrices size \\(M \\times N\\), \\(M\\) number posterior draws \\(N\\) number observations.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_bern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Predictive Distributions for Logistic Regression of a 'brms' Fit — log_pred_dist_bern","text":"","code":"# Assuming 'fit' is a fitted brms logistic model # pred_dist <- log_pred_dist_bern(fit) # lpmf_hat <- pred_dist$lpmf_hat # lcdf_hat <- pred_dist$lcdf_hat"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_pois.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log Predictive Distributions for a Poisson Model of a 'brms' Fit — log_pred_dist_pois","title":"Compute Log Predictive Distributions for a Poisson Model of a 'brms' Fit — log_pred_dist_pois","text":"function calculates log predictive mass function (log-PMF) log cumulative distribution function (log-CDF) observation fitted Poisson model (fitted using brms). function extracts posterior samples model’s mean parameter evaluates predictive distributions across posterior draws.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_pois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Log Predictive Distributions for a Poisson Model of a 'brms' Fit — log_pred_dist_pois","text":"","code":"log_pred_dist_pois(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_pois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log Predictive Distributions for a Poisson Model of a 'brms' Fit — log_pred_dist_pois","text":"fit fitted brms Poisson model object. model must include distributional parameter mu (mean parameter).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_pois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log Predictive Distributions for a Poisson Model of a 'brms' Fit — log_pred_dist_pois","text":"list following components: lpmf_hat matrix log-PMF values (posterior samples × observations). lcdf_hat matrix log-CDF values (posterior samples × observations). zero_id Indices observations zero counts.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_pois.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log Predictive Distributions for a Poisson Model of a 'brms' Fit — log_pred_dist_pois","text":"posterior draw observation, function computes: lpmf_hat: Log predictive mass function values using dpois(). lcdf_hat: Log cumulative distribution function values using ppois() lower.tail = FALSE. function also identifies indices zero-valued observations.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_pois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log Predictive Distributions for a Poisson Model of a 'brms' Fit — log_pred_dist_pois","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: fit <- brm(bf(y ~ x1 + x2), family = poisson(), data = mydata) pred_dist <- log_pred_dist_pois(fit) str(pred_dist) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_zero.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to calculate log predictive distribution (pmf and cdf) of logistic component of a 'brm' fit — log_pred_dist_zero","title":"A function to calculate log predictive distribution (pmf and cdf) of logistic component of a 'brm' fit — log_pred_dist_zero","text":"function calculate log predictive distribution (pmf cdf) logistic component 'brm' fit","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_zero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to calculate log predictive distribution (pmf and cdf) of logistic component of a 'brm' fit — log_pred_dist_zero","text":"","code":"log_pred_dist_zero(fit)"},{"path":"https://tiw150.github.io/Zresidual/reference/log_pred_dist_zero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to calculate log predictive distribution (pmf and cdf) of logistic component of a 'brm' fit — log_pred_dist_zero","text":"fit brm fit.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/model.frame.coxph.html","id":null,"dir":"Reference","previous_headings":"","what":"An internal S3 method for model.matrix. — model.frame.coxph","title":"An internal S3 method for model.matrix. — model.frame.coxph","text":"internal S3 method model.matrix.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/model.frame.coxph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An internal S3 method for model.matrix. — model.frame.coxph","text":"","code":"# S3 method for class 'coxph' model.frame(formula, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/model.frame.survreg.html","id":null,"dir":"Reference","previous_headings":"","what":"An internal S3 method for model.matrix. — model.frame.survreg","title":"An internal S3 method for model.matrix. — model.frame.survreg","text":"internal S3 method model.matrix.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/model.frame.survreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An internal S3 method for model.matrix. — model.frame.survreg","text":"","code":"# S3 method for class 'survreg' model.frame(formula, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/model.matrix.coxph.html","id":null,"dir":"Reference","previous_headings":"","what":"An internal S3 method for model.matrix. — model.matrix.coxph","title":"An internal S3 method for model.matrix. — model.matrix.coxph","text":"internal S3 method model.matrix.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/model.matrix.coxph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An internal S3 method for model.matrix. — model.matrix.coxph","text":"","code":"# S3 method for class 'coxph' model.matrix(object, data = NULL, contrast.arg = object$contrasts, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/model.matrix.survreg.html","id":null,"dir":"Reference","previous_headings":"","what":"An internal S3 method for model.matrix. — model.matrix.survreg","title":"An internal S3 method for model.matrix. — model.matrix.survreg","text":"internal S3 method model.matrix.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/model.matrix.survreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An internal S3 method for model.matrix. — model.matrix.survreg","text":"","code":"# S3 method for class 'survreg' model.matrix(object, data, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/p_tnb.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function (CDF) of Zero-Truncated Negative Binomial Distribution — p_tnb","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Negative Binomial Distribution — p_tnb","text":"Computes cumulative distribution function (CDF) zero-truncated negative binomial (TNB) distribution. function adjusts standard negative binomial CDF account truncation zero (.e., supports \\(y > 0\\)).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/p_tnb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Negative Binomial Distribution — p_tnb","text":"","code":"p_tnb(y, mu, size, lower.tail = FALSE, log.p = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/p_tnb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Negative Binomial Distribution — p_tnb","text":"y Numeric vector quantiles (count values) compute CDF. mu Mean parameter (\\(\\mu\\)) negative binomial distribution. size Dispersion (shape) parameter (\\(r\\)) negative binomial distribution. lower.tail Logical; TRUE (default), probabilities \\(P(Y \\le y)\\). FALSE, probabilities \\(P(Y > y)\\). log.p Logical; TRUE, probabilities \\(p\\) given \\(\\log(p)\\).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/p_tnb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Negative Binomial Distribution — p_tnb","text":"numeric vector length input, containing: CDF values (\\(P(Y \\le y \\mid Y > 0)\\)) lower.tail = TRUE. Upper-tail probabilities (\\(P(Y > y \\mid Y > 0)\\)) lower.tail = FALSE. Log-probabilities log.p = TRUE.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/p_tnb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Negative Binomial Distribution — p_tnb","text":"function computes probabilities zero-truncated version negative binomial distribution: $$P(Y \\le y \\mid Y > 0) = \\frac{P(Y \\le y) - P(Y = 0)}{1 - P(Y = 0)}.$$ Internally, implemented using log-scale numerical stability. lower.tail = FALSE, computes upper-tail probabilities \\(P(Y > y \\mid Y > 0)\\) instead.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/p_tnb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function (CDF) of Zero-Truncated Negative Binomial Distribution — p_tnb","text":"","code":"# Example: Compute the CDF for y = 1:5 mu <- 2 size <- 1 p_tnb(1:5, mu, size) #> [1] 0.6666667 0.4444444 0.2962963 0.1975309 0.1316872  # Compute the upper-tail probabilities p_tnb(1:5, mu, size, lower.tail = FALSE) #> [1] 0.6666667 0.4444444 0.2962963 0.1975309 0.1316872  # Log probabilities p_tnb(1:5, mu, size, log.p = TRUE) #> [1] -0.4054651 -0.8109302 -1.2163953 -1.6218604 -2.0273255"},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tnb.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability Mass Function of the Zero-Truncated Negative Binomial Distribution — pdf.tnb","title":"Probability Mass Function of the Zero-Truncated Negative Binomial Distribution — pdf.tnb","text":"Computes probability mass function (PMF) log-PMF zero-truncated negative binomial (TNB) distribution. version excludes zeros rescales probabilities accordingly sum one positive counts .","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tnb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability Mass Function of the Zero-Truncated Negative Binomial Distribution — pdf.tnb","text":"","code":"pdf.tnb(y, mu, size, log.p = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tnb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability Mass Function of the Zero-Truncated Negative Binomial Distribution — pdf.tnb","text":"y Numeric vector observed count values (y > 0). mu Numeric vector mean parameters negative binomial distribution. size Numeric vector shape (dispersion) parameters. log.p Logical; TRUE, returns log probabilities instead probabilities.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tnb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability Mass Function of the Zero-Truncated Negative Binomial Distribution — pdf.tnb","text":"numeric vector probabilities (log-probabilities log.p = TRUE).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tnb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability Mass Function of the Zero-Truncated Negative Binomial Distribution — pdf.tnb","text":"zero-truncated negative binomial probability observation \\(y > 0\\) : $$ P(Y = y \\mid Y > 0) = \\frac{P(Y = y)}{1 - P(Y = 0)} $$ \\(P(Y = y)\\) \\(P(Y = 0)\\) evaluated using standard negative binomial PMF CDF, respectively. implementation uses dnbinom pnbinom computation. function automatically vectorizes inputs, ensuring output corresponds elementwise set parameters.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tnb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability Mass Function of the Zero-Truncated Negative Binomial Distribution — pdf.tnb","text":"","code":"# Example: Zero-truncated negative binomial probabilities y <- 1:5 mu <- 2 size <- 1.5 pdf.tnb(y, mu, size) #> [1] 0.33426968 0.23876406 0.15917604 0.10232745 0.06432011  # Log probabilities pdf.tnb(y, mu, size, log.p = TRUE) #> [1] -1.095807 -1.432279 -1.837745 -2.279577 -2.743883"},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tp.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability Mass Function of the Zero-Truncated Poisson Distribution — pdf.tp","title":"Probability Mass Function of the Zero-Truncated Poisson Distribution — pdf.tp","text":"Computes probability mass function (PMF) log-PMF zero-truncated Poisson (TP) distribution. version excludes zeros rescales probabilities sum one positive counts .","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability Mass Function of the Zero-Truncated Poisson Distribution — pdf.tp","text":"","code":"pdf.tp(y, lambda, log.p = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability Mass Function of the Zero-Truncated Poisson Distribution — pdf.tp","text":"y Numeric vector observed count values (y > 0). lambda Numeric vector rate parameters (mean Poisson distribution). log.p Logical; TRUE, returns log probabilities instead probabilities.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability Mass Function of the Zero-Truncated Poisson Distribution — pdf.tp","text":"numeric vector probabilities (log-probabilities log.p = TRUE).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability Mass Function of the Zero-Truncated Poisson Distribution — pdf.tp","text":"zero-truncated Poisson probability observation \\(y > 0\\) : $$ P(Y = y \\mid Y > 0) = \\frac{P(Y = y)}{1 - P(Y = 0)} $$ \\(P(Y = y)\\) \\(P(Y = 0)\\) evaluated using standard Poisson PMF CDF, respectively. function uses dpois ppois internally. function automatically vectorizes inputs probability corresponds elementwise provided parameter values.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/pdf.tp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability Mass Function of the Zero-Truncated Poisson Distribution — pdf.tp","text":"","code":"# Example: Zero-truncated Poisson probabilities y <- 1:5 lambda <- 2 pdf.tp(y, lambda) #> [1] 0.31303529 0.31303529 0.20869019 0.10434510 0.04173804  # Log probabilities pdf.tp(y, lambda, log.p = TRUE) #> [1] -1.161439 -1.161439 -1.566904 -2.260052 -3.176342"},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function of the Hurdle Negative Binomial Distribution — phurdle.nb","title":"Cumulative Distribution Function of the Hurdle Negative Binomial Distribution — phurdle.nb","text":"Computes cumulative distribution function (CDF) logarithm hurdle negative binomial (HNB) distribution. hurdle model combines point mass zero truncated negative binomial distribution positive counts.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function of the Hurdle Negative Binomial Distribution — phurdle.nb","text":"","code":"phurdle.nb(y, mu, size, pi, lower.tail = FALSE, log.p = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function of the Hurdle Negative Binomial Distribution — phurdle.nb","text":"y Numeric vector observed count values. mu Numeric vector mean parameters negative binomial distribution. size Numeric vector shape (dispersion) parameters negative binomial distribution. pi Numeric vector hurdle probabilities (probability structural zeros). lower.tail Logical; TRUE (default), probabilities \\(P(Y \\le y)\\); otherwise, \\(P(Y > y)\\). log.p Logical; TRUE, probabilities returned log scale.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function of the Hurdle Negative Binomial Distribution — phurdle.nb","text":"numeric vector cumulative probabilities (log-probabilities log.p = TRUE).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.nb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function of the Hurdle Negative Binomial Distribution — phurdle.nb","text":"hurdle negative binomial model assumes: $$ P(Y = 0) = \\pi, \\quad P(Y = y \\mid Y > 0) = (1 - \\pi) \\frac{F_{NB}(y)-F_{NB}(0)}{1 - F_{NB}(0)}, \\quad y > 0 $$ \\(F_{NB}(y)\\) CDF standard negative binomial distribution. function computes upper lower tail probabilities zeros positive counts using logarithmic form numerical stability. Internal helper functions (log_diff_exp, log_sum_exp) used handle differences sums log-scale probabilities safely.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function of the Hurdle Negative Binomial Distribution — phurdle.nb","text":"","code":"# Example: Hurdle Negative Binomial CDF y <- 0:5 mu <- 2 size <- 1.5 pi <- 0.3 phurdle.nb(y, mu, size, pi) #> [1] 0.70000000 0.46601122 0.29887638 0.18745315 0.11582394 0.07079986  # Upper tail probabilities on log scale phurdle.nb(y, mu, size, pi, lower.tail = FALSE, log.p = TRUE) #> [1] -0.3566749 -0.7635456 -1.2077252 -1.6742263 -2.1556840 -2.6478983"},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.pois.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Distribution Function of the Hurdle Poisson Distribution — phurdle.pois","title":"Cumulative Distribution Function of the Hurdle Poisson Distribution — phurdle.pois","text":"Computes cumulative distribution function (CDF) logarithm hurdle Poisson (HP) distribution. hurdle model combines point mass zero truncated poisson distribution positive counts.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.pois.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Distribution Function of the Hurdle Poisson Distribution — phurdle.pois","text":"","code":"phurdle.pois(y, lambda, pi, lower.tail = FALSE, log.p = FALSE)"},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.pois.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Distribution Function of the Hurdle Poisson Distribution — phurdle.pois","text":"y Numeric vector observed count values. lambda Numeric vector mean parameters poisson distribution. pi Numeric vector hurdle probabilities (probability structural zeros). lower.tail Logical; TRUE (default), probabilities \\(P(Y \\le y)\\); otherwise, \\(P(Y > y)\\). log.p Logical; TRUE, probabilities returned log scale.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.pois.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Distribution Function of the Hurdle Poisson Distribution — phurdle.pois","text":"numeric vector cumulative probabilities (log-probabilities log.p = TRUE).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.pois.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative Distribution Function of the Hurdle Poisson Distribution — phurdle.pois","text":"hurdle poisson model assumes: $$ P(Y = 0) = \\pi, \\quad P(Y = y \\mid Y > 0) = (1 - \\pi) \\frac{F_{Pois}(y)-F_{Pois}(0)}{1 - F_{Pois}(0)}, \\quad y > 0 $$ \\(F_{Pois}(y)\\) CDF standard possion distribution. function computes upper lower tail probabilities zeros positive counts using logarithmic form numerical stability. Internal helper functions (log_diff_exp, log_sum_exp) used handle differences sums log-scale probabilities safely.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/phurdle.pois.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Distribution Function of the Hurdle Poisson Distribution — phurdle.pois","text":"","code":"# Example: Hurdle Poisson CDF y <- 0:5 lambda <- 2 pi <- 0.3 phurdle.pois(y, lambda, pi) #> [1] 0.70000000 0.48087530 0.26175060 0.11566747 0.04262590 0.01340927  # Upper tail probabilities on log scale phurdle.pois(y, lambda, pi, lower.tail = FALSE, log.p = TRUE) #> [1] -0.3566749 -0.7321473 -1.3403631 -2.1570359 -3.1552932 -4.3118087"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.cs.residual.html","id":null,"dir":"Reference","previous_headings":"","what":"Cox–Snell residual plot for survival models — plot.cs.residual","title":"Cox–Snell residual plot for survival models — plot.cs.residual","text":"Produce Cox–Snell residual diagnostic plot survival models, based cumulative hazard Cox–Snell residuals. correctly specified model, Cox–Snell residuals follow exponential distribution mean 1, nonparametric estimate cumulative hazard lie close 45-degree line.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.cs.residual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cox–Snell residual plot for survival models — plot.cs.residual","text":"","code":"# S3 method for class 'cs.residual' plot(   x,   ylab = \"Cumulative Hazard Function\",   main.title = \"Cox-Snell Residuals Scatterplot\",   outlier.return = FALSE,   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.cs.residual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cox–Snell residual plot for survival models — plot.cs.residual","text":"x Numeric vector (one-column matrix) Cox–Snell residuals, typically returned one residual functions package residual.type = \"Cox-Snell\". must carry attribute \"censored.status\", giving event indicator (1 = event, 0 = censored). ylab Character string y-axis label. Default \"Cumulative Hazard Function\". main.title Character string main plot title. Default \"Cox-Snell Residuals Scatterplot\". outlier.return Logical; TRUE, potential outliers identified using simple cutoff |x| > 3.5. indices printed console returned invisibly. FALSE (default), outlier indices returned. Note current implementation attempts highlight outliers using additional plotting calls assumes access objects named Zresidual j calling environment; users may wish adapt part code workflows. ... Additional arguments passed plot.survfit underlying base graphics functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.cs.residual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cox–Snell residual plot for survival models — plot.cs.residual","text":"function primarily called side-effect producing plot. outlier.return = TRUE, prints indices points flagged outliers (|x| > 3.5) invisibly returns list component outliers, containing indices. Otherwise, returns NULL invisibly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.cs.residual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cox–Snell residual plot for survival models — plot.cs.residual","text":"input x typically obtained residual functions package (e.g., residual.coxph(), residual.coxph.frailty(), residual.survreg()) residual.type = \"Cox-Snell\". Non-finite Cox–Snell residuals detected truncated lie slightly beyond largest finite residual, message printed alert user may problems model fit. cumulative hazard drawn using fun = \"cumhaz\" compared visually exponential(1) reference line \\(H(t) = t\\).","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/plot.cs.residual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cox–Snell residual plot for survival models — plot.cs.residual","text":"","code":"if (FALSE) { # \\dontrun{  library(survival)   data(lung)  fit <- coxph(Surv(time, status) ~ age + sex, data = lung)  cs_resid <- residual.coxph(fit, newdata = lung,  residual.type = \"Cox-Snell\")   ## Cox–Snell residual plot  plot(cs_resid) # The user can now call plot() directly   ## Return indices of large residuals  out <- plot(cs_resid, outlier.return = TRUE)  out$outliers } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.dev.resid.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot deviance residuals for survival models — plot.dev.resid","title":"Plot deviance residuals for survival models — plot.dev.resid","text":"Produce diagnostic plots deviance residuals survival models, option plot observation index, linear predictor, selected covariate. function expects vector (one-column matrix) deviance residuals attributes attached residual computation functions package.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.dev.resid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot deviance residuals for survival models — plot.dev.resid","text":"","code":"# S3 method for class 'dev.resid' plot(   x,   ylab = \"Deviance Residual\",   x_axis_var = c(\"index\", \"lp\", \"covariate\"),   main.title = \"Deviance Residual Plot\",   outlier.return = FALSE,   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.dev.resid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot deviance residuals for survival models — plot.dev.resid","text":"x Numeric vector (one-column matrix) deviance residuals, typically returned one residual functions package residual.type = \"deviance\". must carry attributes \"censored.status\", \"linear.pred\", \"covariates\" described . ylab Character string y-axis label. Default \"Deviance Residual\". x_axis_var Character string controlling x-axis. Must one \"index\", \"lp\", \"covariate\", name covariate contained attr(x, \"covariates\"). default effectively \"lp\" x_axis_var supplied. main.title Character string main plot title. Default \"Deviance Residual Plot\". outlier.return Logical; TRUE, attempted outliers (indicated external logical vector .outlier calling environment) highlighted plot indices returned invisibly. FALSE (default), outlier indices returned. Note function compute outliers internally: assumes logical vector .outlier length x available outlier highlighting desired. ... Additional arguments passed underlying plotting functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.dev.resid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot deviance residuals for survival models — plot.dev.resid","text":"function primarily called side-effect producing plot. outlier.return = TRUE, prints indices outlying points console invisibly returns list component outliers, containing indices .outlier TRUE. Otherwise, returns NULL invisibly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.dev.resid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot deviance residuals for survival models — plot.dev.resid","text":"input x typically obtained residual.coxph(), residual.coxph.frailty(), residual.survreg() residual.type = \"deviance\". x_axis_var argument controls x-axis: \"index\": plot deviance residuals observation index. \"lp\": plot deviance residuals linear predictor (attribute \"linear.pred\"). \"covariate\": prompt user print available covariate names console. character string matching one covariate names attr(x, \"covariates\"): plot deviance residuals covariate. \"lp\" covariate cases, LOWESS smooth added plot highlight systematic patterns residuals. Non-finite deviance residuals detected truncated lie slightly beyond largest finite residual, message printed alert user may problems model fit. Censored uncensored observations distinguished color plotting symbol display modes.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/plot.dev.resid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot deviance residuals for survival models — plot.dev.resid","text":"","code":"if (FALSE) { # \\dontrun{  library(survival)   data(lung)  fit <- coxph(Surv(time, status) ~ age + sex, data = lung)  r_d <- residual.coxph(fit, newdata = lung,residual.type = \"deviance\")   ## Basic plot vs. index  plot(r_d, x_axis_var = \"index\")   ## Plot vs. linear predictor  plot(r_d, x_axis_var = \"lp\")   ## Plot vs. a specific covariate, e.g. \"age\"  plot(r_d, x_axis_var = \"age\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.martg.resid.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot martingale residuals for survival models — plot.martg.resid","title":"Plot martingale residuals for survival models — plot.martg.resid","text":"Produce diagnostic plots martingale residuals survival models, option plot observation index, linear predictor, selected covariate. function expects vector (one-column matrix) martingale residuals attributes attached residual computation functions package.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.martg.resid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot martingale residuals for survival models — plot.martg.resid","text":"","code":"# S3 method for class 'martg.resid' plot(   x,   ylab = \"Martingale Residual\",   x_axis_var = c(\"index\", \"lp\", \"covariate\"),   main.title = \"Martingale Residual Plot\",   outlier.return = FALSE,   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.martg.resid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot martingale residuals for survival models — plot.martg.resid","text":"x Numeric vector (one-column matrix) martingale residuals, typically returned one residual functions package residual.type = \"martingale\". must carry attributes \"censored.status\", \"linear.pred\", \"covariates\" described . ylab Character string y-axis label. Default \"Martingale Residual\". x_axis_var Character string controlling x-axis. Must one \"index\", \"lp\", \"covariate\", name covariate contained attr(x, \"covariates\"). default effectively \"lp\" x_axis_var supplied. main.title Character string main plot title. Default \"Martingale Residual Plot\". outlier.return Logical; TRUE, attempted outliers (indicated external logical vector .outlier calling environment) highlighted plot indices returned invisibly. FALSE (default), outlier indices returned. Note function compute outliers internally: assumes logical vector .outlier length x available outlier highlighting desired. ... Additional arguments passed underlying plotting functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.martg.resid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot martingale residuals for survival models — plot.martg.resid","text":"function primarily called side-effect producing plot. outlier.return = TRUE, prints indices outlying points console invisibly returns list component outliers, containing indices .outlier TRUE. Otherwise, returns NULL invisibly.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.martg.resid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot martingale residuals for survival models — plot.martg.resid","text":"input x typically obtained residual.coxph(), residual.coxph.frailty(), residual.survreg() residual.type = \"martingale\". x_axis_var argument controls x-axis: \"index\": plot martingale residuals observation index. \"lp\": plot martingale residuals linear predictor (attribute \"linear.pred\"). \"covariate\": prompt user print available covariate names console. character string matching one covariate names attr(x, \"covariates\"): plot martingale residuals covariate. \"lp\" covariate cases, LOWESS smooth added plot highlight systematic patterns residuals. Non-finite martingale residuals detected truncated lie slightly beyond largest finite residual, warning message printed alert user may problems model fit. Censored uncensored observations distinguished color plotting symbol display modes.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/plot.martg.resid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot martingale residuals for survival models — plot.martg.resid","text":"","code":"if (FALSE) { # \\dontrun{ library(survival)  data(lung) fit <- coxph(Surv(time, status) ~ age + sex, data = lung) r_m <- residual.coxph(fit, newdata = lung,                       residual.type = \"martingale\")  ## Basic plot vs. index plot(r_m, x_axis_var = \"index\")  ## Plot vs. linear predictor plot(r_m, x_axis_var = \"lp\")  ## Plot vs. a specific covariate, e.g. \"age\" plot(r_m, x_axis_var = \"age\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"Produces diagnostic scatterplots Z-residuals wide range model types, including hurdle models, zero models, count models, survival models. function designed compatible Z-residual matrices generated Bayesian models (e.g., brms, Stan-based models) well classical models. function supports: Plotting residuals index, covariates, linear predictors, user-specified vectors. Visual outlier detection customizable coloring, emphasis, labels. Automatic handling censored/un-censored hurdle count/zero classifications. Multiple normality tests (Shapiro-Wilk, ANOVA, Bartlett) per-iteration reporting. Extensive customization graphical parameters.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"","code":"# S3 method for class 'zresid' plot(   x,   irep = 1:ncol(x),   ylab = \"Z-Residual\",   normality.test = c(\"SW\", \"AOV\", \"BL\"),   k.test = 10,   x_axis_var = c(\"index\", \"covariate\", \"lp\"),   main.title = ifelse(is.null(attr(x, \"type\")),                       \"Z-residual Scatterplot\",                       paste(\"Z-residual Scatterplot -\", attr(x, \"type\"))),   outlier.return = TRUE,   outlier.value = 3.5,   category = NULL,   outlier.set = list(),   xlab = NULL,   my.mar = c(5, 4, 4, 6) + 0.1,   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"x numeric matrix Z-residuals (dimensions: n × m) class \"zresid\". Attributes used function include: \"type\", \"zero_id\", \"censored.status\", \"covariates\", \"linear.pred\". irep vector specifying residual column(s) (iterations) plot. Defaults columns x. ylab Label y-axis. normality.test character vector specifying normality tests applied per iteration: \"SW\", \"AOV\", \"BL\". Helper functions (e.g., sw.test.zresid) must exist accept inputs (x, x_axis_var, k.test). k.test Bin size normality tests (used grouping continuous predictors). x_axis_var Specifies x-axis values. Options include: \"index\", \"covariate\", \"lp\", covariate name present attr(x, \"covariates\"), numeric vector length n. main.title Title plot. Defaults type-based informative title. outlier.return TRUE, outliers printed console returned invisibly. outlier.value Threshold residual flagged outlier. Defaults 3.5. category Optional vector categorizing observations (length n). Used coloring shaping points scatterplots. outlier.set named list arguments passed symbols() text() marking labeling outliers. Overrides defaults. xlab Label x-axis. May include LaTeX syntax using form tex(\"...\"), interpreted via latex2exp (installed). .mar numeric vector passed par(mar=...) adjust plot margins. ... Additional graphical arguments passed plot(), legend(), symbols(), text().","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"Invisibly returns (outlier.return = TRUE) list: outliers Vector outlier indices Otherwise returns NULL. Always produces scatterplot primary output.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"function employs S3 method dispatch. input x must object class \"zresid\".","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"hurdle-models","dir":"Reference","previous_headings":"","what":"Hurdle models","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"Zeros counts colored differently (red vs blue).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"survival-models","dir":"Reference","previous_headings":"","what":"Survival models","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"Censored uncensored observations visually separated.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"outlier-detection","dir":"Reference","previous_headings":"","what":"Outlier Detection","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"Outliers defined : $$|Z| > \\mbox{outlier.value} \\hspace{1em} \\mbox{non-finite values}$$ marked, labeled, returned user outlier.return = TRUE.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/plot.zresid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Plot Z-Residuals for Bayesian and Frequentist Count / Hurdle / Zero / Survival Models — plot.zresid","text":"function modifies graphical parameters (par(mar=...)) execution resets end.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logmpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Posterior Log Middle-value Predictive p-values (Log-MPP) — post_logmpp","title":"Compute Posterior Log Middle-value Predictive p-values (Log-MPP) — post_logmpp","text":"Calculates posterior log middle-value (0.5) predictive p-values (log-MPP) set observations given log-PMF log-CDF matrices obtained posterior predictive samples.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logmpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Posterior Log Middle-value Predictive p-values (Log-MPP) — post_logmpp","text":"","code":"post_logmpp(log_cdf, log_pmf)"},{"path":"https://tiw150.github.io/Zresidual/reference/post_logmpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Posterior Log Middle-value Predictive p-values (Log-MPP) — post_logmpp","text":"log_cdf Numeric matrix log cumulative probabilities observation (posterior samples × observations). log_pmf Numeric matrix log probability mass function values observation (posterior samples × observations).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logmpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Posterior Log Middle-value Predictive p-values (Log-MPP) — post_logmpp","text":"numeric vector log posterior mid-value predictive probabilities observation.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logmpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Posterior Log Middle-value Predictive p-values (Log-MPP) — post_logmpp","text":"function computes stabilized version posterior predictive p-values: sums log-CDF log-PMF across posterior samples using log-sum-exp numerical stability. Probabilities exactly equal 0 1 replaced small bounds (\\(10^{-5}\\) \\(9 \\cdot 10^{-5}\\)) avoid numerical issues computations.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logmpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Posterior Log Middle-value Predictive p-values (Log-MPP) — post_logmpp","text":"","code":"NULL #> NULL"},{"path":"https://tiw150.github.io/Zresidual/reference/post_logrpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Posterior Log Randomized Predictive p-values (Log-RPP) — post_logrpp","title":"Compute Posterior Log Randomized Predictive p-values (Log-RPP) — post_logrpp","text":"Calculates posterior log randomized predictive p-values (log-RPP) set observations given log-PMF log-CDF matrices posterior predictive samples.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logrpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Posterior Log Randomized Predictive p-values (Log-RPP) — post_logrpp","text":"","code":"post_logrpp(log_cdf, log_pmf)"},{"path":"https://tiw150.github.io/Zresidual/reference/post_logrpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Posterior Log Randomized Predictive p-values (Log-RPP) — post_logrpp","text":"log_cdf Numeric matrix log cumulative probabilities observation (posterior samples × observations). log_pmf Numeric matrix log probability mass function values observation (posterior samples × observations).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logrpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Posterior Log Randomized Predictive p-values (Log-RPP) — post_logrpp","text":"numeric vector log randomized posterior predictive p-values observation.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logrpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Posterior Log Randomized Predictive p-values (Log-RPP) — post_logrpp","text":"function computes randomized posterior predictive p-values follows: uniform random number generated observation randomize probability zero counts. Probabilities exactly equal 0 1 replaced small bounds (\\(10^{-5}\\) \\(9 \\cdot 10^{-5}\\)) avoid numerical issues.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/post_logrpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Posterior Log Randomized Predictive p-values (Log-RPP) — post_logrpp","text":"","code":"NULL #> NULL"},{"path":"https://tiw150.github.io/Zresidual/reference/posterior.pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Posterior Predicted Parameters from a Hurdle or Count Model — posterior.pred","title":"Extract Posterior Predicted Parameters from a Hurdle or Count Model — posterior.pred","text":"Computes posterior predicted values specified distributional parameter (e.g., mean, shape, hurdle probability) fitted Bayesian count hurdle model. function supports extracting parameters positive counts observations.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/posterior.pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Posterior Predicted Parameters from a Hurdle or Count Model — posterior.pred","text":"","code":"posterior.pred(fit, dpar, count.only = TRUE)"},{"path":"https://tiw150.github.io/Zresidual/reference/posterior.pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Posterior Predicted Parameters from a Hurdle or Count Model — posterior.pred","text":"fit fitted brms model object containing data, formula, MCMC posterior draws. dpar Character string specifying distributional parameter extract: \"mu\" (mean), \"shape\" (dispersion), \"zero\" (hurdle probability). count.Logical; TRUE (default), computes predicted parameters positive counts (y > 0); otherwise, includes observations.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/posterior.pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Posterior Predicted Parameters from a Hurdle or Count Model — posterior.pred","text":"numeric matrix predicted parameter values observation (columns) posterior draw (rows).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/posterior.pred.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Posterior Predicted Parameters from a Hurdle or Count Model — posterior.pred","text":"function performs following steps: Builds model matrix chosen parameter observation subset. Extracts corresponding posterior MCMC draws fitted model. Computes linear predictor via matrix multiplication draws model matrix. Applies link function associated parameter (e.g., logit, log) obtain predicted parameter values natural scale.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/posterior.pred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Posterior Predicted Parameters from a Hurdle or Count Model — posterior.pred","text":"","code":"if (FALSE) { # \\dontrun{ # Extract posterior predicted mean (mu) for all observations mu_pred <- posterior.pred(fit, dpar = \"mu\", count.only = TRUE)  # Extract hurdle probabilities pi_pred <- posterior.pred(fit, dpar = \"zero\", count.only = FALSE) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/pvalue.min.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to calculate the min p-value — pvalue.min","title":"A function to calculate the min p-value — pvalue.min","text":"function calculate min p-value","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pvalue.min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to calculate the min p-value — pvalue.min","text":"","code":"pvalue.min(pv)"},{"path":"https://tiw150.github.io/Zresidual/reference/pvalue.min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to calculate the min p-value — pvalue.min","text":"pv Numeric vector p-values.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/pvalue.min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to calculate the min p-value — pvalue.min","text":"single numeric value: minimum adjusted p-value.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/qqnorm.zresid.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","title":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","text":"Produces normal Q-Q plot Z-residuals, optional Shapiro–Wilk normality testing, automatic handling infinite extreme values, axis breaks large residuals, visual annotation detected outliers. diagnostic designed checking normality assumption Z-residuals obtained Bayesian predictive model checks (posterior, LOOCV, ISCV, etc.).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/qqnorm.zresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","text":"","code":"# S3 method for class 'zresid' qqnorm(   y,   irep = 1,   diagnosis.test = \"SW\",   main.title = ifelse(is.null(attr(y, \"type\")), \"Normal Q-Q Plot\",     paste(\"Normal Q-Q Plot -\", attr(y, \"type\"))),   xlab = \"Theoretical Quantiles\",   ylab = \"Sample Quantiles\",   outlier.return = TRUE,   outlier.value = 3.5,   outlier.set = list(),   my.mar = c(5, 4, 4, 6) + 0.1,   legend.settings = list(),   ... )"},{"path":"https://tiw150.github.io/Zresidual/reference/qqnorm.zresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","text":"y numeric matrix Z-residuals column corresponds iteration predictive draw. function also uses attribute \"type\" (optional model name) construct default titles. irep Integer vector integers indicating column(s) Zresidual plot. Defaults 1. diagnosis.test Character string indicating normality test perform. Currently \"SW\" (Shapiro–Wilk test; using sw.test.zresid()) supported. main.title Main title plot. missing, automatically constructed using \"type\" attribute Zresidual. xlab, ylab Axis labels Q-Q plot. outlier.return Logical; TRUE, function prints returns indices detected outliers. outlier.value Numeric threshold used classify observation outlier based |Zresidual| > outlier.value. Default 3.5. outlier.set Optional named list graphical parameters passed symbols text customizing outlier annotation. .mar Numeric vector giving margin sizes, passed internally par(mar = ...). Default c(5, 4, 4, 6) + 0.1. legend.settings Optional named list parameters override default legend appearance settings. ... Additional graphical arguments passed qqnorm plot.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/qqnorm.zresid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","text":"Invisibly returns list : outliers integer vector containing indices detected outliers. outliers detected, empty integer vector returned. Q-Q plot produced side effect.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/qqnorm.zresid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","text":"function extends base R Q-Q plot better handle typical behavior Z-residuals Bayesian predictive checking: Infinite values (Inf/-Inf) replaced large finite values trigger warning. large Z-residuals (|Z| > 6) shown using axis breaks avoid plot distortion. Outliers (|Z| > outlier.value) highlighted labeled. Column-wise Shapiro–Wilk tests assess normality. Legends summarize model type, selected Q-Q lines, diagnostic results. diagnostic suitable Z-residuals randomized quantile residuals, posterior predictive Z-residuals, LOOCV/ISCV Z-residuals, residuals hurdle zero-inflated Bayesian models.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/qqnorm.zresid.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","text":"Dunn, P. K., & Smyth, G. K. (1996). Randomized quantile residuals. Journal Computational Graphical Statistics, 5(3), 236–244. Gelman, ., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, ., & Rubin, D. B. (2013). Bayesian Data Analysis. CRC Press.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/qqnorm.zresid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal Q-Q Plot for Z-Residuals with Outlier Detection and Normality Diagnostics — qqnorm.zresid","text":"","code":"library(Zresidual) set.seed(1) Z <- matrix(rnorm(200), ncol = 2) attr(Z, \"type\") <- \"Example Model\"  # Basic Q-Q plot qqnorm.zresid(Z)   # Use the second column with custom outlier threshold qqnorm.zresid(Z, irep = 2, outlier.value = 2.5)   # Modify legend settings qqnorm.zresid(Z, legend.settings = list(cex = 0.8))"},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.frailty.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for shared frailty Cox proportional hazards models — residual.coxph.frailty","title":"Residuals for shared frailty Cox proportional hazards models — residual.coxph.frailty","text":"Compute several types residuals (censored Z-residuals, Cox–Snell, martingale, deviance) shared frailty Cox proportional hazards models fitted coxph using multiplicative frailty term (e.g., frailty(group)).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.frailty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for shared frailty Cox proportional hazards models — residual.coxph.frailty","text":"","code":"residual.coxph.frailty(   fit_coxph,   traindata,   newdata,   residual.type = c(\"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\") )"},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.frailty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for shared frailty Cox proportional hazards models — residual.coxph.frailty","text":"fit_coxph fitted coxph object shared frailty Cox model, typically specified term frailty(group) model formula. object must contain cluster-level frailty estimates fit_coxph$frail. traindata data.frame used reconstruct baseline hazard frailty effects. must contain survival response, fixed-effect covariates, shared frailty grouping factor appearing fit_coxph$formula. newdata data.frame residuals computed. must contain survival response, covariates, shared frailty grouping factor used original model. factor levels grouping variable must compatible traindata. residual.type Character string specifying type residual compute. Must one \"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\". default full vector c(\"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\"), typical use single value supplied.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.frailty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for shared frailty Cox proportional hazards models — residual.coxph.frailty","text":"numeric matrix dimension \\(n \\times 1\\), \\(n\\) number observations newdata. single column named according residual.type. Several attributes attached: Survival.Prob: vector survival probabilities \\(S_{ij}(t_i)\\) observation newdata. linear.pred: vector fixed-effect linear predictors \\(\\eta_{ij}\\) (excluding frailty term). covariates: model matrix fixed-effect covariates used linear predictor. censored.status: event indicator (1 = event, 0 = censored). object.model.frame: model.frame constructed fit_coxph$formula newdata.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.frailty.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Residuals for shared frailty Cox proportional hazards models — residual.coxph.frailty","text":"function designed --sample / cross-validation setting: traindata used reconstruct baseline cumulative hazard relationship covariates shared frailty. newdata dataset residuals computed. datasets must contain survival response, fixed-effect covariates, frailty grouping factor (compatible factor levels). grouping variable extracted frailty() term fit_coxph$formula must factor traindata newdata. internal implementation treats models many groups (gpnumber > 5) groups (gpnumber <= 5) slightly differently, reflecting frailty coefficients stored fitted coxph object.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.frailty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for shared frailty Cox proportional hazards models — residual.coxph.frailty","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)    data(lung)   lung$inst <- factor(lung$inst)    ## Shared frailty Cox model   set.seed(1)   idx <- sample(seq_len(nrow(lung)), size = floor(0.7 * nrow(lung)))   train_dat <- lung[idx, ]   test_dat  <- lung[-idx, ]    fit_frail <- coxph(Surv(time, status) ~ age + sex + frailty(inst),                      data = train_dat)    ## Censored Z-residuals on the test set   r_z <- residual.coxph.frailty(fit_frail,                                 traindata = train_dat,                                 newdata   = test_dat,                                 residual.type = \"censored Z-residual\")    ## Cox–Snell residuals   r_cs <- residual.coxph.frailty(fit_frail,                                  traindata = train_dat,                                  newdata   = test_dat,                                  residual.type = \"Cox-Snell\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for Cox proportional hazards models — residual.coxph","title":"Residuals for Cox proportional hazards models — residual.coxph","text":"Compute several types residuals (censored Z-residuals, Cox–Snell, martingale, deviance) Cox proportional hazards models fitted coxph.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for Cox proportional hazards models — residual.coxph","text":"","code":"residual.coxph(   fit_coxph,   newdata,   residual.type = c(\"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\") )"},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for Cox proportional hazards models — residual.coxph","text":"fit_coxph fitted coxph model object without shared frailty term. response right-censored survival object, typically Surv(time, status) Surv(tstart, tstop, status). newdata data.frame containing variables required fit_coxph$formula, including Surv() response covariates. Residuals evaluated observations newdata. residual.type Character string specifying type residual compute. Must one \"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\". default full vector c(\"censored Z-residual\", \"Cox-Snell\",   \"martingale\", \"deviance\"), typical use single value supplied.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for Cox proportional hazards models — residual.coxph","text":"numeric matrix dimension \\(n \\times 1\\), \\(n\\) number observations newdata. single column named according residual.type. Several attributes attached: Survival.Prob: vector survival probabilities \\(S_i(t_i)\\). linear.pred: vector linear predictors \\(\\eta_i\\). covariates: model matrix covariates (columns used linear predictor). censored.status: event indicator (1 = event, 0 = censored). object.model.frame: model.frame constructed fit_coxph$formula newdata.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.coxph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for Cox proportional hazards models — residual.coxph","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)    data(lung)    ## Cox PH model   fit_cox <- coxph(Surv(time, status) ~ age + sex, data = lung)    ## Censored Z-residuals   r_z <- residual.coxph(fit_cox, newdata = lung,                         residual.type = \"censored Z-residual\")    ## Cox–Snell residuals   r_cs <- residual.coxph(fit_cox, newdata = lung,                          residual.type = \"Cox-Snell\")    ## Martingale residuals   r_m <- residual.coxph(fit_cox, newdata = lung,                         residual.type = \"martingale\")    ## Deviance residuals   r_d <- residual.coxph(fit_cox, newdata = lung,                         residual.type = \"deviance\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/residual.survreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for Accelerated failure time model models — residual.survreg","title":"Residuals for Accelerated failure time model models — residual.survreg","text":"Compute several types residuals (censored Z-residuals, Cox–Snell, martingale, deviance) accelerated failure time models fitted survreg.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.survreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for Accelerated failure time model models — residual.survreg","text":"","code":"residual.survreg(   survreg_fit,   newdata,   residual.type = c(\"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\") )"},{"path":"https://tiw150.github.io/Zresidual/reference/residual.survreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for Accelerated failure time model models — residual.survreg","text":"survreg_fit fitted survreg model object. model right-censored survival regression model (.e., Surv(time, status) response), using one supported distributions. newdata data.frame containing variables required survreg_fit$terms, including Surv() response covariates. Residuals evaluated observations newdata. residual.type Character string specifying type residual compute. Must one \"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\". default full vector c(\"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\"), practice single value supplied.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.survreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for Accelerated failure time model models — residual.survreg","text":"numeric matrix dimension \\(n \\times 1\\), \\(n\\) number observations newdata. single column named according residual.type. Several attributes attached: Survival.Prob: vector survival probabilities \\(S_i(t_i)\\). linear.pred: vector linear predictors \\(\\eta_i\\). covariates: model matrix covariates used linear predictor. censored.status: event indicator (1 = event, 0 = censored). object.model.frame: model.frame constructed survreg_fit$terms newdata.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/residual.survreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for Accelerated failure time model models — residual.survreg","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)    data(lung)    ## Weibull survival regression   fit_weib <- survreg(Surv(time, status) ~ age + sex,                       data = lung, dist = \"weibull\")    ## Censored Z-residuals   r_z <- residual.survreg(fit_weib, newdata = lung,                           residual.type = \"censored Z-residual\")    ## Cox–Snell residuals   r_cs <- residual.survreg(fit_weib, newdata = lung,                            residual.type = \"Cox-Snell\")    ## Martingale residuals   r_m <- residual.survreg(fit_weib, newdata = lung,                           residual.type = \"martingale\")    ## Deviance residuals   r_d <- residual.survreg(fit_weib, newdata = lung,                           residual.type = \"deviance\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/sanitize_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Sanitize column names (internal) — sanitize_names","title":"Sanitize column names (internal) — sanitize_names","text":"Replace problematic characters column names get something closer brms' naming scheme.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/sanitize_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sanitize column names (internal) — sanitize_names","text":"","code":"sanitize_names(x)"},{"path":"https://tiw150.github.io/Zresidual/reference/sanitize_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sanitize column names (internal) — sanitize_names","text":"x Character vector names.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/sanitize_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sanitize column names (internal) — sanitize_names","text":"Character vector sanitized names.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/sf.test.zresid.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to calculate Shapiro-Francia test of Zresidual — sf.test.zresid","title":"A function to calculate Shapiro-Francia test of Zresidual — sf.test.zresid","text":"function calculate Shapiro-Francia test Zresidual","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/sf.test.zresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to calculate Shapiro-Francia test of Zresidual — sf.test.zresid","text":"","code":"sf.test.zresid(Zresidual)"},{"path":"https://tiw150.github.io/Zresidual/reference/sf.test.zresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to calculate Shapiro-Francia test of Zresidual — sf.test.zresid","text":"Zresidual Z-residual.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/surv_residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for supported survival models — surv_residuals","title":"Residuals for supported survival models — surv_residuals","text":"High-level wrapper compute residuals supported survival models, unified interface. Depending model type presence shared frailty term, function dispatches : residual.coxph() standard Cox proportional hazards models, residual.coxph.frailty() shared frailty Cox models, residual.survreg() parametric survival models fitted survreg.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/surv_residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for supported survival models — surv_residuals","text":"","code":"surv_residuals(   fit.object,   data,   residual.type = c(\"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\") )"},{"path":"https://tiw150.github.io/Zresidual/reference/surv_residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for supported survival models — surv_residuals","text":"fit.object fitted model object. Currently, coxph survreg objects supported. Cox models may optionally include shared frailty term (e.g., frailty(group)). data data.frame containing variables needed evaluate residuals fit.object. must contain survival response covariates (, shared frailty models, grouping factor) appearing model formula. residual.type Character string specifying type residual compute. Valid values depend underlying model residual function, Cox models typically include: \"censored Z-residual\", \"Cox-Snell\", \"martingale\", \"deviance\". default full vector c(\"censored Z-residual\", \"Cox-Snell\", \"martingale\",   \"deviance\"), typically resolved via match.arg() underlying residual functions.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/surv_residuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for supported survival models — surv_residuals","text":"object containing residuals, returned corresponding lower-level function: residual.coxph() residual.coxph.frailty() Cox / shared frailty Cox models, residual.survreg() parametric survival models. basic structure (numeric vector matrix) attributes preserved underlying function, returned object assigned additional class \"zresid\" top original classes.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/surv_residuals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Residuals for supported survival models — surv_residuals","text":"function intended convenience entry point users package: automatically routes appropriate residual computation given model type adds class \"zresid\" result. extra class can used downstream plotting diagnostic functions (e.g., plot.zresid()).","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/surv_residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for supported survival models — surv_residuals","text":"","code":"if (FALSE) { # \\dontrun{   library(survival)    ## Cox PH model   fit_cox <- coxph(Surv(time, status) ~ age + sex, data = lung)   r1 <- surv_residuals(fit_cox, data = lung,                   residual.type = \"censored Z-residual\")    ## Shared frailty Cox model   lung$inst <- factor(lung$inst)   fit_frail <- coxph(Surv(time, status) ~ age + sex + frailty(inst),                      data = lung)   r2 <- surv_residuals(fit_frail, data = lung,                   residual.type = \"Cox-Snell\")    ## Parametric survival model (Weibull)   fit_weib <- survreg(Surv(time, status) ~ age + sex, data = lung,                       dist = \"weibull\")   r3 <- surv_residuals(fit_weib, data = lung,                   residual.type = \"censored Z-residual\") } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/sw.test.zresid.html","id":null,"dir":"Reference","previous_headings":"","what":"Shapiro-Wilk Normality Test for Z-Residuals — sw.test.zresid","title":"Shapiro-Wilk Normality Test for Z-Residuals — sw.test.zresid","text":"Performs Shapiro-Wilk test normality column matrix Z-residuals.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/sw.test.zresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shapiro-Wilk Normality Test for Z-Residuals — sw.test.zresid","text":"","code":"sw.test.zresid(Zresidual, ...)"},{"path":"https://tiw150.github.io/Zresidual/reference/sw.test.zresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shapiro-Wilk Normality Test for Z-Residuals — sw.test.zresid","text":"Zresidual numeric matrix Z-residuals, column represents separate set residuals (e.g., different posterior predictive draws variables). ... Additional arguments.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/sw.test.zresid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shapiro-Wilk Normality Test for Z-Residuals — sw.test.zresid","text":"numeric vector Shapiro-Wilk p-values, one column Zresidual.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/sw.test.zresid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shapiro-Wilk Normality Test for Z-Residuals — sw.test.zresid","text":"Infinite non-finite values handled replacing negative infinity -1e10 positive infinity 1e10. NaN remaining infinite values reported via messages.","code":""},{"path":[]},{"path":"https://tiw150.github.io/Zresidual/reference/sw.test.zresid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shapiro-Wilk Normality Test for Z-Residuals — sw.test.zresid","text":"","code":"if (FALSE) { # \\dontrun{ Zres <- matrix(rnorm(100), ncol=5) sw.pvals <- sw.test.zresid(Zres) } # }"},{"path":"https://tiw150.github.io/Zresidual/reference/test.nl.aov.html","id":null,"dir":"Reference","previous_headings":"","what":"ANOVA Test for Z-Residuals — test.nl.aov","title":"ANOVA Test for Z-Residuals — test.nl.aov","text":"Performs ANOVA test assess whether Z-residuals differ across levels covariate. Numeric covariates many distinct values discretized bins. Small empty bins removed testing.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.nl.aov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ANOVA Test for Z-Residuals — test.nl.aov","text":"","code":"test.nl.aov(Zresidual, fitted.value, k.anova = 10)"},{"path":"https://tiw150.github.io/Zresidual/reference/test.nl.aov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ANOVA Test for Z-Residuals — test.nl.aov","text":"Zresidual Numeric vector Z-residuals. fitted.value Numeric factor covariate test . k.anova Integer; maximum number bins discretize numeric covariate (default 10).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.nl.aov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ANOVA Test for Z-Residuals — test.nl.aov","text":"Numeric p-value ANOVA F-test effect covariate Z-residuals.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.nl.aov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ANOVA Test for Z-Residuals — test.nl.aov","text":"function handles covariates follows: fitted.value factor fewer k.anova unique values, treated categorical. Otherwise, numeric covariates binned k.anova bins using cut. Bins fewer 3 observations removed. insufficient bins remain, covariate log-transformed binned . ANOVA performed lm(Zresidual ~ binned_covariate) p-value first term returned.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.nl.aov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ANOVA Test for Z-Residuals — test.nl.aov","text":"","code":"NULL #> NULL"},{"path":"https://tiw150.github.io/Zresidual/reference/test.var.bartl.html","id":null,"dir":"Reference","previous_headings":"","what":"Bartlett Test for Homogeneity of Variances of Z-Residual — test.var.bartl","title":"Bartlett Test for Homogeneity of Variances of Z-Residual — test.var.bartl","text":"Performs Bartlett's test assess whether variance Z-residuals differs across levels covariate. Numeric covariates many distinct values binned, small empty bins removed testing.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.var.bartl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bartlett Test for Homogeneity of Variances of Z-Residual — test.var.bartl","text":"","code":"test.var.bartl(Zresidual, fitted.value, k.bl = 10)"},{"path":"https://tiw150.github.io/Zresidual/reference/test.var.bartl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bartlett Test for Homogeneity of Variances of Z-Residual — test.var.bartl","text":"Zresidual Numeric vector Z-residuals. fitted.value Numeric factor covariate test . k.bl Integer; number bins discretize numeric covariate (default 10).","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.var.bartl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bartlett Test for Homogeneity of Variances of Z-Residual — test.var.bartl","text":"Numeric p-value Bartlett's test homogeneity variances.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.var.bartl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bartlett Test for Homogeneity of Variances of Z-Residual — test.var.bartl","text":"function handles covariates follows: fitted.value factor fewer k.bl unique values, treated categorical. Otherwise, numeric covariates binned k.bl bins. Bins fewer 3 observations removed. insufficient bins remain, covariate log-transformed binned . Bartlett's test applied Z-residuals grouped factor binned covariate.","code":""},{"path":"https://tiw150.github.io/Zresidual/reference/test.var.bartl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bartlett Test for Homogeneity of Variances of Z-Residual — test.var.bartl","text":"","code":"if (FALSE) { # \\dontrun{ Zres <- rnorm(100) x <- runif(100) test.var.bartl(Zres, x, k.bl = 5) } # }"},{"path":"https://tiw150.github.io/Zresidual/news/index.html","id":"zresidual-010","dir":"Changelog","previous_headings":"","what":"Zresidual 0.1.0","title":"Zresidual 0.1.0","text":"first version submitted CRAN","code":""}]
