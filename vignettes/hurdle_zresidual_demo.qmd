---
title: "Component-wise Z-residual Diagnosis for Bayesian Hurdle Models"
date: today
format:
 
  html:
    toc: false
    number-sections: true
    format-links: false
    page-layout: full
    code-fold: true
    html-math-method: mathjax
    css: mystyles.css
    include-after-body: 
      - pagetoc.js
execute:
  echo: true
  warning: false
  message: false
  cache: true
crossref:
      eq-prefix: "Equation"
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
link-citations: true      # for HTML
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
 fig.width = 7, fig.height = 5, fig.align = "center"
)
set.seed(123)
```

## Installing Zresidual and Other packages


### Installing Z-residua from the source

```{r}
#| label: install-zresidual
#| echo: true
#| include: false
#| message: false
if (!requireNamespace("Zresidual", quietly = TRUE)) {
  if (!requireNamespace("devtools", quietly = TRUE)) {
    install.packages("devtools")
  }
  devtools::install_github("tiw150/Zresidual")
}
library(Zresidual)

```

### Intalling and Loading R Packages used in this Demo

```{r loading-packages}

# Vector of required packages
pkgs <- c(
  "brms","distributions3","foreach", "statip", "VGAM", "plotrix", "actuar",
  "stringr", "Rlab", "dplyr", "rlang", "tidyr",
  "matrixStats", "timeDate", "katex", "gt","loo"
)

# Check for missing packages and install if needed
missing_pkgs <- pkgs[!pkgs %in% installed.packages()[, "Package"]]
if (length(missing_pkgs) > 0) {
  message("Installing missing packages: ", paste(missing_pkgs, collapse = ", "))
  install.packages(missing_pkgs, dependencies = TRUE)
} else {
  message("All required packages are already installed.")
}

# Load all packages
invisible(lapply(pkgs, library, character.only = TRUE))

options(mc.cores = parallel::detectCores())
```

```{r, echo=FALSE}
# Shortcuts for abbreviations
abbr <- function(short, full) {paste0('<abbr title="', full, '">', short, '</abbr>')}
RPP <- abbr("RPP", "Randomized Predictive P-value")
PMF <- abbr("PMF", "Probability Mass Function")
HNB <- abbr("HNB", "Hurdle Negative Binomial")
HP <- abbr("HP", "Hurdle Poisson")
SW <- abbr("SW", "Shapiro-Wilk")
ANOVA <- abbr("ANOVA", "Analysis of Variance")
BL <- abbr("BL", "Bartlett's")

```

## Introduction

This vignette demonstrates how to use the `Zresidual` package to compute component-wise Z-residuals for diagnosing Bayesian hurdle models [@Mullahy1986-em], based on the output from the `brms` package in R [@Burkner2017-brms] can be calculated separately for the zero, count and hurdle components to reveal potential model misspecifications. The examples illustrate the practical use of these residuals for `r RPP` [@Feng2020] diagnostics.

## Definitions of Component-wise Z-residuals for Bayesian Hurdle Models

This section demonstrates the definiotns of component-wise posterior predictive quantities including the posterior predictive `r PMF`, survival function, and `r RPP` for Bayesian hurdle models. Hurdle models consist of two parts:
<ul>
  <li>A **logistic component** modeling the probability of structural zeros.</li>
  <li>A **count component** modeling positive counts using a zero-truncated distribution.</li>
</ul>

Let $C_i \in \{0, 1\}$, where $C_i = 1$ indicates a non-zero value, and $C_i = 0$ indicates a zero value for the $i^\th$ observations. If $C_i=1$, the corresponding count model then operates on $y_i^+ \in \{1, 2, \dots\}$, i.e., the positive counts only.

Using Bayesian estimation (e.g., via the `brms` package), we draw $T$ samples from the posterior distribution. Let  $\theta^{(t)}$ denote the $t^\th$ posterior draw, including component-specific parameters like:
<ul>
  <li>$\pi^o_i$ : the zero porbability,</li>
  <li>$\mu_i^{(t)}, \phi^{(t)}$ : parameters for the count component.</li>
</ul>

For a given observation $y_i^\text{obs}$, the component-wise posterior predictive `r PMF` and survival functions are defined below.

#### **Hurdle Model:**
\begin{equation}
p_i^{\text{post}, \pi^o_irdle}(y_i^\text{obs}) = \frac{1}{T} \sum_{t=1}^T
\begin{cases} 
{\pi^o_i}^{(t)} & \text{if } y_i^\text{obs} = 0, \\
(1 - {\pi^o_i}^{(t)}) \cdot\frac{p_i^\text{UT}(y_i^\text{obs} | \theta^{(t)})}{1 - p_i^\text{UT}(0 | \theta^{(t)})} & \text{if } y_i^\text{obs} =1, 2, \ldots,\\
0 & \text{otherwise.}
\end{cases}  
\end{equation}
\begin{equation}
S_i^{\text{post}, \pi^o_irdle}(y_i^\text{obs}) = \frac{1}{T} \sum_{t=1}^T 
\begin{cases}
1 & \text{if } y_i^\text{obs} < 0, \\
1-{\pi^o_i}^{(t)} & \text{if } 0 \le y_i^\text{obs} < 1, \\
(1 - {\pi^o_i}^{(t)}) \cdot \frac{S_i^\text{UT}(y_i^\text{obs} \mid \theta^{(t)})}{1-p_i^\text{UT}(0 \mid \theta^{(t)})} & \text{if } y_i^\text{obs} \ge 1. 
\end{cases}
\end{equation}

#### **Logistic Component:**
\begin{equation}
\label{componentwise_logistic_pmf}
p_i^{\text{post}, \text{logit}}(c_i^\text{obs}) = \frac{1}{T} \sum_{t=1}^T 
\begin{cases}
{\pi^o_i}^{(t)} & \text{if } c_i^\text{obs} = 0, \\
1 - {\pi^o_i}^{(t)} & \text{if } c_i^\text{obs} = 1,\\
0 & \text{otherwise.}
\end{cases}
\end{equation}

\begin{equation}
\label{componentwise_logistic_survival}
S_i^{\text{post}, \text{logit}}(c_i^\text{obs}) = \frac{1}{T} \sum_{t=1}^T 
\begin{cases}
1 & \text{if } c_i^\text{obs} < 0, \\
1-{\pi^o_i}^{(t)} & \text{if } 0 \le c_i^\text{obs} < 1, \\
0, & \text{if } c_i^\text{obs} \ge 1. 
\end{cases}
\end{equation}

#### **Count Compoenent:**
\begin{equation}
\label{componentwise_count_pmf}
p_i^{\text{post},\text{count}}({y_i^+}^\text{obs}) = \frac{1}{T} \sum_{t=1}^T 
\begin{cases}
    \frac{p_i^\text{UT}({y_i^+}^\text{obs} \mid \theta^{(t)})}{1 - p_i^\text{UT}(0 \mid \theta^{(t)})}, & \text{ for } {y_i^{+}}^\text{obs} = 1,2,\ldots,\\
    0 & \text{ otherwise.}
\end{cases}
\end{equation}


\begin{equation}
\label{componentwise_count_survival}
S_i^{\text{post}, \text{count}}({y_i^+}^\text{obs}) = \frac{1}{T} \sum_{t=1}^T 
\begin{cases}
    1 & \text{ if } {y_i^+}^\text{obs} < 1 \\
    \frac{S_i^\text{UT}({y_i^+}^\text{obs} \mid \theta^{(t)})}{1-p_i^\text{UT}(0 \mid \theta^{(t)})}, & \text{ if } {y_i^+}^\text{obs} \ge 1
\end{cases}
\end{equation}

where $p_i^\text{UT}(. \mid \theta^{(t)})$ and $S_i^\text{UT}(. \mid \theta^{(t)})$ denote the `r PMF` and survival function of the untruncated count distribution, given the component-specific posterior parameters $\theta^{(t)}$.

For any observed value $y_i^\text{obs}$, we define:
\begin{equation}
\label{eq:post_rpp}\text{rpp}_i(y_i^\text{obs} | \theta^{(t)}) = S_i(y_i^\text{obs} | \theta^{(t)}) + U_i \times p_i(y_i^\text{obs} | \theta^{(t)})
\end{equation}
where $U_i \sim \text{Uniform}(0,1)$. Here, $y_i^\text{obs}$ is the observed value, which can refer to either the binary response $C_i$ or the positive count ${y_i^+}^\text{obs}$, depending on the component being evaluated. Then, the Z-residual of a discrete response variable is,
\begin{equation}
\label{eq:z_residual}
z_i = -\Phi^{-1}(\text{rpp}_i(y_i^\text{obs}|\theta)) \sim N(0, 1)
\end{equation}
where \(\Phi^{-1}(.)\) is the quantile function of standard normal distribution.

## A Simulation Example

### Model fitting with `brms`

To demonstrate how `Zresidual` works with hurdle models, we first simulate data from a `r HNB` model. This simulated dataset allows us to evaluate how well the model and residual diagnostics perform when the true data-generating process is known.

```{r}
# Simulation parameters
n <- 100
beta0 <- -1   # Intercept for hurdle (zero) part
beta1 <- -1  # Coefficient for hurdle part
alpha0 <- 2  # Intercept for count part
alpha1 <- 6  # Coefficient for count part
size <- 6      # Dispersion parameter for negative binomial

x <- rnorm(n) # Predictor

# Hurdle (zero) part
logit_p <- beta0 + beta1 * x
p_zero <- exp(logit_p) / (1 + exp(logit_p))
zeros <- rbinom(n, 1, p_zero)

# Count (non-zero) part
log_mu <- alpha0 + alpha1 * x
mu <- exp(log_mu)

# Generate from zero-truncated negative binomial
prob <- size / (size + mu)
y <- (1-zeros)*distributions3::rztnbinom(n, size, prob)

# A random error variable
z <- rnorm(n, mean = 0, sd = 1)

# Final dataset
sim_data <- data.frame(y = y, x = x, z = z)
```

This dataset includes a single continuous predictor `x`, a rando error variable `z` and the outcome `y` is generated from a hurdle negative binomial process. Note that the error variable is not included in generating the `y` outcome variable. The hurdle (zero) part is modeled with a logistic function and the count part uses a zero-truncated negative binomial distribution.

Now, we use the `brms` package to fit a hurdle negative binomial model to the simulated data.

```{r model_fit}
library(brms)
load("~/Desktop/Zresidual/data/fit_hnb.Rdata")
#fit_hnb <- brm(bf(y ~ x + z, hu ~ x + z),
#               data = sim_data, 
#               family = hurdle_negbinomial())
```

```{r echo=FALSE, eval=FALSE}

```

The `hu` formula models the hurdle (zero) part, while the main formula models the count component. The `family = hurdle_negbinomial()` tells `brms` to use a hurdle model with a negative binomial distribution for the non-zero counts. We use default parameter setting on this example to fit the model.

### Computing Z-residuals

In this example, we compute Z-residuals for the `r HNB` model separately for, logistic component (zero part) and count component using `Zresidual.hurdle.negbinomial()`. Apart from component-wise Z-residuals, the `Zresidual` package support overall model Z-residual calculation. The package take `brms` fit as an input and the `type` argument (`"zero", "count" or "hurdle"`) specifies which component to use when calculating the residuals. By default, Z-residuals are computed using the Importance Sampling Cross-Validation (`iscv`) method based on randomized predictive p-values (`r RPP`). Alternatively, users can choose the standard Posterior `r RPP` method by setting `method = "post"`.

```{r eval=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(Zresidual)
zres_hnb_post_zero <- Zresidual.hurdle.negbinomial(fit_hnb, type = "zero", method = "post")
zres_hnb_post_count <- Zresidual.hurdle.negbinomial(fit_hnb, type = "count", method = "post")
zres_hnb_post_hurdle <- Zresidual.hurdle.negbinomial(fit_hnb, type = "hurdle", method = "post")
```


##### **What the function returns**

The function `Zresidual.hurdle.negbinomial()` (and other Z-residual computing functions) returns a matrix of Z-residuals, with additional attributes. The returned object is of class `zresid`, which includes metadata useful for diagnostic and plotting purposes.

**Return Value**

A numeric matrix of dimension `n × nrep`, where `n` is the number of observations in the data and `nrep` is the number of randomized replicates of Z-residuals (default is 1). Each column represents a set of Z-residuals computed from a `r RPP`, using either posterior (`post`) or importance sampling cross-validation (`iscv`) log predictive distributions.

**Matrix Attributes**

The returned matrix includes the following attached attributes:
<ul>
  <li>`type`: The component of the hurdle model the residuals correspond to. One of "zero", "count", or "hurdle".</li>
  <li>`zero_id`: Indices of observations where the response value was 0. Useful for separating diagnostics by zero and non-zero parts.</li>
  <li>`log_pmf`: A matrix of log predictive probabilities (log-`r PMF`) per observation and posterior draw.</li>
  <li>`log_cdf`: A matrix of log predictive CDF values used in computing the `r RPP`s.</li>
  <li>`covariates`: A data frame containing the covariates used in the model (excluding the response variable). This can be used for plotting or conditional diagnostics.</li>
  <li>`fitted.value`: The posterior mean predicted value for each observation depending on the type.</li>
  
### Diagnostic Tools for Z-Residuals
  
##### Visualizing Z-residuals

The `Zresidual` package includes built-in plotting functions (QQ Plot, Scatter Plot, Boxplot) to help diagnose model fit using Z-residuals. These functions are designed to work directly with objects of class `zresid` returned by functions like `Zresidual.hurdle.negbinomial()`. These plots help assess:
<ul>
  <li>Whether residuals are approximately standard normal (via QQ plots),</li>
  <li>Whether there are patterns in residuals across fitted values (which may suggest model misspecification),</li>
  <li>Whether residuals differ across covariates (optional extensions).</li>
</ul>


```{r message=FALSE, warning=FALSE, results='hide'}
par(mfrow = c(1,3))
qqnorm.zresid(zres_hnb_post_zero)
qqnorm.zresid(zres_hnb_post_count)
qqnorm.zresid(zres_hnb_post_hurdle)
```

```{r message=FALSE, warning=FALSE, results='hide'}
par(mfrow = c(1,3))
plot.zresid(zres_hnb_post_zero, X="fitted.value", outlier.return = TRUE)
plot.zresid(zres_hnb_post_count, X="fitted.value", outlier.return = TRUE, log = "x")
plot.zresid(zres_hnb_post_hurdle, X="fitted.value", outlier.return = TRUE, log = "x")
```

```{r message=FALSE, warning=FALSE, results='hide'}
par(mfrow = c(1,3))
boxplot.zresid(zres_hnb_post_zero, X="fitted.value")
boxplot.zresid(zres_hnb_post_count, X="fitted.value")
boxplot.zresid(zres_hnb_post_hurdle, X="fitted.value")
```

The diagnostic evaluations for the true model—comprising scatter plots, Q-Q plots, and boxplots of Z-residuals—demonstrate that the model adequately captures the data structure. Across the logistic, count, and hurdle components, Z-residuals are evenly scattered around zero and mostly fall within the range of -3 to 3, indicating no visible model misfit. Complementary statistical tests, including the `r SW` test for normality, `r ANOVA` for mean equality, and `r BL` test for variance homogeneity, all return p-values above the 0.05 threshold. This suggests that the residuals follow a normal distribution and exhibit equal means and variances across fitted value intervals. The Q-Q plots further support normality through close alignment with the 45-degree reference line, while the boxplots confirm consistent residual means across partitions. Collectively, these diagnostics validate that the true model satisfies key distributional assumptions and that the proposed Z-residual methods are effective in detecting model adequacy.

The plotting functions in the Zresidual package are designed to be flexible and lightweight, allowing users to quickly visualize residual patterns across different components of hurdle models. These functions support all customizable  arguments in base `R` functions such as axes, labels etc. by making them adaptable to a wide range of diagnostic workflows. The `plot.zresid()` function offers flexible diagnostic plotting for Z-residuals, supporting various x-axes such as index, fitted values, and covariates. Both `plot.zresid()` and `qqnorm.zresid()` automatically highlights outlier residuals that fall outside the typical (or user specified)range making it easier to identify problematic observations.





## Examples for Illustration and Demonstration

###  Load the real Dataset




```{r data-read}
load("~/Desktop/Zresidual/data/kidney.rda")
kidney$sex <- ifelse(kidney$sex == 1, "male", "female")
kidney$sex<-as.factor(kidney$sex)
kidney$id<-as.factor(kidney$id)

```


```{r echo = FALSE}
DT::datatable(kidney,options = list(scrollX = TRUE, paging=TRUE), caption = "Table 1: A real dataset of acute myeloid leukemia patients.")

```

### Fitting Models


```{r}
fit_kidney <-coxph(Surv(time, status) ~ age + sex + disease+frailty(id, distribution="gamma"), data= kidney)
```

### Z-residual and LOOCV Z-residual calculation


```{r, message=FALSE}
library(Zresidual)
Zresid.kidney<-Zresidual(fit.object = fit_kidney,nrep=10)
CVZresid.kidney<-CV.Zresidual(fit.object = fit_kidney,nrep=10,nfolds = nrow(kidney))
CVZresid.kidney<-CVZresid.kidney[-57,]
```

### Inspecting the Normality of Z-Residuals for Checking Overall GOF



```{r}
#| label: qqplot-zresid
#| fig-show: animate
#| animation.hook: "gifski"
#| interval: 1
#| aniopts: "controls,loop"
#| cache: true
#| fig-width: 9
#| fig-height: 4.5
#| echo: true
#| results: hide
#| fig-align: center
#| fig-cap: "Figure 1: Scatterplots and QQ plots of No-CV and LOOCV Z-residuals of the fitted shared frailty models based on the original kidney infection dataset."
par(mfrow = c(2, 2), mar = c(4, 4, 2, 2))
plot.zresid(Zresid.kidney,X="index", main.title = "Z-residual Scatterplot",
            outlier.return = TRUE)
plot.zresid(CVZresid.kidney,X="index", main.title = "LOOCV Z-residual Scatterplot",
            outlier.return = TRUE)
qqnorm.zresid(Zresid.kidney, main.title = "Z-residual QQ plot")
qqnorm.zresid(CVZresid.kidney, main.title = "LOOCV Z-residual QQ plot")
    
```

### Diagnostic Tests with Z-residuals
The Shapiro-Wilk (SW) or Shapiro-Francia (SF) normality tests applied to Z-residuals can be used to numerically test the overall GOF of the model. 

```{r }

sw.kidney<-sw.test.zresid(Zresid.kidney)
sw.kidney.cv<-sw.test.zresid(CVZresid.kidney)
sf.kidney<-sf.test.zresid(Zresid.kidney)
sf.kidney.cv<-sf.test.zresid(CVZresid.kidney)
gof_tests<-data.frame(sw.kidney,sw.kidney.cv,sf.kidney,sf.kidney.cv)
```

```{r echo = FALSE}
DT::datatable(round(gof_tests,3),options = list(scrollX = TRUE, paging=TRUE),caption = "Table 2: 1000 replicated SW and SF p-values of No-CV and LOOCV Z-residuals of the fitted shared frailty models based on the original kidney infection dataset.")
```
There exists randomness in the Z-residuals of censored observations, meaning that different sets of Z-residuals can be generated for the same dataset using distinct random numbers. Thus, to test the robustness of the previously conducted diagnosis, we replicated a large number of realizations of Z-residuals. The Figure 2 exhibits histograms of 1000 SW test p-values, each derived from a set of No-CV or LOOCV Z-residuals. More than 95% of the SW p-values for No-CV Z-residuals surpass 0.05, whereas 100% of the SW p-values for LOOCV Z-residuals fall below 0.05. This consistency across numerous replications confirms that the evaluation of the misspecification of the shared frailty model is not incidental to a specific set of LOOCV Z-residuals but a recurring conclusion supported by extensive Z-residual replications.

```{r echo=FALSE}
pmin.sw.kidney<-pvalue.min(pv=sw.kidney)
pmin.sw.kidney.cv<-pvalue.min(pv=sw.kidney.cv)
pmin.sf.kidney<-pvalue.min(pv=sf.kidney)
pmin.sf.kidney.cv<-pvalue.min(pv=sf.kidney.cv)

```

```{r fig.height = 9,fig.width=9,fig.align='center', fig.cap="Figure 2: The histograms of 1000 replicated SW p-values of No-CV and LOOCV Z-residuals"}

par(mfrow = c(2,2),mar=c(4,4,2,2))
hist(sw.kidney,main="Replicated Z-SW P-values, No CV",breaks=20,
     xlab="Z-SW P-values")
abline(v=pmin.sw.kidney,col="red")
hist(sw.kidney.cv,main="Replicated Z-SW P-values, LOOCV",breaks=20,
     xlab="Z-SW P-values")
abline(v=pmin.sw.kidney.cv,col="red")

hist(sf.kidney,main="Replicated Z-SF P-values, No CV",breaks=20,
     xlab="Z-SF P-values")
abline(v=pmin.sf.kidney,col="red")
hist(sf.kidney.cv,main="Replicated Z-SF P-values, LOOCV",breaks=20,
     xlab="Z-SF P-values")
abline(v=pmin.sf.kidney.cv,col="red")
  
```




