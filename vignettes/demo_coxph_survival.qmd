---
title: "Z-residual Diagnostic Tool for Assessing Covariate Functional Form in Shared Frailty Models"
date: today
format:
  html:
    toc: true
    number-sections: true
    format-links: false
    page-layout: full
    code-fold: true
    html-math-method: mathjax
execute:
  echo: true
  warning: false
  message: false
  cache: false
  freeze: false
crossref:
      eq-prefix: "Equation"
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
link-citations: true      # for HTML
vignette: >
  %\VignetteIndexEntry{Z-residual diagnostic for shared frailty models}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
 fig.width = 7, fig.height = 5, fig.align = "center"
)
set.seed(123)

# Global control to force regeneration of GIFs
force_rerun <- FALSE 
```

```{r}
#| label: setup-paths
#| include: false

# 1. Identify Basename and Folder Name
current_file <- knitr::current_input()
if (is.null(current_file)) current_file <- "Zresidual_vignette.qmd" 

base_name <- tools::file_path_sans_ext(current_file)
folder_name <- paste0(base_name, "_savedfiles")

# 2. Configuration
pkg_name <- "Zresidual"
is_source <- file.exists("DESCRIPTION") || file.exists("../DESCRIPTION")
root_dir  <- ifelse(file.exists("DESCRIPTION"), ".", "..")

# 3. Define Paths
if (is_source) {
  # Development: Save permanently in inst/extdata/[basename]_savedfiles
  extdata_path <- file.path(root_dir, "inst", "extdata", folder_name)
  if (!dir.exists(extdata_path)) dir.create(extdata_path, recursive = TRUE)
  is_dev <- TRUE
} else {
  # Installed: Read from system files
  extdata_path <- system.file("extdata", folder_name, package = pkg_name)
  is_dev <- FALSE
}

# Local rendering folder (current directory)
local_assets_dir <- folder_name
if (!dir.exists(local_assets_dir)) dir.create(local_assets_dir, recursive = TRUE)

# 4. Helper: Local Asset Management
get_local_asset <- function(filename, source_dir, target_dir) {
  src <- file.path(source_dir, filename)
  dest <- file.path(target_dir, filename)
  
  if (!file.exists(src)) return(NULL)
  
  if (!file.exists(dest) || file.mtime(src) > file.mtime(dest)) {
    file.copy(src, dest, overwrite = TRUE)
  }
  return(dest)
}
```

## Installing Zresidual and Required Packages

### Installing Z-residual from Source (Developer Use)

```{r}
#| label: install-locally
#| eval: false
#| include: true
# For developer use to refresh the local installation
remove.packages("Zresidual")
devtools::document()
devtools::install()
```

### Installing Z-residual from GitHub

```{r}
#| label: install-and-load-zresidual
#| eval: false
if (!requireNamespace("Zresidual", quietly = TRUE)) {
  if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")
  remotes::install_github("tiw150/Zresidual", upgrade = "never", dependencies = TRUE)
}
```

```{r}
library(Zresidual)
```

### Loading R Packages used in this Demo

```{r loading-packages}
pkgs <- c(
  "survival", "EnvStats", "foreach", "statip", "VGAM", "plotrix", "actuar",
  "stringr", "Rlab", "dplyr", "rlang", "tidyr",
  "matrixStats", "timeDate", "katex", "gt", "loo"
)

missing_pkgs <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_pkgs)) {
  message("Installing missing packages: ", paste(missing_pkgs, collapse = ", "))
  install.packages(missing_pkgs, dependencies = TRUE)
}

invisible(lapply(pkgs, function(p) {
  suppressPackageStartupMessages(library(p, character.only = TRUE))
}))

nc <- parallel::detectCores(logical = FALSE)
if (!is.na(nc) && nc > 1) options(mc.cores = nc - 1)
```

## Introduction

This vignette explains how to use the `Zresidual` package to calculate Z-residuals based on the output of the `coxph` function from the `survival` package in R. It also demonstrates how Z-residuals can be used to assess the overall goodness of fit (GOF) and identify specific model misspecifications in semi-parametric shared frailty models. For a thorough understanding of the underlying theory, please refer to: *"Z-residual diagnostics for detecting misspecification of the functional form of covariates for shared frailty models."*

## Definition of Z-residual

We use Z-residuals to diagnose shared frailty models in a Cox proportional hazards setting where the baseline function is unspecified. For a group $i$ with $n_i$ individuals, let $y_{ij}$ be a possibly right-censored observation and $\delta_{ij}$ be the indicator for being uncensored. The normalized randomized survival probabilities (RSPs) are defined as:

$$
S_{ij}^{R}(y_{ij}, \delta_{ij}, U_{ij}) =
\left\{
\begin{array}{rl}
S_{ij}(y_{ij}), & \text{if } \delta_{ij}=1, \\
U_{ij}\,S_{ij}(y_{ij}), & \text{if } \delta_{ij}=0, 
\end{array}
\right.
$$ {#eq-rsp}

where $U_{ij} \sim \text{Uniform}(0, 1)$ and $S_{ij}(\cdot)$ is the postulated survival function. RSPs are transformed into Z-residuals via the normal quantile function:

$$
r_{ij}^{Z}(y_{ij}, \delta_{ij}, U_{ij})=-\Phi^{-1} (S_{ij}^R(y_{ij}, \delta_{ij}, U_{ij}))
$$ {#eq-zresid}


Under the true model, Z-residuals are normally distributed. This transformation allows researchers to leverage traditional normal-regression diagnostic tools for censored data. Furthermore, normal transformation highlights extreme RSPs that may indicate model misspecification but could otherwise be overlooked.

## Examples for Illustration and Demonstration

### Load the real Dataset

We utilize data from 411 acute myeloid leukemia patients recorded at the M. D. Anderson Cancer Center (1980–1996). The dataset focuses on patients under 60 from 24 districts. Key variables include survival time, age, sex, white blood cell count (WBC), and the Townsend deprivation score (TPI).

```{r data-read}
data_path <- system.file("extdata", "LeukSurv.rda", package = "Zresidual")
load(data_path)

LeukSurv <- transform(LeukSurv,
  district = as.factor(district),
  sex      = as.factor(sex),
  logwbc   = log(wbc + 0.001)
)
LeukSurv <- LeukSurv[LeukSurv$age < 60, ]
```

### Fitting Models

We compare two models: the **wbc model** (using raw WBC) and the **lwbc model** (using log-transformed WBC).

```{r fit-models}
fit_LeukSurv_wbc <- coxph(Surv(time, cens) ~ age + sex + wbc + tpi +
          frailty(district, distribution="gamma"), data = LeukSurv)

fit_LeukSurv_logwbc <- coxph(Surv(time, cens) ~ age + sex + logwbc + tpi +
          frailty(district, distribution="gamma"), data = LeukSurv)
```

### Computing Z-Residuals 

Once the model is fitted, we calculate Z-residuals for both models using 1,000 repetitions to account for randomization in censored cases.

```{r zresiduals-linear, cache=FALSE}
Zresid.LeukSurv.wbc <- Zresidual(object = fit_LeukSurv_wbc, nrep = 1000)
Zresid.LeukSurv.logwbc <- Zresidual(object = fit_LeukSurv_logwbc, nrep = 1000)
```

### Inspecting the Normality of Z-Residuals for Checking Overall GOF


A QQ plot based on Z-residuals graphically assesses the model's overall GOF. Numerical checks are performed using Shapiro-Wilk (SW) or Shapiro-Francia (SF) normality tests.

```{r}
#| label: qqplot-animation
#| code-summary: "GIF Generation Code (Folded)"
#| code-fold: true
gif_qq_name <- "qqplot_anim.gif"
gif_qq_path <- file.path(extdata_path, gif_qq_name)

if (is_dev && (force_rerun || !file.exists(gif_qq_path))) {
  gifski::save_gif(
    expr = {
      for (i in 1:10) {
        par(mfrow = c(1, 2), mar = c(4, 4, 2, 2))
        qqnorm.zresid(Zresid.LeukSurv.wbc, irep = i)
        qqnorm.zresid(Zresid.LeukSurv.logwbc, irep = i)
      }
    },
    gif_file = gif_qq_path, width = 800, height = 400, res = 72, delay = 0.8
  )
}

local_qq <- get_local_asset(gif_qq_name, extdata_path, local_assets_dir)
if (!is.null(local_qq)) {
  knitr::include_graphics(local_qq)
} else {
  par(mfrow = c(1, 2))
  qqnorm.zresid(Zresid.LeukSurv.wbc, irep = 1)
  qqnorm.zresid(Zresid.LeukSurv.logwbc, irep = 1)
}
```

The QQ plots align well with the $45^\circ$ diagonal line, and numerical Z-SW tests yield large p-values, indicating adequate overall GOF for both models.

### Assessing Homogeneity of Grouped Z-Residuals

We partition Z-residuals into $k$ groups based on the linear predictor (LP) to assess whether they are homogeneously distributed. Scatterplots show that the LOWESS lines remain close to zero, and boxplots suggest equal means and variances across groups.

```{r}
#| label: fig-zresid-scatter-box
#| code-summary: "GIF Generation Code (Folded)"
#| code-fold: true
gif_lp_name <- "lp_anim.gif"
gif_lp_path <- file.path(extdata_path, gif_lp_name)

if (is_dev && (force_rerun || !file.exists(gif_lp_path))) {
  gifski::save_gif(
    expr = {
      for (i in 1:10) {
        par(mfrow = c(2, 2), mar = c(4, 4, 1.5, 2))
        plot(Zresid.LeukSurv.wbc, x_axis_var="lp", main.title = "Scatter: WBC Model", irep=i)
        plot(Zresid.LeukSurv.logwbc, x_axis_var="lp", main.title = "Scatter: log-WBC Model", irep=i)
        boxplot(Zresid.LeukSurv.wbc, x_axis_var = "lp", main.title = "Boxplot: WBC Model", irep=i)
        boxplot(Zresid.LeukSurv.logwbc, x_axis_var = "lp", main.title = "Boxplot: log-WBC Model", irep=i)
      }
    },
    gif_file = gif_lp_path, width = 900, height = 900, res = 96, delay = 1
  )
}

local_lp <- get_local_asset(gif_lp_name, extdata_path, local_assets_dir)
if (!is.null(local_lp)) knitr::include_graphics(local_lp)
```

### Identifying Misspecification of Functional Form


Inspecting Z-residuals against specific covariates reveals potential misspecification. In the **lwbc model**, scatterplots and boxplots against `logwbc` show a non-linear LOWESS trend. A very significant Z-AOV p-value for `logwbc` strongly suggests that the log transformation is inappropriate for modeling survival time in this context.

```{r}
#| label: fig-zresid-scatter-box-wbc
#| code-summary: "GIF Generation Code (Folded)"
#| code-fold: true
gif_wbc_name <- "wbc_anim.gif"
gif_wbc_path <- file.path(extdata_path, gif_wbc_name)

if (is_dev && (force_rerun || !file.exists(gif_wbc_path))) {
  gifski::save_gif(
    expr = {
      for (i in 1:10) {
        par(mfrow = c(2, 2), mar = c(4, 4, 1.5, 2))
        plot(Zresid.LeukSurv.wbc, x_axis_var = "wbc", main.title = "Scatter: WBC Model", irep=i)
        plot(Zresid.LeukSurv.logwbc, x_axis_var = "logwbc", main.title = "Scatter: log-WBC Model", irep=i)
        boxplot(Zresid.LeukSurv.wbc, x_axis_var = "wbc", main.title = "Boxplot: WBC Model", irep=i)
        boxplot(Zresid.LeukSurv.logwbc, x_axis_var = "logwbc", main.title = "Boxplot: log-WBC Model", irep=i)
      }
    },
    gif_file = gif_wbc_path, width = 900, height = 900, res = 96, delay = 1
  )
}

local_wbc <- get_local_asset(gif_wbc_name, extdata_path, local_assets_dir)
if (!is.null(local_wbc)) knitr::include_graphics(local_wbc)
```

## Statistical Test Summaries

### Quantitative Evaluation of Homogeneity

The table below show test results for the first 10 repetitions.

```{r linear_model_Zresid_tests}
sw.wbc<-sw.test.zresid(Zresid.LeukSurv.wbc); sw.lwbc<-sw.test.zresid(Zresid.LeukSurv.logwbc)
sf.wbc<-sf.test.zresid(Zresid.LeukSurv.wbc); sf.lwbc<-sf.test.zresid(Zresid.LeukSurv.logwbc)

aov.wbc.lp<-aov.test.zresid(Zresid.LeukSurv.wbc, X="lp", k.anova=10)
aov.lwbc.lp<-aov.test.zresid(Zresid.LeukSurv.logwbc, X="lp", k.anova=10)

bl.wbc.lp<-bartlett.test.zresid(Zresid.LeukSurv.wbc, X="lp", k.bl=10)
bl.lwbc.lp<-bartlett.test.zresid(Zresid.LeukSurv.logwbc, X="lp", k.bl=10)

aov.wbc<-aov.test.zresid(Zresid.LeukSurv.wbc, X="wbc", k.anova=10)
aov.lwbc<-aov.test.zresid(Zresid.LeukSurv.logwbc, X="logwbc", k.anova=10)

bl.wbc<-bartlett.test.zresid(Zresid.LeukSurv.wbc, X="wbc", k.bl=10)
bl.lwbc<-bartlett.test.zresid(Zresid.LeukSurv.logwbc, X="logwbc", k.bl=10)

homogeneity_tests <- data.frame(aov.wbc.lp, aov.lwbc.lp, bl.wbc.lp, bl.lwbc.lp, aov.wbc, aov.lwbc, bl.wbc, bl.lwbc)

homogeneity_tests %>% head(10) %>% gt() %>% tab_header(title = "Summary of Residual Homogeneity Tests") %>% fmt_number(columns = everything(), decimals = 4)
```

### Summary of Minimum P-values ($p_{min}$)

```{r pmin-table, echo=FALSE}
pmin.sw.wbc<-pvalue.min(pv=sw.wbc); pmin.sw.lwbc<-pvalue.min(pv=sw.lwbc)
pmin.sf.wbc<-pvalue.min(pv=sf.wbc); pmin.sf.lwbc<-pvalue.min(pv=sf.lwbc)
pmin.aov.lp.wbc<-pvalue.min(pv=aov.wbc.lp); pmin.aov.lp.lwbc<-pvalue.min(pv=aov.lwbc.lp)
pmin.aov.wbc<-pvalue.min(pv=aov.wbc); pmin.aov.lwbc<-pvalue.min(pv=aov.lwbc)

pmin_wide <- data.frame(
  Test = c("Shapiro-Wilk", "Shapiro-Francia", "ANOVA (lp)", "ANOVA (Variable)"),
  WBC_Val = c(pmin.sw.wbc, pmin.sf.wbc, pmin.aov.lp.wbc, pmin.aov.wbc),
  LWBC_Val = c(pmin.sw.lwbc, pmin.sf.lwbc, pmin.aov.lp.lwbc, pmin.aov.lwbc)
)

pmin_wide %>%
  gt() %>%
  tab_header(title = md("**Summary of Minimum P-values**"), subtitle = "Diagnostic test results for LeukSurv models") %>%
  cols_label(
    WBC_Val = "WBC Model",
    LWBC_Val = "Log-WBC Model"
  ) %>%
  fmt_number(columns = c(WBC_Val, LWBC_Val), decimals = 4) %>%
  tab_style(style = cell_text(color = "red", weight = "bold"), locations = cells_body(columns = WBC_Val, rows = WBC_Val < 0.05)) %>%
  tab_style(style = cell_text(color = "red", weight = "bold"), locations = cells_body(columns = LWBC_Val, rows = LWBC_Val < 0.05))
```
### Histograms of Replicated P-values

```{r}
#| label: fig-zresid-hist-pvalues
#| fig-height: 9
#| fig-width: 9
#| fig-align: center
#| fig-cap: "Histograms of 1000 replicated p-values for WBC and log-WBC models."

par(mfrow = c(4, 2), mar = c(4, 4, 2, 2))
hist(sw.wbc, main = "Z-SW: WBC Model", breaks = 20); abline(v = pmin.sw.wbc, col = "red")
hist(sw.lwbc, main = "Z-SW: log-WBC Model", breaks = 20); abline(v = pmin.sw.lwbc, col = "red")
hist(sf.wbc, main = "Z-SF: WBC Model", breaks = 20); abline(v = pmin.sf.wbc, col = "red")
hist(sf.lwbc, main = "Z-SF: log-WBC Model", breaks = 20); abline(v = pmin.sf.lwbc, col = "red")
hist(aov.wbc.lp, main = "Z-AOV (LP): WBC Model", breaks = 20); abline(v = pmin.aov.lp.wbc, col = "red")
hist(aov.lwbc.lp, main = "Z-AOV (LP): log-WBC Model", breaks = 20); abline(v = pmin.aov.lp.lwbc, col = "red")
hist(aov.wbc, main = "Z-AOV (WBC): WBC Model", breaks = 20); abline(v = pmin.aov.wbc, col = "red")
hist(aov.lwbc, main = "Z-AOV (log-WBC): log-WBC Model", breaks = 20); abline(v = pmin.aov.lwbc, col = "red")
```


## Other Residual Analysis

### Censored Z-residuals
```{r}
censored.Zresid.wbc<-surv_residuals(fit.object=fit_LeukSurv_wbc, data=LeukSurv, residual.type="censored Z-residual")
censored.Zresid.lwbc<-surv_residuals(fit.object=fit_LeukSurv_logwbc, data=LeukSurv, residual.type="censored Z-residual")

gof.censored.zresidual(censored.Zresidual=censored.Zresid.wbc)
gof.censored.zresidual(censored.Zresidual=censored.Zresid.lwbc)
```

### Cox-Snell Residuals
```{r fig.width=14, fig.height=6, out.width="100%", fig.align="center"}
ucs.wbc <- surv_residuals(fit.object = fit_LeukSurv_wbc, data= LeukSurv, residual.type = "Cox-Snell" )
ucs.lwbc <- surv_residuals(fit.object = fit_LeukSurv_logwbc, data= LeukSurv, residual.type = "Cox-Snell" )
par(mfrow = c(1, 2)); plot.cs.residual(ucs.wbc, main.title = "CS Residuals: WBC Model"); plot.cs.residual(ucs.lwbc, main.title = "CS Residuals: log-WBC Model")
```

### Martingale Residuals
```{r martingale-residuals}
martg.wbc <- surv_residuals(fit.object = fit_LeukSurv_wbc, data= LeukSurv, residual.type = "martingale")
martg.lwbc <- surv_residuals(fit.object = fit_LeukSurv_logwbc, data= LeukSurv, residual.type = "martingale")
```

```{r fig.width=14, fig.height=6, out.width="100%", fig.align="center"}
par(mfrow = c(1, 2))
plot.martg.resid(martg.wbc, x_axis_var="wbc", main.title = "Martingale Residuals: WBC Model")
plot.martg.resid(martg.lwbc, x_axis_var="logwbc", main.title = "Martingale Residuals: log-WBC Model")
```

### Deviance Residuals
```{r deviance-residuals}
dev.wbc <- surv_residuals(fit.object = fit_LeukSurv_wbc, data= LeukSurv, residual.type = "deviance")
dev.lwbc <- surv_residuals(fit.object = fit_LeukSurv_logwbc, data= LeukSurv, residual.type = "deviance")
```

```{r fig.width=14, fig.height=6, out.width="100%", fig.align="center"}
par(mfrow = c(1, 2))
plot.dev.resid(dev.wbc, x_axis_var="wbc", main.title = "Deviance Residuals: WBC Model")
plot.dev.resid(dev.lwbc, x_axis_var="logwbc", main.title = "Deviance Residuals: log-WBC Model")
```

## References
Wu, T., Li, L., & Feng, C. (2024). Z-residual diagnostic tool for assessing covariate functional form in shared frailty models. *Journal of Applied Statistics*, 52(1), 28–58. <https://doi.org/10.1080/02664763.2024.2355551>
