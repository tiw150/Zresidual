---
title: "An Animation to Understand Z-residuals"
format: 
  html:
    toc: true
    number-sections: false
    format-links: false
    page-layout: full
    code-fold: true
    html-math-method: mathjax
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Your Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r rerun-gif}
#| include: false
#| echo: false
#| eval: true
rerun <- FALSE
```


```{r setup-extdata-path}
#| include: false

# 1. Configuration
pkg_name <- "Zresidual"

# 2. Path Discovery Logic
# Check if we are in the package source (root or vignettes/ directory)
is_source <- file.exists("DESCRIPTION") || file.exists("../DESCRIPTION")
root_dir  <- ifelse(file.exists("DESCRIPTION"), ".", "..")

if (is_source) {
  # Scenario: Local Development or Local pkgdown build
  extdata_path <- file.path(root_dir, "inst", "extdata")
  if (!dir.exists(extdata_path)) dir.create(extdata_path, recursive = TRUE)
  is_dev <- TRUE
} else {
  # Scenario: CRAN or User installation
  extdata_path <- system.file("extdata", package = pkg_name)
  is_dev <- FALSE
}

# 3. Helper: Local Asset Copy
# Ensures knitr can find the file by copying it to the current directory
get_local_asset <- function(filename, source_dir) {
  src <- file.path(source_dir, filename)
  if (!file.exists(src)) return(NULL)
   
  # Copy to current directory if it's not already there
  if (!file.exists(filename) || file.mtime(src) > file.mtime(filename)) {
    file.copy(src, filename, overwrite = TRUE)
  }
  return(filename)
}

# Status for console debugging
message(sprintf("Environment: %s | Path: %s", 
                ifelse(is_dev, "Source", "Installed"), 
                extdata_path))
```

```{r gen-aniz-anims}
#| echo: false
#| message: false
#| warning: false
#| results: hide

library(dplyr)
library(patchwork)
library(cowplot)
library(grid)
library(ggplot2)
library(gifski)

# --- Configuration ---
# Define the two scenarios
scenarios <- list(
  list(
    suffix = "correct",
    mu_true = 5,
    mu_post = 5,
    title_text = "Correct Specification"
  ),
  list(
    suffix = "wrong",
    mu_true = 3,
    mu_post = 5,
    title_text = "Misspecification"
  )
)

# Shared Parameters
n_sim <- 50
size_val <- 5
col_S <- "#253494" 
col_U <- "#41b6c4" 
col_Z <- "#225ea8" 
col_curr <- "#d7191c"   
col_past <- "#fdae61"   

# --- Main Generation Loop ---
for (scen in scenarios) {
  
  anim_filename <- paste0("z_residual_anim-", scen$suffix, ".gif")
  anim_full_path <- file.path(extdata_path, anim_filename)
  
  if (is_source && (rerun || !file.exists(anim_full_path))) {
    
    save_gif({
      set.seed(2024)
      
      # 1. Setup Parameters
      mu_true <- scen$mu_true
      mu_postulated <- scen$mu_post
      nb_center <- mu_postulated
      
      # 2. Data Generation
      sim_data <- data.frame(
        id = 1:n_sim,
        y = rnbinom(n_sim, mu = mu_true, size = size_val),
        u = runif(n_sim)
      ) %>%
        mutate(
          S_y = pnbinom(y, mu = mu_postulated, size = size_val, lower.tail = FALSE),
          p_y = dnbinom(y, mu = mu_postulated, size = size_val),
          rsp = S_y + u * p_y,
          z = qnorm(1 - rsp)
        )
      
      # 3. Static Backgrounds
      x_nb <- 0:18
      df_post <- data.frame(x = x_nb, prob = dnbinom(x_nb, mu = mu_postulated, size = size_val))
      df_true <- data.frame(x = x_nb, prob = dnbinom(x_nb, mu = mu_true, size = size_val))
      
      x_norm <- seq(-6, 6, length.out = 500)
      df_norm <- data.frame(x = x_norm, dens = dnorm(x_norm))
      
      # 4. Meter Grid Helper
      # Find k such that P(Y=k) < 0.05 for the postulated model
      check_k <- 0:30
      densities <- dnbinom(check_k, mu=mu_postulated, size=size_val)
      k_limit_idx <- which(check_k > mu_postulated & densities < 0.05)[1]
      k_limit <- check_k[k_limit_idx]
      if(is.na(k_limit)) k_limit <- 12 
      
      grid_idx <- 0:k_limit
      
      # Calculate True and Postulated limits for the meters
      p_true_grid <- dnbinom(grid_idx, mu=mu_true, size=size_val)
      cum_true <- cumsum(p_true_grid)
      low_true <- c(0, head(cum_true, -1))
      
      p_post_grid <- dnbinom(grid_idx, mu=mu_postulated, size=size_val)
      cum_post <- cumsum(p_post_grid)
      low_post <- c(0, head(cum_post, -1))
      
      meter_grid <- data.frame(
        y_i = grid_idx,
        true_low = low_true, true_upp = cum_true,
        post_low = low_post, post_upp = cum_post
      )
      
      meter_grid_labels <- meter_grid %>% 
        filter((true_upp - true_low) > 0.02 | (post_upp - post_low) > 0.02)
      
      # 5. Plot Formatting
      xlim_top <- c(nb_center - 10, nb_center + 10) 
      xlim_bot <- c(-10, 10) 
      max_prob <- max(df_true$prob, df_post$prob)
      ylim_top <- c(0, max_prob * 1.1) 
      common_margin <- theme(plot.margin = unit(c(0.2, 0.5, 0.2, 0.5), "cm"))
      
      # 6. Animation Loop
      for (i in 1:n_sim) {
        
        curr <- sim_data[i, ]
        past <- sim_data[1:i, ]
        
        # --- A. Meter Plot ---
        y_meter1_base <- 1.4  
        y_meter2_base <- 0.2  
        h <- 0.6              
        
        p_meter <- ggplot() +
          # Meter 1: True
          annotate("text", x = -0.05, y = y_meter1_base + h/2, label = "True Model:", 
                   size=4, hjust=1, fontface="bold") +
          geom_rect(aes(xmin=0, xmax=1, ymin=y_meter1_base, ymax=y_meter1_base + h), 
                    fill="white", color="black", size=0.3) +
          geom_rect(data = meter_grid, aes(xmin = true_low, xmax = true_upp, 
                                           ymin = y_meter1_base, ymax = y_meter1_base + h,
                                           fill = (y_i == curr$y)), color = "black", size = 0.2) +
          scale_fill_manual(values = c("FALSE" = "white", "TRUE" = "lightgrey"), guide = "none") +
          geom_text(data = meter_grid_labels,
                    aes(x = (true_low + true_upp)/2, y = y_meter1_base + h + 0.15, label = y_i),
                    size = 3, color = "black") +
          
          # Meter 2: Postulated
          annotate("text", x = -0.05, y = y_meter2_base + h/2, label = "Postulated Model:", 
                   size=4, hjust=1, fontface="bold") +
          geom_rect(aes(xmin=0, xmax=1, ymin=y_meter2_base, ymax=y_meter2_base + h), 
                    fill="white", color="black", size=0.3) +
          geom_rect(aes(xmin = 1 - curr$S_y, xmax = 1, ymin = y_meter2_base, ymax = y_meter2_base + h), 
                    fill = col_S) + 
          geom_rect(aes(xmin = 1 - curr$rsp, xmax = 1 - curr$S_y, ymin = y_meter2_base, ymax = y_meter2_base + h), 
                    fill = col_U) + 
          geom_rect(data = meter_grid, aes(xmin = post_low, xmax = post_upp, 
                                           ymin = y_meter2_base, ymax = y_meter2_base + h),
                    fill = NA, color = "black", size = 0.2) +
          geom_text(data = meter_grid_labels,
                    aes(x = (post_low + post_upp)/2, y = y_meter2_base + h + 0.15, label = y_i),
                    size = 3, color = "black") +
          geom_text(aes(x = 1 - (curr$rsp / 2), y = y_meter2_base - 0.25, label = paste0("RSP = ", round(curr$rsp, 3))),
                    color = "black", size = 3.5) +
          
          scale_x_continuous(limits = c(-0.35, 1), expand = c(0,0)) +
          scale_y_continuous(limits = c(-0.5, 2.5), expand = c(0,0)) +
          theme_void() + theme(plot.margin = unit(c(0.5, 0.5, 0.2, 0.5), "cm"))
        
        # --- B. Top Plot (NB) ---
        shade_S <- df_post %>% filter(x > curr$y)
        x_start_val <- (curr$y + 0.5) - curr$u
        rect_U <- data.frame(xmin = x_start_val, xmax = curr$y + 0.5, 
                             ymin = 0, ymax = dnbinom(curr$y, mu = mu_postulated, size = size_val))
        
        p_nb <- ggplot() +
          geom_rect(data = shade_S, aes(xmin=x-0.5, xmax=x+0.5, ymin=0, ymax=prob, fill = "S"), alpha = 1) +
          geom_rect(data = rect_U, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill = "U"), alpha = 1) +
          geom_step(data = df_post, aes(x = x - 0.5, y = prob, linetype = "Postulated"), direction = "hv", color = "black") +
          geom_segment(aes(x = max(df_post$x) + 0.5, xend = max(df_post$x) + 0.5, y = df_post$prob[nrow(df_post)], yend = 0), linetype = "dashed") +
          geom_step(data = df_true, aes(x = x - 0.5, y = prob, linetype = "True"), direction = "hv", color = "black", size = 0.8) +
          geom_segment(aes(x = max(df_true$x) + 0.5, xend = max(df_true$x) + 0.5, y = df_true$prob[nrow(df_true)], yend = 0), linetype = "solid") +
          geom_point(aes(x = curr$y, y = 0), shape = 1, size = 3, stroke = 1.5) +
          
          scale_fill_manual(name = "Area", values = c("S" = col_S, "U" = col_U), labels = c("S" = expression(S[i](y[i])), "U" = expression(U[i] %.% p[i](y[i])))) +
          scale_linetype_manual(name = "Model", values = c("True" = "solid", "Postulated" = "dashed")) +
          
          scale_x_continuous(breaks = seq(0, 50, by = 2), expand = c(0,0)) +
          scale_y_continuous(expand = c(0,0)) + 
          coord_cartesian(xlim = xlim_top, ylim = ylim_top, clip = "off") +
          labs(title = bquote(paste("NB (True ", mu==.(mu_true), ", Post. ", mu==.(mu_postulated), "): ", y[i] == .(curr$y))), y = "Probability", x = expression(y[i])) + 
          theme_minimal() + common_margin +
          theme(legend.position = c(0.9, 0.95), legend.justification = c(0, 1),
                legend.background = element_rect(fill = "white", color = NA), legend.box = "vertical",
                legend.margin = margin(2, 2, 2, 2), legend.spacing.y = unit(0, "cm"))
        
        # --- C. Bottom Plot (Z) ---
        shade_norm <- df_norm %>% filter(x >= curr$z)
        p_z <- ggplot() +
          geom_line(data = df_norm, aes(x = x, y = dens)) +
          geom_area(data = shade_norm, aes(x = x, y = dens), fill = col_Z) +
          geom_point(data = past %>% filter(id != i), aes(x = z, y = 0), color = col_past, size = 2) +
          geom_point(aes(x = curr$z, y = 0), color = col_curr, size = 4) +
          scale_x_continuous(limits = xlim_bot, expand = c(0,0)) +
          coord_cartesian(xlim = c(-3, 3), ylim = c(0, 0.45), clip = "off") + 
          labs(title = bquote(paste("Standard Normal: ", z[i] == .(round(curr$z, 2)))), y = "Density", x = expression(z[i])) + 
          theme_minimal() + common_margin + theme(legend.position = "none")
        
        # --- D. Assembly ---
        plots_aligned <- align_plots(p_nb, p_z, align = 'v', axis = 'lr')
        print(plot_grid(p_meter, plots_aligned[[1]], plots_aligned[[2]], ncol = 1, rel_heights = c(0.5, 1.2, 1)))
      }
    }, gif_file = anim_full_path, width = 800, height = 950, res = 100, delay = 2.0)
    
    message("Generated: ", anim_full_path)
  }
}
```


## Z-residuals

The **Zresidual** package implements diagnostic residuals based on the **predictive distribution** of each observation. By utilizing the full probabilistic information of the model, the package generates residuals that are approximately normally distributed. This allows for standard diagnostic techniques similar to using Pearson residuals in OLS regression.

For a given observation $y_i$, the **Randomized Survival Probability (RSP)**—also known as the randomized probability integral transform—represents the value of the predictive survival function (upper-tail probability) at $y_i$, adjusted with a randomization term to ensure continuity for discrete outcomes. It is defined as:

$$RSP_i(y_i \mid \theta) = S_i(y_i \mid \theta) + U_i \, p_i(y_i \mid \theta)$${#eq-rsp}

where $S_i$ and $p_i$ represent the survival function and probability mass function, respectively, derived from the predictive distribution of $y_i$ given covariates $\mathbf{x}_i$ and parameters $\theta$. $U_i \sim \text{Unif}(0,1)$ is a random uniform variable used to smooth discrete outcomes. Under a correctly specified model—where the observed data $y_i$ arises from the assumed predictive distribution—the RSP follows a $\text{Unif}(0,1)$ distribution.

The **Z-residual** (or randomized quantile residual) is derived by transforming the RSP via the inverse standard normal cumulative distribution function (CDF):

$$z_i(y_i \mid \theta) = -\Phi^{-1}\left(RSP_i(y_i \mid \theta)\right)= \Psi^{-1}\left(RSP_i(y_i \mid \theta)\right)$${#eq-zs}

where $\Psi^{-1}(p) = -\Phi^{-1}(p) = \Phi^{-1}(1-p)$ represents the inverse survival function (upper-tailed quantile) of the standard normal distribution $N(0,1)$.

In words, the Z-residual is simply the $N(0,1)$ value that shares the same **upper-tail area (RSP)** as the observed $y_i$. This transformation effectively maps any predictive distribution to the standard normal scale while preserving the tail probabilities. If the model is correct, the resulting Z-residuals follow a standard normal distribution.

**Intuition:** Think of the Z-residual as the **distance to the median**, but **rescaled** to account for skewness and **smoothed** to handle discreteness. This ensures that a residual of $+2$ always implies the same degree of 'extremeness', regardless of the original distribution's shape.

## Z-residuals of a True Model

The animation in **@fig-aniz-true** demonstrates this transformation for $y_i$ using its true predictive distribution. As more points are simulated, the distribution of $z_i$ values (shown by the accumulating points) aligns with the theoretical $N(0,1)$ density curve.

```{r}
#| label: fig-aniz-correct
#| fig-cap: "Z-residuals under a correctly specified model. **Meters:** Top and bottom bars show identical probability structures. **Top Plot:** Data $y_i$ generated from the True Model ($\\mu=3$) are evaluated against the same Postulated Model ($\\mu=3$). **Bottom Plot:** Because the model is correct, the Z-residuals (red dots) follow the Standard Normal density."
#| fig-cap-location: top
#| echo: false

local_anim_corr <- get_local_asset("z_residual_anim-correct.gif", extdata_path)
if (!is.null(local_anim_corr)) {
  knitr::include_graphics(local_anim_corr)
} else {
  message("Animation file not found.")
}
```





## Z-residuals of a Wrong Model

The animation in **@fig-aniz-wrong** demonstrates the behavior of Z-residuals when the model is misspecified. Here, the data $y_i$ are simulated from a **True Model** (Negative Binomial with $\mu=3$), but the residuals are calculated based on a **Postulated Model** (Negative Binomial with $\mu=5$).

The plotting window is fixed to the **Postulated Model** (the expectation). You can see that the observed data (solid bars) fall systematically to the left of the expected distribution (dashed bars). Because the observed values are smaller than expected, the calculated $RSP$ values are consistently high (upper tail area is large), resulting in $z_i$ values that drift toward the negative side of the standard normal distribution.

```{r}
#| label: fig-aniz-wrong
#| fig-cap: "Z-residuals under a misspecified model. **Meters:** Top bar shows True generating probabilities; bottom bar shows RSP calculation. **Top Plot:** Data $y_i$ are generated from the True Model ($\\mu=3$, solid) but evaluated against the Postulated Model ($\\mu=5$, dashed). Consequently, observed counts consistently fall in the lower tail of the postulated distribution. **Bottom Plot:** This mismatch biases the cumulative probabilities downward, causing the Z-residuals (red dots) to drift systematically to the left of the Standard Normal density."
#| fig-cap-location: top
#| echo: false

local_anim_wrong <- get_local_asset("z_residual_anim-wrong.gif", extdata_path)
if (!is.null(local_anim_wrong)) {
  knitr::include_graphics(local_anim_wrong)
} else {
  message("Animation file not found.")
}
```
```

