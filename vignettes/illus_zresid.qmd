---
title: "An Animation for Understanding Z-residuals"
author: "[Longhai Li](https://longhaisk.github.io/)"
date: last-modified
format: 
  html:
    toc: true
    number-sections: false
    format-links: false
    page-layout: full
    code-fold: true
    html-math-method: mathjax
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Your Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r rerun-gif}
#| include: false
#| echo: false
#| eval: true
rerun <- FALSE
```


```{r setup-extdata-path}
#| include: false

# 1. Configuration
pkg_name <- "Zresidual"

# 2. Path Discovery Logic
# Check if we are in the package source (root or vignettes/ directory)
is_source <- file.exists("DESCRIPTION") || file.exists("../DESCRIPTION")
root_dir  <- ifelse(file.exists("DESCRIPTION"), ".", "..")

if (is_source) {
  # Scenario: Local Development or Local pkgdown build
  extdata_path <- file.path(root_dir, "inst", "extdata")
  if (!dir.exists(extdata_path)) dir.create(extdata_path, recursive = TRUE)
  is_dev <- TRUE
} else {
  # Scenario: CRAN or User installation
  extdata_path <- system.file("extdata", package = pkg_name)
  is_dev <- FALSE
}

# 3. Helper: Local Asset Copy
# Ensures knitr can find the file by copying it to the current directory
get_local_asset <- function(filename, source_dir) {
  src <- file.path(source_dir, filename)
  if (!file.exists(src)) return(NULL)
   
  # Copy to current directory if it's not already there
  if (!file.exists(filename) || file.mtime(src) > file.mtime(filename)) {
    file.copy(src, filename, overwrite = TRUE)
  }
  return(filename)
}

# Status for console debugging
message(sprintf("Environment: %s | Path: %s", 
                ifelse(is_dev, "Source", "Installed"), 
                extdata_path))
```


```{r gen-aniz-anims-av, include=FALSE}
#| echo: false
#| message: false
#| warning: false
#| results: hide

library(dplyr)
library(patchwork)
library(cowplot)
library(grid)
library(ggplot2)
library(av)

# --- Configuration ---
scenarios <- list(
  list(suffix = "correct", mu_true = 5, mu_post = 5, title_text = "Correct Specification"),
  list(suffix = "wrong", mu_true = 2, mu_post = 5, title_text = "Misspecification")
)

# Shared Parameters
n_sim <- 50
size_val <- 5
col_S <- "#253494" 
col_U <- "#41b6c4" 
col_Z <- "#225ea8" 
col_curr <- "#d7191c"   
col_past <- "#fdae61"   
col_rsp_past <- "#80cdc1" 

# --- Main Generation Loop ---
for (scen in scenarios) {
  
  anim_filename <- paste0("z_residual_anim-", scen$suffix, ".mp4")
  anim_full_path <- file.path(extdata_path, anim_filename)
  
  if (is_source && (rerun || !file.exists(anim_full_path))) {
    
    av::av_capture_graphics({
      
      set.seed(2024)
      
      # 1. Setup Parameters
      mu_true <- scen$mu_true
      mu_postulated <- scen$mu_post
      nb_center <- mu_postulated
      
      # 2. Data Generation
      sim_data <- data.frame(
        id = 1:n_sim,
        y = rnbinom(n_sim, mu = mu_true, size = size_val),
        u = runif(n_sim)
      ) %>%
        mutate(
          S_y = pnbinom(y, mu = mu_postulated, size = size_val, lower.tail = FALSE),
          p_y = dnbinom(y, mu = mu_postulated, size = size_val),
          rsp = S_y + u * p_y,
          z = qnorm(1 - rsp)
        )
      
      # 3. Static Backgrounds
      x_nb <- 0:18
      df_post <- data.frame(x = x_nb, prob = dnbinom(x_nb, mu = mu_postulated, size = size_val))
      df_true <- data.frame(x = x_nb, prob = dnbinom(x_nb, mu = mu_true, size = size_val))
      x_norm <- seq(-6, 6, length.out = 500)
      df_norm <- data.frame(x = x_norm, dens = dnorm(x_norm))
      
      # 4. Meter Grid Helper
      check_k <- 0:30
      densities <- dnbinom(check_k, mu=mu_postulated, size=size_val)
      k_limit_idx <- which(check_k > mu_postulated & densities < 0.05)[1]
      k_limit <- check_k[k_limit_idx]
      if(is.na(k_limit)) k_limit <- 12 
      grid_idx <- 0:k_limit
      
      p_true_grid <- dnbinom(grid_idx, mu=mu_true, size=size_val)
      cum_true <- cumsum(p_true_grid)
      low_true <- c(0, head(cum_true, -1))
      
      p_post_grid <- dnbinom(grid_idx, mu=mu_postulated, size=size_val)
      cum_post <- cumsum(p_post_grid)
      low_post <- c(0, head(cum_post, -1))
      
      meter_grid <- data.frame(
        y_i = grid_idx,
        true_low = low_true, true_upp = cum_true,
        post_low = low_post, post_upp = cum_post
      )
      
      meter_grid_labels <- meter_grid %>% 
        filter((true_upp - true_low) > 0.02 | (post_upp - post_low) > 0.02)
      
      # 5. Plot Formatting
      xlim_top <- c(nb_center - 10, nb_center + 10) 
      xlim_bot <- c(-10, 10) 
      max_prob <- max(df_true$prob, df_post$prob)
      ylim_top <- c(0, max_prob * 1.1) 
      common_margin <- theme(plot.margin = unit(c(0.2, 0.5, 0.2, 0.5), "cm"))
      
      # 6. Animation Loop
      for (i in 1:n_sim) {
        
        curr <- sim_data[i, ]
        past <- sim_data[1:i, ]
        
        # --- A. Meter Plot ---
        y_meter1_base <- 1.4  
        y_meter2_base <- 0.2  
        h <- 0.6              
        
        p_meter <- ggplot() +
          # Meter 1: True
          annotate("text", x = -0.05, y = y_meter1_base + h/2, label = "True Model:", 
                   size=4, hjust=1, fontface="bold") +
          geom_rect(aes(xmin=0, xmax=1, ymin=y_meter1_base, ymax=y_meter1_base + h), 
                    fill="white", color="black", size=0.3) +
          geom_rect(data = meter_grid, aes(xmin = true_low, xmax = true_upp, 
                                           ymin = y_meter1_base, ymax = y_meter1_base + h,
                                           fill = (y_i == curr$y)), color = "black", size = 0.2) +
          scale_fill_manual(values = c("FALSE" = "white", "TRUE" = "lightgrey"), guide = "none") +
          geom_text(data = meter_grid_labels,
                    aes(x = (true_low + true_upp)/2, y = y_meter1_base + h + 0.15, label = y_i),
                    size = 3, color = "black") +
          
          # Meter 2: Postulated
          annotate("text", x = -0.05, y = y_meter2_base + h/2, label = "Postulated Model:", 
                   size=4, hjust=1, fontface="bold") +
          geom_rect(aes(xmin=0, xmax=1, ymin=y_meter2_base, ymax=y_meter2_base + h), 
                    fill="white", color="black", size=0.3) +
          geom_rect(aes(xmin = 1 - curr$S_y, xmax = 1, ymin = y_meter2_base, ymax = y_meter2_base + h), 
                    fill = col_S) + 
          geom_rect(aes(xmin = 1 - curr$rsp, xmax = 1 - curr$S_y, ymin = y_meter2_base, ymax = y_meter2_base + h), 
                    fill = col_U) + 
          geom_rect(data = meter_grid, aes(xmin = post_low, xmax = post_upp, 
                                           ymin = y_meter2_base, ymax = y_meter2_base + h),
                    fill = NA, color = "black", size = 0.2) +
          geom_text(data = meter_grid_labels,
                    aes(x = (post_low + post_upp)/2, y = y_meter2_base + h + 0.15, label = y_i),
                    size = 3, color = "black") +
          
          # --- RSP Points (History) ---
          geom_point(data = past %>% filter(id != i), 
                     aes(x = 1 - rsp, y = y_meter2_base - 0.15), 
                     color = col_rsp_past, size = 2) +
          geom_point(aes(x = 1 - curr$rsp, y = y_meter2_base - 0.15), 
                     color = col_curr, size = 4) +
          
          geom_text(aes(x = 1 - (curr$rsp / 2), y = y_meter2_base - 0.45, label = paste0("RSP = ", round(curr$rsp, 3))),
                    color = "black", size = 3.5) +
          
          scale_x_continuous(limits = c(-0.35, 1), expand = c(0,0)) +
          scale_y_continuous(limits = c(-0.6, 2.5), expand = c(0,0)) +
          theme_void() + theme(plot.margin = unit(c(0.5, 0.5, 0.2, 0.5), "cm"))
        
        # --- B. Top Plot (NB) ---
        shade_S <- df_post %>% filter(x > curr$y)
        rect_U <- data.frame(xmin = (curr$y + 0.5) - curr$u, xmax = curr$y + 0.5, 
                             ymin = 0, ymax = dnbinom(curr$y, mu = mu_postulated, size = size_val))
        
        p_nb <- ggplot() +
          geom_rect(data = shade_S, aes(xmin=x-0.5, xmax=x+0.5, ymin=0, ymax=prob, fill = "S"), alpha = 1) +
          geom_rect(data = rect_U, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill = "U"), alpha = 1) +
          
          geom_step(data = df_post, aes(x = x - 0.5, y = prob, linetype = "Postulated"), 
                    direction = "hv", color = "black", size = 1.2) +
          geom_segment(aes(x = max(df_post$x) + 0.5, xend = max(df_post$x) + 0.5, 
                           y = df_post$prob[nrow(df_post)], yend = 0), linetype = "dashed", size = 1.2) +
          
          geom_step(data = df_true, aes(x = x - 0.5, y = prob, linetype = "True"), 
                    direction = "hv", color = "black", size = 0.8) +
          geom_segment(aes(x = max(df_true$x) + 0.5, xend = max(df_true$x) + 0.5, 
                           y = df_true$prob[nrow(df_true)], yend = 0), linetype = "solid") +
          
          geom_point(aes(x = curr$y, y = 0), shape = 1, size = 3, stroke = 1.5) +
          
          # --- MODIFIED: SCALE_FILL_MANUAL (Legend Enabled) ---
          scale_fill_manual(name = NULL, # Remove title to save space or keep "Area"
                            values = c("S" = col_S, "U" = col_U), 
                            labels = c("S" = expression(S[i](y[i])), "U" = expression(U[i] %*% p[i](y[i]))),
                            guide = guide_legend(override.aes = list(alpha = 1))) +
          
          scale_linetype_manual(name = NULL, values = c("True" = "solid", "Postulated" = "dashed")) +
          
          scale_x_continuous(breaks = seq(0, 50, by = 2), expand = c(0,0)) +
          scale_y_continuous(expand = c(0,0)) + 
          coord_cartesian(xlim = xlim_top, ylim = ylim_top, clip = "off") +
          labs(title = bquote(paste("NB (True ", mu==.(mu_true), ", Post. ", mu==.(mu_postulated), "): ", y[i] == .(curr$y))), y = "Probability", x = expression(y[i])) + 
          theme_minimal() + common_margin +
          theme(legend.position = c(0.9, 0.95), legend.justification = c(0, 1),
                legend.background = element_rect(fill = "white", color = NA), legend.box = "vertical",
                legend.margin = margin(2, 2, 2, 2), legend.spacing.y = unit(0, "cm"))
        
        # --- C. Bottom Plot (Z) ---
        shade_norm <- df_norm %>% filter(x >= curr$z)
        p_z <- ggplot() +
          geom_line(data = df_norm, aes(x = x, y = dens)) +
          geom_area(data = shade_norm, aes(x = x, y = dens), fill = col_Z) +
          geom_point(data = past %>% filter(id != i), aes(x = z, y = 0), color = col_past, size = 2) +
          geom_point(aes(x = curr$z, y = 0), color = col_curr, size = 4) +
          scale_x_continuous(limits = xlim_bot, expand = c(0,0)) +
          coord_cartesian(xlim = c(-3, 3), ylim = c(0, 0.45), clip = "off") + 
          labs(title = bquote(paste("Standard Normal: ", z[i] == .(round(curr$z, 2)))), y = "Density", x = expression(z[i])) + 
          theme_minimal() + common_margin + theme(legend.position = "none")
        
        # --- D. Assembly ---
        plots_aligned <- align_plots(p_nb, p_z, align = 'v', axis = 'lr')
        print(plot_grid(p_meter, plots_aligned[[1]], plots_aligned[[2]], ncol = 1, rel_heights = c(0.6, 1.2, 1)))
      }
    }, output = anim_full_path, width = 1600, height = 1600, res = 200, framerate = 0.5)
    
    message("Generated: ", anim_full_path)
  }
}

```


```{r copy-videos}
#| include: false

# Define filenames
vid1 <- "z_residual_anim-correct.mp4"
vid2 <- "z_residual_anim-wrong.mp4"

# Copy files from extdata to the project root (or a specific 'assets' folder)
# We use invisible() to suppress the "TRUE" output
invisible(file.copy(from = file.path(extdata_path, vid1), to = vid1, overwrite = TRUE))
invisible(file.copy(from = file.path(extdata_path, vid2), to = vid2, overwrite = TRUE))
```

## Z-residuals

The **Zresidual** package implements diagnostic residuals based on the **predictive distribution** of each observation. By utilizing the full probabilistic information of the model, the package generates residuals that are approximately normally distributed. This allows for standard diagnostic techniques similar to using Pearson residuals in OLS regression.

### RSP

For a given observation $y_i$, the **Randomized Survival Probability (RSP)**—also known as the randomized probability integral transform—represents the value of the predictive survival function (upper-tail probability) at $y_i$, adjusted with a randomization term to ensure continuity for discrete outcomes. It is defined as:

$$RSP_i(y_i \mid \theta) = S_i(y_i \mid \theta) + U_i \, p_i(y_i \mid \theta)$${#eq-rsp}

where $S_i$ and $p_i$ represent the survival function and probability mass function, respectively, derived from the predictive distribution of $y_i$ given covariates $\mathbf{x}_i$ and parameters $\theta$. $U_i \sim \text{Unif}(0,1)$ is a random uniform variable used to smooth discrete outcomes. Under a correctly specified model—where the observed data $y_i$ arises from the assumed predictive distribution—the RSP follows a $\text{Unif}(0,1)$ distribution.
 
### Z-residual
 
The Z-residual (aka **randomized quantile residual**) is derived by transforming the RSP via the inverse survival function of $N(0,1)$:

$$z_i(y_i \mid \theta) = -\Phi^{-1}\left(RSP_i(y_i \mid \theta)\right)= \Psi^{-1}\left(RSP_i(y_i \mid \theta)\right)$${#eq-zs}

where $\Psi^{-1}(p) = -\Phi^{-1}(p) = \Phi^{-1}(1-p)$ represents the inverse survival function (upper-tailed quantile) of the standard normal distribution $N(0,1)$.

In words, the Z-residual is simply the $N(0,1)$ value that shares the same **upper-tail area (RSP)** as the observed $y_i$. This transformation effectively maps any predictive distribution to the standard normal scale while preserving the tail probabilities. If the model is correct, the resulting Z-residuals follow a standard normal distribution.

**Intuition:** 

Think of the Z-residual as the **distance to the median**, but **rescaled** to account for skewness and **smoothed** to handle discreteness. This ensures that a residual of $+2$ always implies the same degree of 'extremeness', regardless of the original distribution's shape.

## Z-residuals of a True Model

The animation in **@fig-aniz-true** demonstrates this transformation for $y_i$ using its true predictive distribution. As more points are simulated, the distribution of $z_i$ values (shown by the accumulating points) aligns with the theoretical $N(0,1)$ density curve.

::: {#fig-aniz-true}

```{=html}
<div style="display: flex; justify-content: center; margin-bottom: 10px;">
  <video width="80%" controls loop autoplay muted playsinline>
    <source src="z_residual_anim-correct.mp4" type="video/mp4">
  </video>
</div>
```

Animation of Z-residuals of a correct model. 
The meters compare the **True Generation** ($\mu=5$) with the **Postulated Model** ($\mu=5$). The blue bar represents the **RSP** (upper-tail area), calculated as the survival probability $S(y)$ plus a random fraction of the probability mass $p(y)$. Because the models match, the resulting Z-residuals (red dots) map perfectly to the standard normal distribution, confirming the model fit.
::: 



## Z-residuals of a Wrong Model

The animation in **@fig-aniz-wrong** demonstrates the behavior of Z-residuals when the model is misspecified. Here, the data $y_i$ are simulated from a **True Model** (Negative Binomial with $\mu=2$), but the residuals are calculated based on a **Postulated Model** (Negative Binomial with $\mu=5$).

We can see that the observed data (solid bars) fall systematically to the left of the expected distribution (dashed bars). Because the observed values are smaller than expected, the calculated $RSP$ values are consistently high (upper tail area is large), resulting in $z_i$ values that drift toward the negative side of the standard normal distribution.

::: {#fig-aniz-wrong}

```{=html}
<div style="display: flex; justify-content: center; margin-bottom: 10px;">
  <video width="80%" controls loop autoplay muted playsinline>
    <source src="z_residual_anim-wrong.mp4" type="video/mp4">
  </video>
</div>
```

Animation of Z-residual of a wrong model. 
Data is generated from a True Model with $\mu=2$, but residuals are calculated using a Postulated Model with $\mu=5$. The observed values $y_i$ are more likely smaller than expected, resulting in **RSP values** (blue bars) that are too large for the assumed distribution. Consequently, the Z-residuals drift systematically to the left (negative bias), signaling that the model overestimates the mean.
:::

